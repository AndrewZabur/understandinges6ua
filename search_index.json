{"index":{"version":"0.5.12","fields":[{"name":"title","boost":10},{"name":"body","boost":1}],"ref":"url","documentStore":{"store":{"./":["2014","2016","3.0","4149","4378","5","5069","5501","6","arrow","c","cc","deni","dovhan","ecmascript","ecmasctipt","epub","issu","javascript","leanpub","map","mobi","nc","nd","nichola","node.j","o","oзвo","pdf","permiss","press","pull","request","sahaidak","set","starch","terri","translat","zaka"],"manuscript/00-Introduction.html":["1","10","11","12","13","1999","2","2007","2008","2015","262","3","3.1","39","4","5","6","7","8","9","ajax","api","arrow","const","ecma","ecmascript","googl","harmoni","http://groups.google.com/group/zakasbook","https://github.com/denysdovhan/understandinges6ua","https://github.com/nzakas/understandinges6","javascript","json","map","microsoft","node.j","pull","request","set","tc","var","weakmap","weakset","yahoo"],"manuscript/01-Block-Bindings.html":["0","1","10","2","2015","25","30","39","40","5","6","9","ag","b","c","code","condit","console.log(&quot;ncz&quot","console.log(i","console.log(key","console.log(ncz","console.log(regexp","console.log(typeof","console.log(valu","console.log(window.ncz","console.log(window.regexp","const","count","doesn&#39;t","ecmascript","exist","express","fals","fon","func","funcs.foreach(function(func","funcs.push((function(valu","funcs.push(funct","function","getvalu","getvalue(condit","gt","here","i=0","iif","immedi","invok","javascript","key","lt","lеt","maxitem","messag","more","name","ncz","non","null","nzt","object","person","person.nam","process(items[i","quot;10&quot","quot;a&quot","quot;b&quot","quot;blue&quot","quot;c&quot","quot;goodbye!&quot","quot;greg&quot","quot;hello!&quot","quot;hi!&quot","quot;nicholas&quot","quot;undefined&quot","regexp","return","strict","true","typeof","undefin","valu","var","w&gt","window","windows.regexp"],"manuscript/02-Strings-and-Regular-Expressions.html":["0","0.25","0xffff","1","10","12","134071","14","16","17","2","2.50.&quot","2^16","3","31","32","39","4","5","55362","57271","6","7","8","97","a&gt","ab/g","ab/i","c.codepointat(0","canon","catch","charat","charcodeat","code","codepointat","codepointlength(text","compat","composit","console.log","console.log(&quot;abc&quot;.repeat(4","console.log(&quot;hello&quot;.repeat(2","console.log(&quot;x&quot;.repeat(3","console.log(/^.$/.test(text","console.log(/^.$/u.test(text","console.log(codepointlength(&quot;abc&quot","console.log(codepointlength(&quot;𠮷bc&quot","console.log(getflags(r","console.log(globalpattern.lastindex","console.log(globalresult[0","console.log(is32bit(&quot;a&quot","console.log(is32bit(&quot;𠮷&quot","console.log(messag","console.log(message.length","console.log(message1","console.log(message2","console.log(msg.endswith(&quot;!&quot","console.log(msg.endswith(&quot;o&quot","console.log(msg.endswith(&quot;world!&quot","console.log(msg.includes(&quot;o&quot","console.log(msg.includes(&quot;x&quot","console.log(msg.startswith(&quot;hello&quot","console.log(msg.startswith(&quot;o&quot","console.log(pattern.lastindex","console.log(pattern.sticki","console.log(re.flag","console.log(re.sourc","console.log(re1.test(&quot;ab&quot","console.log(re1.tostr","console.log(re2.test(&quot;ab&quot","console.log(re2.tostr","console.log(result[0","console.log(stickypattern.lastindex","console.log(stickyresult[0","console.log(string.fromcodepoint(134071","console.log(text.charat(0","console.log(text.charat(1","console.log(text.charcodeat(0","console.log(text.charcodeat(1","console.log(text.charcodeat(2","console.log(text.codepointat(0","console.log(text.codepointat(1","console.log(text.codepointat(2","console.log(text.length","console.log(typeof","cost","count","decomposit","dsl","ecmascript","endswith","error","es5","es6","escap","ex","exec","express","fals","ffff","firefox","first","first.norm","first.normalize(&quot;nfd&quot","firstnorm","flag","form","function","g","getflags(r","globalpattern","globalpattern.exec(text","globalpattern.lastindex","globalresult","gt","hasregexpi","hasregexpu","hello","hello2","hello3&quot","hello\\d/i","hello\\d\\","hello\\d\\s?/g","hello\\d\\s?/i","html","i&gt","includ","indent","indent.repeat(++indentlevel","indentlevel","indexof","instead","is32bit(c","item","javascript","javascript&#39;","join(&quot;\\n&quot","lastindex","lastindexof","length","liter","literals.length","literals.raw","literals.raw[0","literals.raw[i","literals.raw[literals.length","literals[0","literals[i","literals[literals.length","lt","lt;/div&gt;`.trim","lt;div&gt","lt;h1&gt;title&lt;/h1&gt","match","messag","message1","message2","msg","msg.endswith(&quot;o&quot","msg.includes(&quot;o&quot","msg.startswith(&quot;o&quot","multilin","multiline\\nstr","n","n&quot","name","new","newind","nfc","nicholas.&quot","normal","normalized.sort(function(first","null","passthru","passthru(liter","passthru`${count","pattern","pattern.exec(text","pattern.lastindex","point","price","price).tofixed(2","quot","quot;&quot","quot;.&quot","quot;.repeat(4","quot;/ab/g&quot","quot;/ab/i&quot","quot;10","quot;2.50&quot","quot;\\\\n&quot","quot;`hello","quot;a&quot","quot;ab&quot","quot;abc&quot","quot;abcabcabcabc&quot","quot;ae&quot","quot;e&quot","quot;g&quot","quot;hello","quot;hello&quot","quot;hello1","quot;hello2","quot;hellohello&quot","quot;multilin","quot;multiline\\\\nstring&quot","quot;nfc&quot","quot;nfd&quot","quot;nfkc&quot","quot;nfkd&quot","quot;nicholas&quot","quot;o&quot","quot;r&quot","quot;string&quot","quot;u&quot","quot;world&quot","quot;xxx&quot","quot;y&quot","quot;æ&quot","quot;𠮷&quot","quot;𠮷a&quot","quot;𠮷bc&quot","raw","raw(liter","raw`multiline\\nstr","re","re.tostr","re1","re2","regexp","regexp(&quot;.&quot","regexp(re1","regular","repeat","result","result.length","return","second","second.norm","second.normalize(&quot;nfd&quot","secondnorm","sourc","sql","startswith","sticki","stickypattern","stickypattern.exec(text","stickypattern.lastindex","stickyresult","strawman","string","string&quot","string.fromcharcod","string.fromcodepoint","string.raw","string.raw`multiline\\nstr","substitut","substitutions.length","substitutions[i","tag","tag(liter","tag`hello","templat","test","text","text.length","text.match(/[\\s\\s]/gu","text.norm","text.substring(text.lastindexof(&quot;/&quot","tofix","tostr","tri","trim","true","u","uc","unicod","unit","us","utf","valu","values.map(function(text","values.sort(function(first","var","w&gt","world","world!&quot","xss","y"],"manuscript/03-Functions.html":["0","1","100","2","2000","2015","25","3","39","39;new&#39","4","5","50","500","6","6&quot","7","75","add","add(1","add(first","add(undefin","anotherperson","anotherperson(&quot;nicholas&quot","anotherperson(nam","appli","args[0]&quot","argument","arguments.length","arguments[0","arguments[1","arraw","array","arrow","arrowfunct","author","b","bind","bind(thi","book","bookdata","boundsum","c","call","callback","can&#39;t","checkarg","checkargs(&quot;a&quot","checkargs(...arg","compar","console.log","console.log(&quot;handl","console.log((new","console.log(add(1","console.log(add(undefin","console.log(args.length","console.log(args[0","console.log(args[1","console.log(arguments.length","console.log(arrowfunct","console.log(bookdata.author","console.log(bookdata.year","console.log(boundsum","console.log(compar","console.log(doanotherthing.nam","console.log(dosomething.bind().nam","console.log(dosomething.nam","console.log(first","console.log(math.max(...valu","console.log(math.max(25","console.log(math.max(value1","console.log(math.max.apply(math","console.log(notaperson","console.log(person","console.log(person.firstname.nam","console.log(person.getnam","console.log(person.sayname.nam","console.log(pickfirst(1","console.log(second","console.log(sum.apply(nul","console.log(sum.call(nul","console.log(this.nam","console.log(typeof","const","construct","createarrowfunctionreturningfirstarg","createarrowfunctionreturningfirstarg(5","doanotherth","document","document.addeventlistener(&quot;click&quot","donoth","dosometh","dosomething&quot","dosomething(bodi","dosomething.nam","dosomethingels","ecmascript","error","error(&quot;y","es5","es6","event","factori","factorial(n","fals","first","first&quot","firstnam","firstname&quot","func","function","function(&quot;...args&quot","function(&quot;first&quot","function()).nam","function(bodi","function(ev","function(id","function(nam","function(num1","function(typ","function(valu","getnam","gettempitem","getvalu","getvalue(first","getvalue(valu","gt","i&gt","id","init","instanceof","javascript","key","keys.length","last","len","length","lt","makerequest","makerequest(&quot;/foo&quot","makerequest(url","map","math.max","math.max.appli","mixarg","mixargs(&quot;a&quot","mixargs(first","mode","mytyp","n","name","name(...valu","new","new.target","nonstrict","notaperson","null","num","num1","num2","object","object.create(nul","object[arguments[i","object[keys[i","object]&quot","p","pagehandl","param","paramet","person","person(&quot;nicholas&quot","person(nam","person.&quot","person.cal","person.call(person","person.call(thi","person.firstnam","person.saynam","pick","pick(book","pick(object","pickfirst","prototyp","quot","quot;/foo&quot","quot;123456&quot","quot;[object","quot;anonymous&quot","quot;arrow&quot","quot;author&quot","quot;b&quot","quot;bound","quot;bound&quot","quot;c&quot","quot;d&quot","quot;doanotherthing&quot","quot;dosomething&quot","quot;dosomethingelse&quot","quot;function&quot","quot;get","quot;michael&quot","quot;nichola","quot;nicholas&quot","quot;return","quot;sayname&quot","quot;second","quot;second&quot","quot;set&quot","quot;temp&quot","quot;undefined&quot","quot;understand","quot;us","quot;year&quot","reduc","reflect","rest","result","result[arguments[i","result[keys[i","return","rrow","saynam","second","second&quot","set","setter","sort","spread","strict","strict&quot","sum","sum.bind(nul","super","syntax","tail","this.dosometh","this.dosomething(event.typ","this.id","this.nam","throw","timeout","titl","true","type","typeof","undefin","underscore.j","url","us","valu","value1","value2","values.sort((a","values.sort(function(a","var","w&gt","year","zakas&quot"],"manuscript/04-Objects.html":["0","1","12","2","39","5","6","a&gt","ag","array","assign","b","c","call(thi","console.log(+0","console.log(5","console.log(descriptor.get","console.log(descriptor.valu","console.log(friend.getgreet","console.log(nan","console.log(object.getownpropertynames(obj).join(&quot;&quot","console.log(object.getprototypeof(friend","console.log(object.is(+0","console.log(object.is(5","console.log(object.is(nan","console.log(person.getgreet","console.log(person.nam","console.log(person[&quot;first","console.log(person[&quot;last","console.log(person[lastnam","console.log(receiver.nam","console.log(receiver.typ","console.log(relative.getgreet","console.log(this.nam","constructor","createperson","createperson(nam","d","date","descriptor","dog","ecmascript","emit","error","es5","es6","eventtarget","eventtarget.prototyp","extend","fals","friend","friend.getgreet","friend.getgreeting().cal","function","getglobalgreet","getgreet","hi!&quot","homeobject","i&gt","isnan","javascript","json","json.stringifi","lastnam","mix","mixin","mixin(myobject","mixin(receiv","myobject","myobject.emit(&quot;somethingchanged&quot","name","name&quot","nan","node.j","obj","obj.d","object","object.assign","object.assign(myobject","object.assign(receiv","object.cr","object.create(friend","object.create(person","object.getownpropertydescriptor(receiv","object.getownpropertynam","object.getprototypeof","object.getprototypeof(thi","object.getprototypeof(this).getgreeting.call(thi","object.i","object.key","object.keys(supplier).foreach(function(key","object.mixin","object.prototyp","object.setprototypeof","object.setprototypeof(friend","person","person.getgreet","person.nam","person.saynam","person[&quot;first","person[lastnam","prototyp","quot","quot;012acbd&quot","quot;5&quot","quot;css&quot","quot;file.js&quot","quot;first","quot;first&quot","quot;greg&quot","quot;hello","quot;hello&quot","quot;hi!&quot","quot;js&quot","quot;last","quot;last&quot","quot;name&quot","quot;nicholas&quot","quot;sayname&quot","quot;us","quot;woof","quot;woof&quot","quot;zakas&quot","quot;ім&#39","receiv","receiver.nam","receiver.typ","receiver[key","reflect.ownkey","rel","relative.getgreet","return","saynam","section","sharegreet","strict&quot","suffix","super","super&quot","super.getgreet","supplier","supplier.nam","supplier[key","true","type","undefin","var","w&gt","yo!&quot"],"manuscript/05-Destructuring.html":["0","1","2","3","360000000","39","4","5","6","60000","a&gt","b","clonedcolor","color","colors.concat","column","concat","console.log(a","console.log(b","console.log(clonedcolor","console.log(firstcolor","console.log(localnam","console.log(localstart.column","console.log(localstart.lin","console.log(localtyp","console.log(nam","console.log(restcolors.length","console.log(restcolors[0","console.log(restcolors[1","console.log(secondcolor","console.log(start.column","console.log(start.lin","console.log(startindex","console.log(thirdcolor","console.log(typ","console.log(valu","const","cooki","date(date.now","destructur","domain","ecmascript","end","error","expir","fals","firstcolor","function","gt","javascript","json","line","loc","localnam","localstart","localtyp","name","new","node","node.loc.start","node.nam","node.range[0","node.typ","node.valu","null","option","options.domain","options.expir","options.path","options.repeat","options.sav","options.secur","outputinfo","outputinfo(valu","path","quot;/&quot","quot;[red,green,blue]&quot","quot;bar&quot","quot;black&quot","quot;blue&quot","quot;example.com&quot","quot;foo&quot","quot;green&quot","quot;identifier&quot","quot;js&quot","quot;lightgreen&quot","quot;literal&quot","quot;purple&quot","quot;red&quot","rang","repeat","rest","restcolor","save","secondcolor","secur","setcooki","setcookie(&quot;type&quot","setcookie(nam","start","startindex","syntax","thirdcolor","tmp","true","type","undefin","valu","var","w&gt"]},"length":7},"tokenStore":{"root":{"0":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.011682242990654205},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.012896825396825396},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.006825938566552901},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.012362637362637362},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0034904013961605585}},".":{"2":{"5":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.002976190476190476}}},"docs":{}},"docs":{}},"x":{"docs":{},"f":{"docs":{},"f":{"docs":{},"f":{"docs":{},"f":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}},"1":{"0":{"0":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.004095563139931741}}},"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542},"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.02102803738317757},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968}}},"1":{"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542}}},"2":{"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}},"3":{"4":{"0":{"7":{"1":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}},"docs":{}},"docs":{}},"docs":{}},"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542}}},"4":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968}}},"6":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.026785714285714284}}},"7":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}},"9":{"9":{"9":{"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542}}},"docs":{}},"docs":{}},"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542},"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.004672897196261682},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.015873015873015872},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.034129692832764506},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.012362637362637362},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.03315881326352531}}},"2":{"0":{"0":{"0":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0034129692832764505}}},"7":{"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542}}},"8":{"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542}}},"docs":{}},"1":{"4":{"docs":{"./":{"ref":"./","tf":0.016666666666666666}}},"5":{"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.015267175572519083},"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.002336448598130841},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}},"6":{"docs":{"./":{"ref":"./","tf":0.016666666666666666}}},"docs":{}},"docs":{}},"5":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.002336448598130841},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0027303754266211604}}},"6":{"2":{"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.030534351145038167}}},"docs":{}},"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542},"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.004672897196261682},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.005952380952380952},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.013651877133105802},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.008726003490401396}},".":{"5":{"0":{"docs":{},".":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}}}}}}},"docs":{}},"docs":{}},"^":{"1":{"6":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}},"docs":{}},"docs":{}}},"3":{"0":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.009345794392523364}}},"1":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}},"2":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}},"6":{"0":{"0":{"0":{"0":{"0":{"0":{"0":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0017452006980802793}}},"docs":{}},"docs":{}},"docs":{}},"docs":{}},"docs":{}},"docs":{}},"docs":{}},"9":{"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.022900763358778626},"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.06775700934579439},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0034904013961605585}},";":{"docs":{},"n":{"docs":{},"e":{"docs":{},"w":{"docs":{},"&":{"docs":{},"#":{"3":{"9":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}},"docs":{}},"docs":{}}}}}}}},"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0027303754266211604},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.005235602094240838}},".":{"0":{"docs":{"./":{"ref":"./","tf":0.016666666666666666}}},"1":{"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.05343511450381679}}},"docs":{}}},"4":{"0":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.004672897196261682}}},"1":{"4":{"9":{"docs":{"./":{"ref":"./","tf":0.016666666666666666}}},"docs":{}},"docs":{}},"3":{"7":{"8":{"docs":{"./":{"ref":"./","tf":0.016666666666666666}}},"docs":{}},"docs":{}},"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.061068702290076333},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0020477815699658703},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.006980802792321117}}},"5":{"0":{"0":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}},"6":{"9":{"docs":{"./":{"ref":"./","tf":0.016666666666666666}}},"docs":{}},"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.004095563139931741}}},"5":{"0":{"1":{"docs":{"./":{"ref":"./","tf":0.016666666666666666}}},"docs":{}},"3":{"6":{"2":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}},"docs":{}},"docs":{}},"docs":{}},"7":{"2":{"7":{"1":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.002976190476190476}}},"docs":{}},"docs":{}},"docs":{}},"docs":{"./":{"ref":"./","tf":0.03333333333333333},"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.030534351145038167},"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.004672897196261682},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.007936507936507936},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.013651877133105802},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.02197802197802198},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.012216404886561954}}},"6":{"0":{"0":{"0":{"0":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0034904013961605585}}},"docs":{}},"docs":{}},"docs":{}},"docs":{"./":{"ref":"./","tf":3.4166666666666665},"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.06870229007633588},"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.02570093457943925},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.026785714285714284},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.029351535836177476},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.04532967032967033},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.013961605584642234}},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}},"7":{"5":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0027303754266211604}}},"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0034129692832764505}}},"8":{"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.005952380952380952}}},"9":{"7":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}},"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542},"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.009345794392523364}}},"docs":{},"a":{"docs":{},"r":{"docs":{},"r":{"docs":{},"o":{"docs":{},"w":{"docs":{"./":{"ref":"./","tf":0.016666666666666666},"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.03686006825938567}},"f":{"docs":{},"u":{"docs":{},"n":{"docs":{},"c":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}},"a":{"docs":{},"w":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}},"y":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}},"g":{"docs":{},"s":{"docs":{},"[":{"0":{"docs":{},"]":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}},"docs":{}}},"u":{"docs":{},"m":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.025938566552901023}},"s":{"docs":{},".":{"docs":{},"l":{"docs":{},"e":{"docs":{},"n":{"docs":{},"g":{"docs":{},"t":{"docs":{},"h":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}}}}},"[":{"0":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.007508532423208191}}},"1":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0061433447098976105}}},"docs":{}}}}}}}}}},"j":{"docs":{},"a":{"docs":{},"x":{"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542}}}}},"p":{"docs":{},"i":{"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542}}},"p":{"docs":{},"l":{"docs":{},"i":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.005460750853242321}}}}}},"g":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.004672897196261682},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.01098901098901099}}},"&":{"docs":{},"g":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.004120879120879121},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.010471204188481676}}}}},"b":{"docs":{},"/":{"docs":{},"g":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}},"i":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.002976190476190476}}}}},"d":{"docs":{},"d":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0034129692832764505}},"(":{"1":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.008873720136518772}}},"docs":{},"f":{"docs":{},"i":{"docs":{},"r":{"docs":{},"s":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.00477815699658703}}}}}}},"u":{"docs":{},"n":{"docs":{},"d":{"docs":{},"e":{"docs":{},"f":{"docs":{},"i":{"docs":{},"n":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0020477815699658703}}}}}}}}}}}},"n":{"docs":{},"o":{"docs":{},"t":{"docs":{},"h":{"docs":{},"e":{"docs":{},"r":{"docs":{},"p":{"docs":{},"e":{"docs":{},"r":{"docs":{},"s":{"docs":{},"o":{"docs":{},"n":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}},"(":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},"n":{"docs":{},"i":{"docs":{},"c":{"docs":{},"h":{"docs":{},"o":{"docs":{},"l":{"docs":{},"a":{"docs":{},"s":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}}}}}}}}}}}}}}}}},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}}}}}}}}},"u":{"docs":{},"t":{"docs":{},"h":{"docs":{},"o":{"docs":{},"r":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}},"s":{"docs":{},"s":{"docs":{},"i":{"docs":{},"g":{"docs":{},"n":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}},"c":{"docs":{"./":{"ref":"./","tf":0.016666666666666666},"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.009345794392523364},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475}},"c":{"docs":{"./":{"ref":"./","tf":0.016666666666666666}}},"o":{"docs":{},"n":{"docs":{},"s":{"docs":{},"t":{"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542},"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.11448598130841121},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.008726003490401396}},"r":{"docs":{},"u":{"docs":{},"c":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.007508532423208191}},"o":{"docs":{},"r":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475}}}}}}}}},"o":{"docs":{},"l":{"docs":{},"e":{"docs":{},".":{"docs":{},"l":{"docs":{},"o":{"docs":{},"g":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}},"(":{"5":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.005494505494505495}}},"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},"n":{"docs":{},"c":{"docs":{},"z":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.002336448598130841}}}}}}}}}},"a":{"docs":{},"b":{"docs":{},"c":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},".":{"docs":{},"r":{"docs":{},"e":{"docs":{},"p":{"docs":{},"e":{"docs":{},"a":{"docs":{},"t":{"docs":{},"(":{"4":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}},"docs":{}}}}}}}}}}}}}}}}}},"h":{"docs":{},"e":{"docs":{},"l":{"docs":{},"l":{"docs":{},"o":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},".":{"docs":{},"r":{"docs":{},"e":{"docs":{},"p":{"docs":{},"e":{"docs":{},"a":{"docs":{},"t":{"docs":{},"(":{"2":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}},"docs":{}}}}}}}}}}}}}}}}}}},"a":{"docs":{},"n":{"docs":{},"d":{"docs":{},"l":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0020477815699658703}}}}}}},"x":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},".":{"docs":{},"r":{"docs":{},"e":{"docs":{},"p":{"docs":{},"e":{"docs":{},"a":{"docs":{},"t":{"docs":{},"(":{"3":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}},"docs":{}}}}}}}}}}}}}}}}}}}}}},"i":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.014018691588785047}},"s":{"3":{"2":{"docs":{},"b":{"docs":{},"i":{"docs":{},"t":{"docs":{},"(":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},"a":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}},"�":{"docs":{},"�":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}}}}}}},"docs":{}},"docs":{}}},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.004672897196261682}}}}},"n":{"docs":{},"c":{"docs":{},"z":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.002336448598130841}}}},"o":{"docs":{},"t":{"docs":{},"a":{"docs":{},"p":{"docs":{},"e":{"docs":{},"r":{"docs":{},"s":{"docs":{},"o":{"docs":{},"n":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}},"a":{"docs":{},"n":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475}}},"m":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.008726003490401396}}}}},"r":{"docs":{},"e":{"1":{"docs":{},".":{"docs":{},"t":{"docs":{},"e":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},"a":{"docs":{},"b":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}}}}}}}}}}}}}}}}},"o":{"docs":{},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}},"2":{"docs":{},".":{"docs":{},"t":{"docs":{},"e":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},"a":{"docs":{},"b":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}}}}}}}}}}}}}}}}},"o":{"docs":{},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}},"docs":{},"g":{"docs":{},"e":{"docs":{},"x":{"docs":{},"p":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.002336448598130841}}}}}},".":{"docs":{},"f":{"docs":{},"l":{"docs":{},"a":{"docs":{},"g":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}},"s":{"docs":{},"o":{"docs":{},"u":{"docs":{},"r":{"docs":{},"c":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}},"s":{"docs":{},"u":{"docs":{},"l":{"docs":{},"t":{"docs":{},"[":{"0":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968}}},"docs":{}}}}},"t":{"docs":{},"c":{"docs":{},"o":{"docs":{},"l":{"docs":{},"o":{"docs":{},"r":{"docs":{},"s":{"docs":{},".":{"docs":{},"l":{"docs":{},"e":{"docs":{},"n":{"docs":{},"g":{"docs":{},"t":{"docs":{},"h":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0017452006980802793}}}}}}}}},"[":{"0":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0017452006980802793}}},"1":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0017452006980802793}}},"docs":{}}}}}}}}}},"c":{"docs":{},"e":{"docs":{},"i":{"docs":{},"v":{"docs":{},"e":{"docs":{},"r":{"docs":{},".":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}},"t":{"docs":{},"y":{"docs":{},"p":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}}}}}},"l":{"docs":{},"a":{"docs":{},"t":{"docs":{},"i":{"docs":{},"v":{"docs":{},"e":{"docs":{},".":{"docs":{},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"g":{"docs":{},"r":{"docs":{},"e":{"docs":{},"e":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475}}}}}}}}}}}}}}}}}}},"t":{"docs":{},"y":{"docs":{},"p":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.008726003490401396}},"e":{"docs":{},"o":{"docs":{},"f":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.004672897196261682},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.00477815699658703}}}}}}},"e":{"docs":{},"x":{"docs":{},"t":{"docs":{},".":{"docs":{},"c":{"docs":{},"h":{"docs":{},"a":{"docs":{},"r":{"docs":{},"a":{"docs":{},"t":{"docs":{},"(":{"0":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}},"1":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}},"docs":{}}}},"c":{"docs":{},"o":{"docs":{},"d":{"docs":{},"e":{"docs":{},"a":{"docs":{},"t":{"docs":{},"(":{"0":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}},"1":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}},"2":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}},"docs":{}}}}}}}}}}},"o":{"docs":{},"d":{"docs":{},"e":{"docs":{},"p":{"docs":{},"o":{"docs":{},"i":{"docs":{},"n":{"docs":{},"t":{"docs":{},"a":{"docs":{},"t":{"docs":{},"(":{"0":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}},"1":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}},"2":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}},"docs":{}}}}}}}}}}}}},"l":{"docs":{},"e":{"docs":{},"n":{"docs":{},"g":{"docs":{},"t":{"docs":{},"h":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}}}}}}}}}},"h":{"docs":{},"i":{"docs":{},"s":{"docs":{},".":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475}}}}}}},"r":{"docs":{},"d":{"docs":{},"c":{"docs":{},"o":{"docs":{},"l":{"docs":{},"o":{"docs":{},"r":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0017452006980802793}}}}}}}}}}}},"v":{"docs":{},"a":{"docs":{},"l":{"docs":{},"u":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.002336448598130841},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.005235602094240838}}}}}},"w":{"docs":{},"i":{"docs":{},"n":{"docs":{},"d":{"docs":{},"o":{"docs":{},"w":{"docs":{},".":{"docs":{},"n":{"docs":{},"c":{"docs":{},"z":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.002336448598130841}}}}},"r":{"docs":{},"e":{"docs":{},"g":{"docs":{},"e":{"docs":{},"x":{"docs":{},"p":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.004672897196261682}}}}}}}}}}}}}}},"/":{"docs":{},"^":{"docs":{},".":{"docs":{},"$":{"docs":{},"/":{"docs":{},".":{"docs":{},"t":{"docs":{},"e":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"docs":{},"t":{"docs":{},"e":{"docs":{},"x":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}}}}}}}}}},"u":{"docs":{},".":{"docs":{},"t":{"docs":{},"e":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"docs":{},"t":{"docs":{},"e":{"docs":{},"x":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}}}}},"c":{"docs":{},"o":{"docs":{},"d":{"docs":{},"e":{"docs":{},"p":{"docs":{},"o":{"docs":{},"i":{"docs":{},"n":{"docs":{},"t":{"docs":{},"l":{"docs":{},"e":{"docs":{},"n":{"docs":{},"g":{"docs":{},"t":{"docs":{},"h":{"docs":{},"(":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},"a":{"docs":{},"b":{"docs":{},"c":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}},"�":{"docs":{},"�":{"docs":{},"b":{"docs":{},"c":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"m":{"docs":{},"p":{"docs":{},"a":{"docs":{},"r":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}},"l":{"docs":{},"o":{"docs":{},"n":{"docs":{},"e":{"docs":{},"d":{"docs":{},"c":{"docs":{},"o":{"docs":{},"l":{"docs":{},"o":{"docs":{},"r":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0034904013961605585}}}}}}}}}}}}},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"f":{"docs":{},"l":{"docs":{},"a":{"docs":{},"g":{"docs":{},"s":{"docs":{},"(":{"docs":{},"r":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}},"l":{"docs":{},"o":{"docs":{},"b":{"docs":{},"a":{"docs":{},"l":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{},"n":{"docs":{},".":{"docs":{},"l":{"docs":{},"a":{"docs":{},"s":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"d":{"docs":{},"e":{"docs":{},"x":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"s":{"docs":{},"u":{"docs":{},"l":{"docs":{},"t":{"docs":{},"[":{"0":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968}}},"docs":{}}}}}}}}}}}}}},"m":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},"a":{"docs":{},"g":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.010912698412698412}},"e":{"1":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}},"2":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}},"docs":{},".":{"docs":{},"l":{"docs":{},"e":{"docs":{},"n":{"docs":{},"g":{"docs":{},"t":{"docs":{},"h":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.005952380952380952}}}}}}}}}}}}}}},"s":{"docs":{},"g":{"docs":{},".":{"docs":{},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{},"s":{"docs":{},"w":{"docs":{},"i":{"docs":{},"t":{"docs":{},"h":{"docs":{},"(":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},"!":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}},"o":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}},"w":{"docs":{},"o":{"docs":{},"r":{"docs":{},"l":{"docs":{},"d":{"docs":{},"!":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}}}}}}}}}}}}}}},"i":{"docs":{},"n":{"docs":{},"c":{"docs":{},"l":{"docs":{},"u":{"docs":{},"d":{"docs":{},"e":{"docs":{},"s":{"docs":{},"(":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},"o":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}}}}}},"x":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{},"s":{"docs":{},"w":{"docs":{},"i":{"docs":{},"t":{"docs":{},"h":{"docs":{},"(":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},"h":{"docs":{},"e":{"docs":{},"l":{"docs":{},"l":{"docs":{},"o":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}},"o":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}}}}}}}}}}}}}}}}}}}}}}}}}},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},".":{"docs":{},"m":{"docs":{},"a":{"docs":{},"x":{"docs":{},"(":{"2":{"5":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}},"docs":{}},"docs":{},".":{"docs":{},".":{"docs":{},".":{"docs":{},"v":{"docs":{},"a":{"docs":{},"l":{"docs":{},"u":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}}}}},"v":{"docs":{},"a":{"docs":{},"l":{"docs":{},"u":{"docs":{},"e":{"1":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}},"docs":{}}}}}}},".":{"docs":{},"a":{"docs":{},"p":{"docs":{},"p":{"docs":{},"l":{"docs":{},"y":{"docs":{},"(":{"docs":{},"m":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}}}}}}}}}}}},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{},"n":{"docs":{},".":{"docs":{},"l":{"docs":{},"a":{"docs":{},"s":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"d":{"docs":{},"e":{"docs":{},"x":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}}}}}}}}},"s":{"docs":{},"t":{"docs":{},"i":{"docs":{},"c":{"docs":{},"k":{"docs":{},"i":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}},"e":{"docs":{},"r":{"docs":{},"s":{"docs":{},"o":{"docs":{},"n":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}},".":{"docs":{},"f":{"docs":{},"i":{"docs":{},"r":{"docs":{},"s":{"docs":{},"t":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{},"e":{"docs":{},".":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}}}}}},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}},"g":{"docs":{},"r":{"docs":{},"e":{"docs":{},"e":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475}}}}}}}}}},"s":{"docs":{},"a":{"docs":{},"y":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{},"e":{"docs":{},".":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}}}},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}},"[":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},"f":{"docs":{},"i":{"docs":{},"r":{"docs":{},"s":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.005494505494505495}}}}}}},"l":{"docs":{},"a":{"docs":{},"s":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}}}}}},"l":{"docs":{},"a":{"docs":{},"s":{"docs":{},"t":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475}}}}}}}}}}}}}}},"i":{"docs":{},"c":{"docs":{},"k":{"docs":{},"f":{"docs":{},"i":{"docs":{},"r":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"1":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}},"docs":{}}}}}}}}}}},"s":{"docs":{},"t":{"docs":{},"i":{"docs":{},"c":{"docs":{},"k":{"docs":{},"y":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{},"n":{"docs":{},".":{"docs":{},"l":{"docs":{},"a":{"docs":{},"s":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"d":{"docs":{},"e":{"docs":{},"x":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"s":{"docs":{},"u":{"docs":{},"l":{"docs":{},"t":{"docs":{},"[":{"0":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968}}},"docs":{}}}}}}}}}}}},"r":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},".":{"docs":{},"f":{"docs":{},"r":{"docs":{},"o":{"docs":{},"m":{"docs":{},"c":{"docs":{},"o":{"docs":{},"d":{"docs":{},"e":{"docs":{},"p":{"docs":{},"o":{"docs":{},"i":{"docs":{},"n":{"docs":{},"t":{"docs":{},"(":{"1":{"3":{"4":{"0":{"7":{"1":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}},"docs":{}},"docs":{}},"docs":{}},"docs":{}},"docs":{}},"docs":{}}}}}}}}}}}}}}}}}}}},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{},".":{"docs":{},"c":{"docs":{},"o":{"docs":{},"l":{"docs":{},"u":{"docs":{},"m":{"docs":{},"n":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0034904013961605585}}}}}}}},"l":{"docs":{},"i":{"docs":{},"n":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0034904013961605585}}}}}},"i":{"docs":{},"n":{"docs":{},"d":{"docs":{},"e":{"docs":{},"x":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0017452006980802793}}}}}}}}}}},"e":{"docs":{},"c":{"docs":{},"o":{"docs":{},"n":{"docs":{},"d":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.004095563139931741}},"c":{"docs":{},"o":{"docs":{},"l":{"docs":{},"o":{"docs":{},"r":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.006980802792321117}}}}}}}}}}}},"u":{"docs":{},"m":{"docs":{},".":{"docs":{},"a":{"docs":{},"p":{"docs":{},"p":{"docs":{},"l":{"docs":{},"y":{"docs":{},"(":{"docs":{},"n":{"docs":{},"u":{"docs":{},"l":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}},"c":{"docs":{},"a":{"docs":{},"l":{"docs":{},"l":{"docs":{},"(":{"docs":{},"n":{"docs":{},"u":{"docs":{},"l":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}}}}},"(":{"docs":{},"n":{"docs":{},"e":{"docs":{},"w":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}},"a":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0034904013961605585}},"d":{"docs":{},"d":{"docs":{},"(":{"1":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.011604095563139932}}},"docs":{},"u":{"docs":{},"n":{"docs":{},"d":{"docs":{},"e":{"docs":{},"f":{"docs":{},"i":{"docs":{},"n":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}}},"r":{"docs":{},"g":{"docs":{},"s":{"docs":{},".":{"docs":{},"l":{"docs":{},"e":{"docs":{},"n":{"docs":{},"g":{"docs":{},"t":{"docs":{},"h":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}},"[":{"0":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}},"1":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}},"docs":{}}},"u":{"docs":{},"m":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},"s":{"docs":{},".":{"docs":{},"l":{"docs":{},"e":{"docs":{},"n":{"docs":{},"g":{"docs":{},"t":{"docs":{},"h":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}}}}}}}}}}}},"r":{"docs":{},"o":{"docs":{},"w":{"docs":{},"f":{"docs":{},"u":{"docs":{},"n":{"docs":{},"c":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}}},"b":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0034904013961605585}},"o":{"docs":{},"o":{"docs":{},"k":{"docs":{},"d":{"docs":{},"a":{"docs":{},"t":{"docs":{},"a":{"docs":{},".":{"docs":{},"a":{"docs":{},"u":{"docs":{},"t":{"docs":{},"h":{"docs":{},"o":{"docs":{},"r":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}},"y":{"docs":{},"e":{"docs":{},"a":{"docs":{},"r":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}}}},"u":{"docs":{},"n":{"docs":{},"d":{"docs":{},"s":{"docs":{},"u":{"docs":{},"m":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}},"d":{"docs":{},"o":{"docs":{},"a":{"docs":{},"n":{"docs":{},"o":{"docs":{},"t":{"docs":{},"h":{"docs":{},"e":{"docs":{},"r":{"docs":{},"t":{"docs":{},"h":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},".":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}}}}}}}}},"s":{"docs":{},"o":{"docs":{},"m":{"docs":{},"e":{"docs":{},"t":{"docs":{},"h":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},".":{"docs":{},"b":{"docs":{},"i":{"docs":{},"n":{"docs":{},"d":{"docs":{},"(":{"docs":{},")":{"docs":{},".":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}}},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}}}}}}}}}}}},"e":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{},".":{"docs":{},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}},"v":{"docs":{},"a":{"docs":{},"l":{"docs":{},"u":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}}}}}}}}}}},"f":{"docs":{},"i":{"docs":{},"r":{"docs":{},"s":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.004095563139931741}},"c":{"docs":{},"o":{"docs":{},"l":{"docs":{},"o":{"docs":{},"r":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.008726003490401396}}}}}}}}}}},"r":{"docs":{},"i":{"docs":{},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{},".":{"docs":{},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"g":{"docs":{},"r":{"docs":{},"e":{"docs":{},"e":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.01098901098901099}}}}}}}}}}}}}}}}},"+":{"0":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475}}},"docs":{}},"o":{"docs":{},"b":{"docs":{},"j":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{},".":{"docs":{},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"o":{"docs":{},"w":{"docs":{},"n":{"docs":{},"p":{"docs":{},"r":{"docs":{},"o":{"docs":{},"p":{"docs":{},"e":{"docs":{},"r":{"docs":{},"t":{"docs":{},"y":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{},"e":{"docs":{},"s":{"docs":{},"(":{"docs":{},"o":{"docs":{},"b":{"docs":{},"j":{"docs":{},")":{"docs":{},".":{"docs":{},"j":{"docs":{},"o":{"docs":{},"i":{"docs":{},"n":{"docs":{},"(":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"p":{"docs":{},"r":{"docs":{},"o":{"docs":{},"t":{"docs":{},"o":{"docs":{},"t":{"docs":{},"y":{"docs":{},"p":{"docs":{},"e":{"docs":{},"o":{"docs":{},"f":{"docs":{},"(":{"docs":{},"f":{"docs":{},"r":{"docs":{},"i":{"docs":{},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.005494505494505495}}}}}}}}}}}}}}}}}}}}}}},"i":{"docs":{},"s":{"docs":{},"(":{"5":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475}}},"docs":{},"+":{"0":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}},"docs":{}},"n":{"docs":{},"a":{"docs":{},"n":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}}}}}}}}},"l":{"docs":{},"o":{"docs":{},"c":{"docs":{},"a":{"docs":{},"l":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0034904013961605585}}}}},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{},".":{"docs":{},"c":{"docs":{},"o":{"docs":{},"l":{"docs":{},"u":{"docs":{},"m":{"docs":{},"n":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0017452006980802793}}}}}}}},"l":{"docs":{},"i":{"docs":{},"n":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0017452006980802793}}}}}}}}}}},"t":{"docs":{},"y":{"docs":{},"p":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0034904013961605585}}}}}}}}}}}}}}}}}}},"d":{"docs":{},"i":{"docs":{},"t":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.02102803738317757}}}}},"c":{"docs":{},"a":{"docs":{},"t":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.005235602094240838}}}}}},"d":{"docs":{},"e":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.002336448598130841},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}},"p":{"docs":{},"o":{"docs":{},"i":{"docs":{},"n":{"docs":{},"t":{"docs":{},"a":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.006944444444444444}}}},"l":{"docs":{},"e":{"docs":{},"n":{"docs":{},"g":{"docs":{},"t":{"docs":{},"h":{"docs":{},"(":{"docs":{},"t":{"docs":{},"e":{"docs":{},"x":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}}}}}}},"u":{"docs":{},"n":{"docs":{},"t":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.016355140186915886},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.00992063492063492}}}}},"m":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}},"r":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}},"o":{"docs":{},"s":{"docs":{},"i":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}}}}}},"s":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.005952380952380952}}}},"l":{"docs":{},"o":{"docs":{},"r":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.03664921465968586}},"s":{"docs":{},".":{"docs":{},"c":{"docs":{},"o":{"docs":{},"n":{"docs":{},"c":{"docs":{},"a":{"docs":{},"t":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0017452006980802793}}}}}}}}}}}},"u":{"docs":{},"m":{"docs":{},"n":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.010471204188481676}}}}}},"o":{"docs":{},"k":{"docs":{},"i":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.005235602094240838}}}}}},".":{"docs":{},"c":{"docs":{},"o":{"docs":{},"d":{"docs":{},"e":{"docs":{},"p":{"docs":{},"o":{"docs":{},"i":{"docs":{},"n":{"docs":{},"t":{"docs":{},"a":{"docs":{},"t":{"docs":{},"(":{"0":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}},"docs":{}}}}}}}}}}}}}},"a":{"docs":{},"n":{"docs":{},"o":{"docs":{},"n":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}},"&":{"docs":{},"#":{"3":{"9":{"docs":{},";":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}},"docs":{}},"docs":{}}}},"t":{"docs":{},"c":{"docs":{},"h":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}}},"l":{"docs":{},"l":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.005460750853242321}},"b":{"docs":{},"a":{"docs":{},"c":{"docs":{},"k":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.008191126279863481}}}}}},"(":{"docs":{},"t":{"docs":{},"h":{"docs":{},"i":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475}}}}}}}}},"h":{"docs":{},"a":{"docs":{},"r":{"docs":{},"a":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}},"c":{"docs":{},"o":{"docs":{},"d":{"docs":{},"e":{"docs":{},"a":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.002976190476190476}}}}}}}}}},"e":{"docs":{},"c":{"docs":{},"k":{"docs":{},"a":{"docs":{},"r":{"docs":{},"g":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}},"s":{"docs":{},"(":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},"a":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}}}}},".":{"docs":{},".":{"docs":{},".":{"docs":{},"a":{"docs":{},"r":{"docs":{},"g":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"a":{"docs":{},"t":{"docs":{},"e":{"docs":{},"a":{"docs":{},"r":{"docs":{},"r":{"docs":{},"o":{"docs":{},"w":{"docs":{},"f":{"docs":{},"u":{"docs":{},"n":{"docs":{},"c":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"f":{"docs":{},"i":{"docs":{},"r":{"docs":{},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"g":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0027303754266211604}},"(":{"5":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}},"docs":{}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"p":{"docs":{},"e":{"docs":{},"r":{"docs":{},"s":{"docs":{},"o":{"docs":{},"n":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475}},"(":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475}}}}}}}}}}}}}}}}},"l":{"docs":{},"o":{"docs":{},"n":{"docs":{},"e":{"docs":{},"d":{"docs":{},"c":{"docs":{},"o":{"docs":{},"l":{"docs":{},"o":{"docs":{},"r":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.005235602094240838}}}}}}}}}}}}},"d":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475}},"e":{"docs":{},"n":{"docs":{},"i":{"docs":{"./":{"ref":"./","tf":0.016666666666666666}}}},"c":{"docs":{},"o":{"docs":{},"m":{"docs":{},"p":{"docs":{},"o":{"docs":{},"s":{"docs":{},"i":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}}}}}}}},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}}},"t":{"docs":{},"r":{"docs":{},"u":{"docs":{},"c":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0017452006980802793}}}}}}}}}}},"o":{"docs":{},"v":{"docs":{},"h":{"docs":{},"a":{"docs":{},"n":{"docs":{"./":{"ref":"./","tf":0.016666666666666666}}}}}},"e":{"docs":{},"s":{"docs":{},"n":{"docs":{},"&":{"docs":{},"#":{"3":{"9":{"docs":{},";":{"docs":{},"t":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.004672897196261682}}}}},"docs":{}},"docs":{}}}}}},"a":{"docs":{},"n":{"docs":{},"o":{"docs":{},"t":{"docs":{},"h":{"docs":{},"e":{"docs":{},"r":{"docs":{},"t":{"docs":{},"h":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}}}}}}},"c":{"docs":{},"u":{"docs":{},"m":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}},".":{"docs":{},"a":{"docs":{},"d":{"docs":{},"d":{"docs":{},"e":{"docs":{},"v":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},"l":{"docs":{},"i":{"docs":{},"s":{"docs":{},"t":{"docs":{},"e":{"docs":{},"n":{"docs":{},"e":{"docs":{},"r":{"docs":{},"(":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},"c":{"docs":{},"l":{"docs":{},"i":{"docs":{},"c":{"docs":{},"k":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0020477815699658703}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"n":{"docs":{},"o":{"docs":{},"t":{"docs":{},"h":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}},"s":{"docs":{},"o":{"docs":{},"m":{"docs":{},"e":{"docs":{},"t":{"docs":{},"h":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.023208191126279865}},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}}},"(":{"docs":{},"b":{"docs":{},"o":{"docs":{},"d":{"docs":{},"i":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0020477815699658703}}}}}}},".":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}},"e":{"docs":{},"l":{"docs":{},"s":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0061433447098976105}}}}}}}}}}}}}},"g":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.013736263736263736}}},"m":{"docs":{},"a":{"docs":{},"i":{"docs":{},"n":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.012216404886561954}}}}}}},"s":{"docs":{},"l":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.005952380952380952}}}},"a":{"docs":{},"t":{"docs":{},"e":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}},"(":{"docs":{},"d":{"docs":{},"a":{"docs":{},"t":{"docs":{},"e":{"docs":{},".":{"docs":{},"n":{"docs":{},"o":{"docs":{},"w":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0017452006980802793}}}}}}}}}}}}}}},"e":{"docs":{},"c":{"docs":{},"m":{"docs":{},"a":{"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.030534351145038167}},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":3.4166666666666665},"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.22900763358778625},"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.02570093457943925},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.03869047619047619},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.039590443686006824},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.061813186813186816},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.02268760907504363}}}}}},"t":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.016666666666666666}}}}}}}}}}},"p":{"docs":{},"u":{"docs":{},"b":{"docs":{"./":{"ref":"./","tf":0.016666666666666666}}}}},"x":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}},"i":{"docs":{},"s":{"docs":{},"t":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.004672897196261682}}}}},"p":{"docs":{},"r":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.002336448598130841},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}},"i":{"docs":{},"r":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.015706806282722512}}}}},"e":{"docs":{},"c":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}},"t":{"docs":{},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}},"n":{"docs":{},"d":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.005235602094240838}},"s":{"docs":{},"w":{"docs":{},"i":{"docs":{},"t":{"docs":{},"h":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968}}}}}}}}},"r":{"docs":{},"r":{"docs":{},"o":{"docs":{},"r":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.005235602094240838}},"(":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},"y":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0027303754266211604}}}}}}}}}}}}}},"s":{"5":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}},"6":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}},"docs":{},"c":{"docs":{},"a":{"docs":{},"p":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}},"v":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.005494505494505495}},".":{"docs":{},"p":{"docs":{},"r":{"docs":{},"o":{"docs":{},"t":{"docs":{},"o":{"docs":{},"t":{"docs":{},"y":{"docs":{},"p":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.006868131868131868}}}}}}}}}}}}}}}}}}}}},"m":{"docs":{},"i":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.004120879120879121}}}}}},"i":{"docs":{},"s":{"3":{"2":{"docs":{},"b":{"docs":{},"i":{"docs":{},"t":{"docs":{},"(":{"docs":{},"c":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}},"docs":{}},"docs":{},"s":{"docs":{},"u":{"docs":{"./":{"ref":"./","tf":0.03333333333333333}}}},"n":{"docs":{},"a":{"docs":{},"n":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}},"=":{"0":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.014018691588785047}}},"docs":{}},"i":{"docs":{},"f":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.002336448598130841}}}},"m":{"docs":{},"m":{"docs":{},"e":{"docs":{},"d":{"docs":{},"i":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.002336448598130841}}}}}}},"n":{"docs":{},"v":{"docs":{},"o":{"docs":{},"k":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.002336448598130841}}}}},"c":{"docs":{},"l":{"docs":{},"u":{"docs":{},"d":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968}}}}}},"d":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}},".":{"docs":{},"r":{"docs":{},"e":{"docs":{},"p":{"docs":{},"e":{"docs":{},"a":{"docs":{},"t":{"docs":{},"(":{"docs":{},"+":{"docs":{},"+":{"docs":{},"i":{"docs":{},"n":{"docs":{},"d":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},"l":{"docs":{},"e":{"docs":{},"v":{"docs":{},"e":{"docs":{},"l":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}}}}}}}}}},"l":{"docs":{},"e":{"docs":{},"v":{"docs":{},"e":{"docs":{},"l":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.002976190476190476}}}}}}}}},"x":{"docs":{},"o":{"docs":{},"f":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.002976190476190476}}}}}}},"s":{"docs":{},"t":{"docs":{},"e":{"docs":{},"a":{"docs":{},"d":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}},"a":{"docs":{},"n":{"docs":{},"c":{"docs":{},"e":{"docs":{},"o":{"docs":{},"f":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.004095563139931741}}}}}}}}}},"i":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0034129692832764505}}}}},"&":{"docs":{},"g":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.002976190476190476},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0027303754266211604},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475}}}}},"t":{"docs":{},"e":{"docs":{},"m":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.005952380952380952}}}}},"d":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.005460750853242321}}}},"j":{"docs":{},"a":{"docs":{},"v":{"docs":{},"a":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.06666666666666667},"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.1297709923664122},"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.030373831775700934},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.02976190476190476},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.017064846416382253},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.034340659340659344},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.008726003490401396}},"&":{"docs":{},"#":{"3":{"9":{"docs":{},";":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}},"docs":{}},"docs":{}}}}}}}}}}}},"s":{"docs":{},"o":{"docs":{},"n":{"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0034904013961605585}},".":{"docs":{},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"i":{"docs":{},"f":{"docs":{},"i":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}}}}}}}}},"o":{"docs":{},"i":{"docs":{},"n":{"docs":{},"(":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},"\\":{"docs":{},"n":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}}}}}}},"l":{"docs":{},"e":{"docs":{},"a":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"b":{"docs":{"./":{"ref":"./","tf":0.016666666666666666}}}}}}},"n":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.004095563139931741}},"g":{"docs":{},"t":{"docs":{},"h":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}}},"t":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.014018691588785047},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.00496031746031746},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0034129692832764505}},";":{"docs":{},"/":{"docs":{},"d":{"docs":{},"i":{"docs":{},"v":{"docs":{},"&":{"docs":{},"g":{"docs":{},"t":{"docs":{},";":{"docs":{},"`":{"docs":{},".":{"docs":{},"t":{"docs":{},"r":{"docs":{},"i":{"docs":{},"m":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}}},"d":{"docs":{},"i":{"docs":{},"v":{"docs":{},"&":{"docs":{},"g":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}},"h":{"1":{"docs":{},"&":{"docs":{},"g":{"docs":{},"t":{"docs":{},";":{"docs":{},"t":{"docs":{},"i":{"docs":{},"t":{"docs":{},"l":{"docs":{},"e":{"docs":{},"&":{"docs":{},"l":{"docs":{},"t":{"docs":{},";":{"docs":{},"/":{"docs":{},"h":{"1":{"docs":{},"&":{"docs":{},"g":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}},"docs":{}}}}}}}}}}}}}}}}},"docs":{}}}},"е":{"docs":{},"t":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.002336448598130841}}}},"a":{"docs":{},"s":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}},"i":{"docs":{},"n":{"docs":{},"d":{"docs":{},"e":{"docs":{},"x":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.008928571428571428}},"o":{"docs":{},"f":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}}}}}}},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.005494505494505495}}}}}}}},"i":{"docs":{},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.006944444444444444}},"a":{"docs":{},"l":{"docs":{},"s":{"docs":{},".":{"docs":{},"l":{"docs":{},"e":{"docs":{},"n":{"docs":{},"g":{"docs":{},"t":{"docs":{},"h":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}}}}}},"r":{"docs":{},"a":{"docs":{},"w":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}},"[":{"0":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}},"docs":{},"i":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}},"l":{"docs":{},"i":{"docs":{},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{},"a":{"docs":{},"l":{"docs":{},"s":{"docs":{},".":{"docs":{},"l":{"docs":{},"e":{"docs":{},"n":{"docs":{},"g":{"docs":{},"t":{"docs":{},"h":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}}}}}}}}},"[":{"0":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}},"docs":{},"i":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}},"l":{"docs":{},"i":{"docs":{},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{},"a":{"docs":{},"l":{"docs":{},"s":{"docs":{},".":{"docs":{},"l":{"docs":{},"e":{"docs":{},"n":{"docs":{},"g":{"docs":{},"t":{"docs":{},"h":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}}}}}}}}}}}}}}}}}}}}}},"n":{"docs":{},"e":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.010471204188481676}}}}},"o":{"docs":{},"c":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.017452006980802792}},"a":{"docs":{},"l":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.006980802792321117}}}}},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0034904013961605585}}}}}}},"t":{"docs":{},"y":{"docs":{},"p":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.008726003490401396}}}}}}}}}},"m":{"docs":{},"a":{"docs":{},"p":{"docs":{"./":{"ref":"./","tf":0.016666666666666666},"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.015267175572519083},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}},"x":{"docs":{},"i":{"docs":{},"t":{"docs":{},"e":{"docs":{},"m":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.02102803738317757}}}}}}},"t":{"docs":{},"c":{"docs":{},"h":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}},"h":{"docs":{},".":{"docs":{},"m":{"docs":{},"a":{"docs":{},"x":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.00477815699658703}},".":{"docs":{},"a":{"docs":{},"p":{"docs":{},"p":{"docs":{},"l":{"docs":{},"i":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}}}}},"k":{"docs":{},"e":{"docs":{},"r":{"docs":{},"e":{"docs":{},"q":{"docs":{},"u":{"docs":{},"e":{"docs":{},"s":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0020477815699658703}},"(":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},"/":{"docs":{},"f":{"docs":{},"o":{"docs":{},"o":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.004095563139931741}}}}}}}}}}}}}}}}},"u":{"docs":{},"r":{"docs":{},"l":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0027303754266211604}}}}}}}}}}}}}}}},"o":{"docs":{},"b":{"docs":{},"i":{"docs":{"./":{"ref":"./","tf":0.016666666666666666}}}},"r":{"docs":{},"e":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.002336448598130841}}}},"d":{"docs":{},"e":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}},"i":{"docs":{},"c":{"docs":{},"r":{"docs":{},"o":{"docs":{},"s":{"docs":{},"o":{"docs":{},"f":{"docs":{},"t":{"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542}}}}}}}}},"x":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}},"a":{"docs":{},"r":{"docs":{},"g":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0020477815699658703}},"s":{"docs":{},"(":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},"a":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0020477815699658703}}}}}}}}}}}}}},"f":{"docs":{},"i":{"docs":{},"r":{"docs":{},"s":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0020477815699658703}}}}}}}}}}}},"i":{"docs":{},"n":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.009615384615384616}},"(":{"docs":{},"m":{"docs":{},"y":{"docs":{},"o":{"docs":{},"b":{"docs":{},"j":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"c":{"docs":{},"e":{"docs":{},"i":{"docs":{},"v":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}}}}}}},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},"a":{"docs":{},"g":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.004672897196261682},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.022817460317460316}},"e":{"1":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}},"2":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}},"docs":{}}}}}}},"s":{"docs":{},"g":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}},".":{"docs":{},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{},"s":{"docs":{},"w":{"docs":{},"i":{"docs":{},"t":{"docs":{},"h":{"docs":{},"(":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},"o":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}}}}}}}}}},"i":{"docs":{},"n":{"docs":{},"c":{"docs":{},"l":{"docs":{},"u":{"docs":{},"d":{"docs":{},"e":{"docs":{},"s":{"docs":{},"(":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},"o":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{},"s":{"docs":{},"w":{"docs":{},"i":{"docs":{},"t":{"docs":{},"h":{"docs":{},"(":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},"o":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}}}}}}}}}}}}}}},"u":{"docs":{},"l":{"docs":{},"t":{"docs":{},"i":{"docs":{},"l":{"docs":{},"i":{"docs":{},"n":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.002976190476190476}},"e":{"docs":{},"\\":{"docs":{},"n":{"docs":{},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}}}}}}}}}}}}},"y":{"docs":{},"t":{"docs":{},"y":{"docs":{},"p":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0027303754266211604}}}}},"o":{"docs":{},"b":{"docs":{},"j":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.005494505494505495}},".":{"docs":{},"e":{"docs":{},"m":{"docs":{},"i":{"docs":{},"t":{"docs":{},"(":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},"s":{"docs":{},"o":{"docs":{},"m":{"docs":{},"e":{"docs":{},"t":{"docs":{},"h":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"c":{"docs":{},"h":{"docs":{},"a":{"docs":{},"n":{"docs":{},"g":{"docs":{},"e":{"docs":{},"d":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"n":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.005952380952380952},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.004095563139931741}},"c":{"docs":{"./":{"ref":"./","tf":0.016666666666666666}},"z":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.007009345794392523}}}},"d":{"docs":{"./":{"ref":"./","tf":0.016666666666666666}}},"i":{"docs":{},"c":{"docs":{},"h":{"docs":{},"o":{"docs":{},"l":{"docs":{},"a":{"docs":{"./":{"ref":"./","tf":0.016666666666666666}},"s":{"docs":{},".":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}},"o":{"docs":{},"d":{"docs":{},"e":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.05235602094240838}},".":{"docs":{},"j":{"docs":{"./":{"ref":"./","tf":0.016666666666666666},"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.03816793893129771},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}},"l":{"docs":{},"o":{"docs":{},"c":{"docs":{},".":{"docs":{},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.005235602094240838}}}}}}}}}}},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.005235602094240838}}}}},"r":{"docs":{},"a":{"docs":{},"n":{"docs":{},"g":{"docs":{},"e":{"docs":{},"[":{"0":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0017452006980802793}}},"docs":{}}}}}}},"t":{"docs":{},"y":{"docs":{},"p":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.005235602094240838}}}}},"v":{"docs":{},"a":{"docs":{},"l":{"docs":{},"u":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0017452006980802793}}}}}}}}},"n":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.002336448598130841}},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{},"i":{"docs":{},"c":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}},"r":{"docs":{},"m":{"docs":{},"a":{"docs":{},"l":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.00992063492063492}},"i":{"docs":{},"z":{"docs":{},"e":{"docs":{},"d":{"docs":{},".":{"docs":{},"s":{"docs":{},"o":{"docs":{},"r":{"docs":{},"t":{"docs":{},"(":{"docs":{},"f":{"docs":{},"u":{"docs":{},"n":{"docs":{},"c":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"(":{"docs":{},"f":{"docs":{},"i":{"docs":{},"r":{"docs":{},"s":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"t":{"docs":{},"a":{"docs":{},"p":{"docs":{},"e":{"docs":{},"r":{"docs":{},"s":{"docs":{},"o":{"docs":{},"n":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0034129692832764505}}}}}}}}}}},"a":{"docs":{},"m":{"docs":{},"e":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.009345794392523364},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.00496031746031746},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.021160409556313993},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.03159340659340659},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.04537521815008726}},"(":{"docs":{},".":{"docs":{},".":{"docs":{},".":{"docs":{},"v":{"docs":{},"a":{"docs":{},"l":{"docs":{},"u":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.023351648351648352}}}}}}}}},"n":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.01098901098901099}}}},"u":{"docs":{},"l":{"docs":{},"l":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.007009345794392523},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.008726003490401396}}}},"m":{"1":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.005460750853242321}}},"2":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.006825938566552901}}},"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0027303754266211604}}}},"z":{"docs":{},"t":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.002336448598130841}}}},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}},"e":{"docs":{},"w":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.00496031746031746},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.030716723549488054},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0017452006980802793}},"i":{"docs":{},"n":{"docs":{},"d":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}},".":{"docs":{},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.011604095563139932}}}}}}}}}}},"f":{"docs":{},"c":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}},"o":{"docs":{"./":{"ref":"./","tf":3.383333333333333}},"з":{"docs":{},"в":{"docs":{},"o":{"docs":{"./":{"ref":"./","tf":0.016666666666666666}}}}},"b":{"docs":{},"j":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.004120879120879121}},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.009345794392523364},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0027303754266211604},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475}},".":{"docs":{},"c":{"docs":{},"r":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}},"e":{"docs":{},"a":{"docs":{},"t":{"docs":{},"e":{"docs":{},"(":{"docs":{},"n":{"docs":{},"u":{"docs":{},"l":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0020477815699658703}}}}},"f":{"docs":{},"r":{"docs":{},"i":{"docs":{},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475}}}}}}}},"p":{"docs":{},"e":{"docs":{},"r":{"docs":{},"s":{"docs":{},"o":{"docs":{},"n":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}}}}}}}}},"a":{"docs":{},"s":{"docs":{},"s":{"docs":{},"i":{"docs":{},"g":{"docs":{},"n":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.019230769230769232}},"(":{"docs":{},"m":{"docs":{},"y":{"docs":{},"o":{"docs":{},"b":{"docs":{},"j":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"c":{"docs":{},"e":{"docs":{},"i":{"docs":{},"v":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475}}}}}}}}}}}}}}},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"o":{"docs":{},"w":{"docs":{},"n":{"docs":{},"p":{"docs":{},"r":{"docs":{},"o":{"docs":{},"p":{"docs":{},"e":{"docs":{},"r":{"docs":{},"t":{"docs":{},"y":{"docs":{},"d":{"docs":{},"e":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{},"(":{"docs":{},"r":{"docs":{},"e":{"docs":{},"c":{"docs":{},"e":{"docs":{},"i":{"docs":{},"v":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}}}}}}}}}}}}},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475}}}}}}}}}}}}}}}},"p":{"docs":{},"r":{"docs":{},"o":{"docs":{},"t":{"docs":{},"o":{"docs":{},"t":{"docs":{},"y":{"docs":{},"p":{"docs":{},"e":{"docs":{},"o":{"docs":{},"f":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.009615384615384616}},"(":{"docs":{},"t":{"docs":{},"h":{"docs":{},"i":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}},"s":{"docs":{},")":{"docs":{},".":{"docs":{},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"g":{"docs":{},"r":{"docs":{},"e":{"docs":{},"e":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},".":{"docs":{},"c":{"docs":{},"a":{"docs":{},"l":{"docs":{},"l":{"docs":{},"(":{"docs":{},"t":{"docs":{},"h":{"docs":{},"i":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.005494505494505495}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"i":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.006868131868131868}}},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}},"s":{"docs":{},"(":{"docs":{},"s":{"docs":{},"u":{"docs":{},"p":{"docs":{},"p":{"docs":{},"l":{"docs":{},"i":{"docs":{},"e":{"docs":{},"r":{"docs":{},")":{"docs":{},".":{"docs":{},"f":{"docs":{},"o":{"docs":{},"r":{"docs":{},"e":{"docs":{},"a":{"docs":{},"c":{"docs":{},"h":{"docs":{},"(":{"docs":{},"f":{"docs":{},"u":{"docs":{},"n":{"docs":{},"c":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"(":{"docs":{},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"m":{"docs":{},"i":{"docs":{},"x":{"docs":{},"i":{"docs":{},"n":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475}}}}}}},"p":{"docs":{},"r":{"docs":{},"o":{"docs":{},"t":{"docs":{},"o":{"docs":{},"t":{"docs":{},"y":{"docs":{},"p":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}}}},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"p":{"docs":{},"r":{"docs":{},"o":{"docs":{},"t":{"docs":{},"o":{"docs":{},"t":{"docs":{},"y":{"docs":{},"p":{"docs":{},"e":{"docs":{},"o":{"docs":{},"f":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.005494505494505495}},"(":{"docs":{},"f":{"docs":{},"r":{"docs":{},"i":{"docs":{},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.009615384615384616}}}}}}}}}}}}}}}}}}}}}}}},"[":{"docs":{},"a":{"docs":{},"r":{"docs":{},"g":{"docs":{},"u":{"docs":{},"m":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},"s":{"docs":{},"[":{"docs":{},"i":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}}}},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{},"s":{"docs":{},"[":{"docs":{},"i":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}}}}},"]":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}},".":{"docs":{},"d":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}},"p":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.019197207678883072}},"s":{"docs":{},".":{"docs":{},"d":{"docs":{},"o":{"docs":{},"m":{"docs":{},"a":{"docs":{},"i":{"docs":{},"n":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0017452006980802793}}}}}}}},"e":{"docs":{},"x":{"docs":{},"p":{"docs":{},"i":{"docs":{},"r":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0017452006980802793}}}}}}},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0017452006980802793}}}}}},"r":{"docs":{},"e":{"docs":{},"p":{"docs":{},"e":{"docs":{},"a":{"docs":{},"t":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0017452006980802793}}}}}}}},"s":{"docs":{},"a":{"docs":{},"v":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0017452006980802793}}}},"e":{"docs":{},"c":{"docs":{},"u":{"docs":{},"r":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0017452006980802793}}}}}}}}}}}}}},"u":{"docs":{},"t":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"f":{"docs":{},"o":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.005235602094240838}},"(":{"docs":{},"v":{"docs":{},"a":{"docs":{},"l":{"docs":{},"u":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0017452006980802793}}}}}}}}}}}}}}}}},"p":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0034129692832764505}},"d":{"docs":{},"f":{"docs":{"./":{"ref":"./","tf":0.016666666666666666}}}},"e":{"docs":{},"r":{"docs":{},"m":{"docs":{},"i":{"docs":{},"s":{"docs":{},"s":{"docs":{"./":{"ref":"./","tf":0.016666666666666666}}}}}},"s":{"docs":{},"o":{"docs":{},"n":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.011682242990654205},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.015017064846416382},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.04532967032967033}},".":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.004672897196261682},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0027303754266211604}}}}}}},"c":{"docs":{},"a":{"docs":{},"l":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}},"l":{"docs":{},"(":{"docs":{},"p":{"docs":{},"e":{"docs":{},"r":{"docs":{},"s":{"docs":{},"o":{"docs":{},"n":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}}}},"t":{"docs":{},"h":{"docs":{},"i":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}}}}}},"f":{"docs":{},"i":{"docs":{},"r":{"docs":{},"s":{"docs":{},"t":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}},"s":{"docs":{},"a":{"docs":{},"y":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"g":{"docs":{},"r":{"docs":{},"e":{"docs":{},"e":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475}}}}}}}}}}},"(":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},"n":{"docs":{},"i":{"docs":{},"c":{"docs":{},"h":{"docs":{},"o":{"docs":{},"l":{"docs":{},"a":{"docs":{},"s":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.00477815699658703}}}}}}}}}}}}}}}}}}}}},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0034129692832764505}}}}}},"[":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},"f":{"docs":{},"i":{"docs":{},"r":{"docs":{},"s":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}}}}}}},"l":{"docs":{},"a":{"docs":{},"s":{"docs":{},"t":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{"./":{"ref":"./","tf":0.05}}}}},"o":{"docs":{},"c":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},"(":{"docs":{},"i":{"docs":{},"t":{"docs":{},"e":{"docs":{},"m":{"docs":{},"s":{"docs":{},"[":{"docs":{},"i":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.004672897196261682}}}}}}}}}}}}}},"t":{"docs":{},"o":{"docs":{},"t":{"docs":{},"y":{"docs":{},"p":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.006868131868131868}}}}}}}},"i":{"docs":{},"c":{"docs":{},"e":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968}},")":{"docs":{},".":{"docs":{},"t":{"docs":{},"o":{"docs":{},"f":{"docs":{},"i":{"docs":{},"x":{"docs":{},"e":{"docs":{},"d":{"docs":{},"(":{"2":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968}}},"docs":{}}}}}}}}}}}}}}},"u":{"docs":{},"l":{"docs":{},"l":{"docs":{"./":{"ref":"./","tf":0.03333333333333333},"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542}}}}},"a":{"docs":{},"s":{"docs":{},"s":{"docs":{},"t":{"docs":{},"h":{"docs":{},"r":{"docs":{},"u":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}},"(":{"docs":{},"l":{"docs":{},"i":{"docs":{},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}},"`":{"docs":{},"$":{"docs":{},"{":{"docs":{},"c":{"docs":{},"o":{"docs":{},"u":{"docs":{},"n":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}}}}}}}}}}}}}},"t":{"docs":{},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{},"n":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.005952380952380952}},".":{"docs":{},"e":{"docs":{},"x":{"docs":{},"e":{"docs":{},"c":{"docs":{},"(":{"docs":{},"t":{"docs":{},"e":{"docs":{},"x":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968}}}}}}}}}}},"l":{"docs":{},"a":{"docs":{},"s":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"d":{"docs":{},"e":{"docs":{},"x":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}}},"h":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.012216404886561954}}}},"g":{"docs":{},"e":{"docs":{},"h":{"docs":{},"a":{"docs":{},"n":{"docs":{},"d":{"docs":{},"l":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.00477815699658703}}}}}}}}},"r":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}},"e":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}}}},"o":{"docs":{},"i":{"docs":{},"n":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}},"i":{"docs":{},"c":{"docs":{},"k":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0027303754266211604}},"(":{"docs":{},"b":{"docs":{},"o":{"docs":{},"o":{"docs":{},"k":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}},"o":{"docs":{},"b":{"docs":{},"j":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0020477815699658703}}}}}}}}},"f":{"docs":{},"i":{"docs":{},"r":{"docs":{},"s":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}},"r":{"docs":{},"e":{"1":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.006944444444444444}}},"2":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.005952380952380952}}},"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.002976190476190476}},"q":{"docs":{},"u":{"docs":{},"e":{"docs":{},"s":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.03333333333333333},"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542}}}}}}},"g":{"docs":{},"e":{"docs":{},"x":{"docs":{},"p":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.018691588785046728},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.005952380952380952}},"(":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},".":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}}}}}}}}}}}},"r":{"docs":{},"e":{"1":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.002976190476190476}}},"docs":{}}}}}}},"u":{"docs":{},"l":{"docs":{},"a":{"docs":{},"r":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.016355140186915886},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.018849206349206348},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.025938566552901023},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.03021978021978022}}}}}},".":{"docs":{},"t":{"docs":{},"o":{"docs":{},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}},"p":{"docs":{},"e":{"docs":{},"a":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.005235602094240838}}}}}},"s":{"docs":{},"u":{"docs":{},"l":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.015873015873015872},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.008191126279863481}},".":{"docs":{},"l":{"docs":{},"e":{"docs":{},"n":{"docs":{},"g":{"docs":{},"t":{"docs":{},"h":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}},"[":{"docs":{},"a":{"docs":{},"r":{"docs":{},"g":{"docs":{},"u":{"docs":{},"m":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},"s":{"docs":{},"[":{"docs":{},"i":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}}}},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{},"s":{"docs":{},"[":{"docs":{},"i":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}}}}}}}},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.004095563139931741},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.005235602094240838}},"c":{"docs":{},"o":{"docs":{},"l":{"docs":{},"o":{"docs":{},"r":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.005235602094240838}}}}}}}}},"d":{"docs":{},"u":{"docs":{},"c":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}},"f":{"docs":{},"l":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0020477815699658703}},".":{"docs":{},"o":{"docs":{},"w":{"docs":{},"n":{"docs":{},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}}}}}}}},"c":{"docs":{},"e":{"docs":{},"i":{"docs":{},"v":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.006868131868131868}},"e":{"docs":{},"r":{"docs":{},".":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}},"t":{"docs":{},"y":{"docs":{},"p":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}},"[":{"docs":{},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}}}}}},"l":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.006868131868131868}},"a":{"docs":{},"t":{"docs":{},"i":{"docs":{},"v":{"docs":{},"e":{"docs":{},".":{"docs":{},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"g":{"docs":{},"r":{"docs":{},"e":{"docs":{},"e":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}}}}}}}}}}}},"a":{"docs":{},"w":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.002976190476190476}},"(":{"docs":{},"l":{"docs":{},"i":{"docs":{},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}},"`":{"docs":{},"m":{"docs":{},"u":{"docs":{},"l":{"docs":{},"t":{"docs":{},"i":{"docs":{},"l":{"docs":{},"i":{"docs":{},"n":{"docs":{},"e":{"docs":{},"\\":{"docs":{},"n":{"docs":{},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}}}}},"n":{"docs":{},"g":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.005235602094240838}}}}},"r":{"docs":{},"o":{"docs":{},"w":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0020477815699658703}}}}}},"s":{"docs":{},"a":{"docs":{},"h":{"docs":{},"a":{"docs":{},"i":{"docs":{},"d":{"docs":{},"a":{"docs":{},"k":{"docs":{"./":{"ref":"./","tf":0.016666666666666666}}}}}}}},"y":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.005494505494505495}}}}}},"v":{"docs":{},"e":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.005235602094240838}}}}},"e":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.016666666666666666},"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.015267175572519083},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}},"c":{"docs":{},"o":{"docs":{},"o":{"docs":{},"k":{"docs":{},"i":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.012216404886561954}},"e":{"docs":{},"(":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},"t":{"docs":{},"y":{"docs":{},"p":{"docs":{},"e":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.005235602094240838}}}}}}}}}}}}}}}}},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.008726003490401396}}}}}}}}}}}}},"c":{"docs":{},"o":{"docs":{},"n":{"docs":{},"d":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.005952380952380952},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.028668941979522185}},".":{"docs":{},"n":{"docs":{},"o":{"docs":{},"r":{"docs":{},"m":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}},"a":{"docs":{},"l":{"docs":{},"i":{"docs":{},"z":{"docs":{},"e":{"docs":{},"(":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},"n":{"docs":{},"f":{"docs":{},"d":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}}}}}}}}}}}}}},"n":{"docs":{},"o":{"docs":{},"r":{"docs":{},"m":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.005952380952380952}}}}}},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}}},"c":{"docs":{},"o":{"docs":{},"l":{"docs":{},"o":{"docs":{},"r":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.019197207678883072}}}}}}}}}},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}},"u":{"docs":{},"r":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.015706806282722512}}}}}},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"c":{"docs":{},"h":{"docs":{"./":{"ref":"./","tf":0.05}}}},"t":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.013961605584642234}},"s":{"docs":{},"w":{"docs":{},"i":{"docs":{},"t":{"docs":{},"h":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968}}}}}}},"i":{"docs":{},"n":{"docs":{},"d":{"docs":{},"e":{"docs":{},"x":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0034904013961605585}}}}}}}}}},"r":{"docs":{},"i":{"docs":{},"c":{"docs":{},"t":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.004672897196261682},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0061433447098976105},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475}}}}}}}}},"n":{"docs":{},"g":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.002976190476190476}},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.007936507936507936}}}}}}},".":{"docs":{},"f":{"docs":{},"r":{"docs":{},"o":{"docs":{},"m":{"docs":{},"c":{"docs":{},"h":{"docs":{},"a":{"docs":{},"r":{"docs":{},"c":{"docs":{},"o":{"docs":{},"d":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}},"o":{"docs":{},"d":{"docs":{},"e":{"docs":{},"p":{"docs":{},"o":{"docs":{},"i":{"docs":{},"n":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968}}}}}}}}}}}}}}},"r":{"docs":{},"a":{"docs":{},"w":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}},"`":{"docs":{},"m":{"docs":{},"u":{"docs":{},"l":{"docs":{},"t":{"docs":{},"i":{"docs":{},"l":{"docs":{},"i":{"docs":{},"n":{"docs":{},"e":{"docs":{},"\\":{"docs":{},"n":{"docs":{},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}}}}}}}}}}},"a":{"docs":{},"w":{"docs":{},"m":{"docs":{},"a":{"docs":{},"n":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}},"i":{"docs":{},"c":{"docs":{},"k":{"docs":{},"i":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.00496031746031746}}},"y":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{},"n":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968}},".":{"docs":{},"e":{"docs":{},"x":{"docs":{},"e":{"docs":{},"c":{"docs":{},"(":{"docs":{},"t":{"docs":{},"e":{"docs":{},"x":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968}}}}}}}}}}},"l":{"docs":{},"a":{"docs":{},"s":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"d":{"docs":{},"e":{"docs":{},"x":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"s":{"docs":{},"u":{"docs":{},"l":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.005952380952380952}}}}}}}}}}}}},"o":{"docs":{},"u":{"docs":{},"r":{"docs":{},"c":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.002976190476190476}}}}},"r":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}},"q":{"docs":{},"l":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}},"u":{"docs":{},"b":{"docs":{},"s":{"docs":{},"t":{"docs":{},"i":{"docs":{},"t":{"docs":{},"u":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.011904761904761904}},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"s":{"docs":{},".":{"docs":{},"l":{"docs":{},"e":{"docs":{},"n":{"docs":{},"g":{"docs":{},"t":{"docs":{},"h":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968}}}}}}}}},"[":{"docs":{},"i":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}}}}}}}}}}}}},"m":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.005460750853242321}},".":{"docs":{},"b":{"docs":{},"i":{"docs":{},"n":{"docs":{},"d":{"docs":{},"(":{"docs":{},"n":{"docs":{},"u":{"docs":{},"l":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}}},"p":{"docs":{},"e":{"docs":{},"r":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0020477815699658703},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.024725274725274724}},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}},".":{"docs":{},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"g":{"docs":{},"r":{"docs":{},"e":{"docs":{},"e":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.013736263736263736}}}}}}}}}}}}},"p":{"docs":{},"l":{"docs":{},"i":{"docs":{},"e":{"docs":{},"r":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.006868131868131868}},".":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}},"[":{"docs":{},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}}}}}},"f":{"docs":{},"f":{"docs":{},"i":{"docs":{},"x":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.004120879120879121}}}}}}},"p":{"docs":{},"r":{"docs":{},"e":{"docs":{},"a":{"docs":{},"d":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0020477815699658703}}}}}}},"y":{"docs":{},"n":{"docs":{},"t":{"docs":{},"a":{"docs":{},"x":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.005235602094240838}}}}}}},"h":{"docs":{},"a":{"docs":{},"r":{"docs":{},"e":{"docs":{},"g":{"docs":{},"r":{"docs":{},"e":{"docs":{},"e":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475}}}}}}}}}}}},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{},"r":{"docs":{},"i":{"docs":{"./":{"ref":"./","tf":0.016666666666666666}}}}},"m":{"docs":{},"p":{"docs":{},"l":{"docs":{},"a":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}},"s":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}},"x":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.008928571428571428}},".":{"docs":{},"l":{"docs":{},"e":{"docs":{},"n":{"docs":{},"g":{"docs":{},"t":{"docs":{},"h":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}},"m":{"docs":{},"a":{"docs":{},"t":{"docs":{},"c":{"docs":{},"h":{"docs":{},"(":{"docs":{},"/":{"docs":{},"[":{"docs":{},"\\":{"docs":{},"s":{"docs":{},"\\":{"docs":{},"s":{"docs":{},"]":{"docs":{},"/":{"docs":{},"g":{"docs":{},"u":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}}}}},"n":{"docs":{},"o":{"docs":{},"r":{"docs":{},"m":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}},"s":{"docs":{},"u":{"docs":{},"b":{"docs":{},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"(":{"docs":{},"t":{"docs":{},"e":{"docs":{},"x":{"docs":{},"t":{"docs":{},".":{"docs":{},"l":{"docs":{},"a":{"docs":{},"s":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"d":{"docs":{},"e":{"docs":{},"x":{"docs":{},"o":{"docs":{},"f":{"docs":{},"(":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},"/":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"a":{"docs":{},"n":{"docs":{},"s":{"docs":{},"l":{"docs":{},"a":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.016666666666666666}}}}}}}},"u":{"docs":{},"e":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.016355140186915886},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.017857142857142856},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.008873720136518772},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.016483516483516484},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.012216404886561954}}}},"i":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}},"m":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}}},"c":{"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.022900763358778626}}},"y":{"docs":{},"p":{"docs":{},"e":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0020477815699658703},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0506108202443281}},"o":{"docs":{},"f":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.014018691588785047},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.005460750853242321}}}}}}},"a":{"docs":{},"g":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}},"(":{"docs":{},"l":{"docs":{},"i":{"docs":{},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}},"`":{"docs":{},"h":{"docs":{},"e":{"docs":{},"l":{"docs":{},"l":{"docs":{},"o":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}},"i":{"docs":{},"l":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}},"o":{"docs":{},"f":{"docs":{},"i":{"docs":{},"x":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.002976190476190476}}}}}},"h":{"docs":{},"i":{"docs":{},"s":{"docs":{},".":{"docs":{},"d":{"docs":{},"o":{"docs":{},"s":{"docs":{},"o":{"docs":{},"m":{"docs":{},"e":{"docs":{},"t":{"docs":{},"h":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0027303754266211604}},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"(":{"docs":{},"e":{"docs":{},"v":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},".":{"docs":{},"t":{"docs":{},"y":{"docs":{},"p":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0020477815699658703}}}}}}}}}}}}}}}}}}}}}}},"i":{"docs":{},"d":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0020477815699658703}}}},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0034129692832764505}}}}}}},"r":{"docs":{},"d":{"docs":{},"c":{"docs":{},"o":{"docs":{},"l":{"docs":{},"o":{"docs":{},"r":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0034904013961605585}}}}}}}}}},"r":{"docs":{},"o":{"docs":{},"w":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0027303754266211604}}}}}},"i":{"docs":{},"m":{"docs":{},"e":{"docs":{},"o":{"docs":{},"u":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.011604095563139932}}}}}}},"t":{"docs":{},"l":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}},"m":{"docs":{},"p":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.006980802792321117}}}}},"z":{"docs":{},"a":{"docs":{},"k":{"docs":{},"a":{"docs":{"./":{"ref":"./","tf":0.016666666666666666}},"s":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}}}}}}}},"g":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.00496031746031746}},"o":{"docs":{},"o":{"docs":{},"g":{"docs":{},"l":{"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542}}}}}},"e":{"docs":{},"t":{"docs":{},"v":{"docs":{},"a":{"docs":{},"l":{"docs":{},"u":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.004672897196261682},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0061433447098976105}},"e":{"docs":{},"(":{"docs":{},"c":{"docs":{},"o":{"docs":{},"n":{"docs":{},"d":{"docs":{},"i":{"docs":{},"t":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.007009345794392523}}}}}}}},"f":{"docs":{},"i":{"docs":{},"r":{"docs":{},"s":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0027303754266211604}}}}}}},"v":{"docs":{},"a":{"docs":{},"l":{"docs":{},"u":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}}}}}}}},"f":{"docs":{},"l":{"docs":{},"a":{"docs":{},"g":{"docs":{},"s":{"docs":{},"(":{"docs":{},"r":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0034129692832764505}}}}},"t":{"docs":{},"e":{"docs":{},"m":{"docs":{},"p":{"docs":{},"i":{"docs":{},"t":{"docs":{},"e":{"docs":{},"m":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}}}}}},"g":{"docs":{},"l":{"docs":{},"o":{"docs":{},"b":{"docs":{},"a":{"docs":{},"l":{"docs":{},"g":{"docs":{},"r":{"docs":{},"e":{"docs":{},"e":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.012362637362637362}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"e":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.03159340659340659}}}}}}}}},"t":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.004672897196261682},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.010238907849829351},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0017452006980802793}}},"l":{"docs":{},"o":{"docs":{},"b":{"docs":{},"a":{"docs":{},"l":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{},"n":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968}},".":{"docs":{},"e":{"docs":{},"x":{"docs":{},"e":{"docs":{},"c":{"docs":{},"(":{"docs":{},"t":{"docs":{},"e":{"docs":{},"x":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968}}}}}}}}}}},"l":{"docs":{},"a":{"docs":{},"s":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"d":{"docs":{},"e":{"docs":{},"x":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"s":{"docs":{},"u":{"docs":{},"l":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968}}}}}}}}}}}}}},"h":{"docs":{},"a":{"docs":{},"r":{"docs":{},"m":{"docs":{},"o":{"docs":{},"n":{"docs":{},"i":{"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.015267175572519083}}}}}}},"s":{"docs":{},"r":{"docs":{},"e":{"docs":{},"g":{"docs":{},"e":{"docs":{},"x":{"docs":{},"p":{"docs":{},"i":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}},"u":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}},"t":{"docs":{},"t":{"docs":{},"p":{"docs":{},":":{"docs":{},"/":{"docs":{},"/":{"docs":{},"g":{"docs":{},"r":{"docs":{},"o":{"docs":{},"u":{"docs":{},"p":{"docs":{},"s":{"docs":{},".":{"docs":{},"g":{"docs":{},"o":{"docs":{},"o":{"docs":{},"g":{"docs":{},"l":{"docs":{},"e":{"docs":{},".":{"docs":{},"c":{"docs":{},"o":{"docs":{},"m":{"docs":{},"/":{"docs":{},"g":{"docs":{},"r":{"docs":{},"o":{"docs":{},"u":{"docs":{},"p":{"docs":{},"/":{"docs":{},"z":{"docs":{},"a":{"docs":{},"k":{"docs":{},"a":{"docs":{},"s":{"docs":{},"b":{"docs":{},"o":{"docs":{},"o":{"docs":{},"k":{"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},":":{"docs":{},"/":{"docs":{},"/":{"docs":{},"g":{"docs":{},"i":{"docs":{},"t":{"docs":{},"h":{"docs":{},"u":{"docs":{},"b":{"docs":{},".":{"docs":{},"c":{"docs":{},"o":{"docs":{},"m":{"docs":{},"/":{"docs":{},"d":{"docs":{},"e":{"docs":{},"n":{"docs":{},"y":{"docs":{},"s":{"docs":{},"d":{"docs":{},"o":{"docs":{},"v":{"docs":{},"h":{"docs":{},"a":{"docs":{},"n":{"docs":{},"/":{"docs":{},"u":{"docs":{},"n":{"docs":{},"d":{"docs":{},"e":{"docs":{},"r":{"docs":{},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"n":{"docs":{},"d":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"e":{"docs":{},"s":{"6":{"docs":{},"u":{"docs":{},"a":{"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542}}}}},"docs":{}}}}}}}}}}}}}}}}}}}}}}}}}}}},"n":{"docs":{},"z":{"docs":{},"a":{"docs":{},"k":{"docs":{},"a":{"docs":{},"s":{"docs":{},"/":{"docs":{},"u":{"docs":{},"n":{"docs":{},"d":{"docs":{},"e":{"docs":{},"r":{"docs":{},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"n":{"docs":{},"d":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"e":{"docs":{},"s":{"6":{"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542}}},"docs":{}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"m":{"docs":{},"l":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968}}}}},"e":{"docs":{},"r":{"docs":{},"e":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.004672897196261682}}}},"l":{"docs":{},"l":{"docs":{},"o":{"2":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}},"3":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}}}}}},"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968}},"\\":{"docs":{},"d":{"docs":{},"/":{"docs":{},"i":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}},"\\":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}},"s":{"docs":{},"?":{"docs":{},"/":{"docs":{},"g":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}},"i":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}}}}}}}}}}},"i":{"docs":{},"!":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.019230769230769232}}}}}}}}},"o":{"docs":{},"m":{"docs":{},"e":{"docs":{},"o":{"docs":{},"b":{"docs":{},"j":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.013736263736263736}}}}}}}}}}}},"v":{"docs":{},"a":{"docs":{},"r":{"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542},"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.09579439252336448},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.023809523809523808},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.027986348122866895},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.02197802197802198},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.012216404886561954}}},"l":{"docs":{},"u":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.06542056074766354},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.008873720136518772},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.020942408376963352}},"e":{"1":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}},"2":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}},"docs":{},"s":{"docs":{},".":{"docs":{},"m":{"docs":{},"a":{"docs":{},"p":{"docs":{},"(":{"docs":{},"f":{"docs":{},"u":{"docs":{},"n":{"docs":{},"c":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"(":{"docs":{},"t":{"docs":{},"e":{"docs":{},"x":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"o":{"docs":{},"r":{"docs":{},"t":{"docs":{},"(":{"docs":{},"f":{"docs":{},"u":{"docs":{},"n":{"docs":{},"c":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"(":{"docs":{},"f":{"docs":{},"i":{"docs":{},"r":{"docs":{},"s":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}}}}},"a":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}}},"(":{"docs":{},"a":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}}}}}}},"w":{"docs":{},"e":{"docs":{},"a":{"docs":{},"k":{"docs":{},"m":{"docs":{},"a":{"docs":{},"p":{"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542}}}}},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542}}}}}}}},"&":{"docs":{},"g":{"docs":{},"t":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.002336448598130841},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.006980802792321117}}}}},"i":{"docs":{},"n":{"docs":{},"d":{"docs":{},"o":{"docs":{},"w":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.009345794392523364}},"s":{"docs":{},".":{"docs":{},"r":{"docs":{},"e":{"docs":{},"g":{"docs":{},"e":{"docs":{},"x":{"docs":{},"p":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.002336448598130841}}}}}}}}}}}}}}},"o":{"docs":{},"r":{"docs":{},"l":{"docs":{},"d":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968}},"!":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.002976190476190476}}}}}}}}}}}}},"y":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.013888888888888888}},"a":{"docs":{},"h":{"docs":{},"o":{"docs":{},"o":{"docs":{"manuscript/00-Introduction.html":{"ref":"manuscript/00-Introduction.html","tf":0.007633587786259542}}}}}},"e":{"docs":{},"a":{"docs":{},"r":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}},"o":{"docs":{},"!":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475}}}}}}}}}},"b":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.004672897196261682},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.005460750853242321},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.013961605584642234}},"i":{"docs":{},"n":{"docs":{},"d":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0034129692832764505}},"(":{"docs":{},"t":{"docs":{},"h":{"docs":{},"i":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0020477815699658703}}}}}}}}},"o":{"docs":{},"o":{"docs":{},"k":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}},"d":{"docs":{},"a":{"docs":{},"t":{"docs":{},"a":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}},"u":{"docs":{},"n":{"docs":{},"d":{"docs":{},"s":{"docs":{},"u":{"docs":{},"m":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}}}}}},"f":{"docs":{},"a":{"docs":{},"l":{"docs":{},"s":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.007009345794392523},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.01488095238095238},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.005460750853242321},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.008241758241758242},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0034904013961605585}}}},"c":{"docs":{},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{},"i":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0020477815699658703}},"a":{"docs":{},"l":{"docs":{},"(":{"docs":{},"n":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0027303754266211604}}}}}}}}}}}},"o":{"docs":{},"n":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.004672897196261682}}},"r":{"docs":{},"m":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968}}}}},"u":{"docs":{},"n":{"docs":{},"c":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.02570093457943925},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0027303754266211604}},"s":{"docs":{},".":{"docs":{},"f":{"docs":{},"o":{"docs":{},"r":{"docs":{},"e":{"docs":{},"a":{"docs":{},"c":{"docs":{},"h":{"docs":{},"(":{"docs":{},"f":{"docs":{},"u":{"docs":{},"n":{"docs":{},"c":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"(":{"docs":{},"f":{"docs":{},"u":{"docs":{},"n":{"docs":{},"c":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.011682242990654205}}}}}}}}}}}}}}}}}}}}}}},"p":{"docs":{},"u":{"docs":{},"s":{"docs":{},"h":{"docs":{},"(":{"docs":{},"(":{"docs":{},"f":{"docs":{},"u":{"docs":{},"n":{"docs":{},"c":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"(":{"docs":{},"v":{"docs":{},"a":{"docs":{},"l":{"docs":{},"u":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.002336448598130841}}}}}}}}}}}}}}}},"f":{"docs":{},"u":{"docs":{},"n":{"docs":{},"c":{"docs":{},"t":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.011682242990654205}}}}}}}}}}}}}},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.011682242990654205},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.007936507936507936},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.04436860068259386},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.02197802197802198},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.010471204188481676}},"(":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},".":{"docs":{},".":{"docs":{},".":{"docs":{},"a":{"docs":{},"r":{"docs":{},"g":{"docs":{},"s":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}}}}},"f":{"docs":{},"i":{"docs":{},"r":{"docs":{},"s":{"docs":{},"t":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}}}}}}}}}}}}}},")":{"docs":{},")":{"docs":{},".":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}},"b":{"docs":{},"o":{"docs":{},"d":{"docs":{},"i":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0020477815699658703}}}}}},"e":{"docs":{},"v":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}},"i":{"docs":{},"d":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}},"u":{"docs":{},"m":{"1":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}},"docs":{}}}},"t":{"docs":{},"y":{"docs":{},"p":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0020477815699658703}}}}},"v":{"docs":{},"a":{"docs":{},"l":{"docs":{},"u":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}}}}},"f":{"docs":{},"f":{"docs":{},"f":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}},"i":{"docs":{},"r":{"docs":{},"e":{"docs":{},"f":{"docs":{},"o":{"docs":{},"x":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}},"s":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.002976190476190476},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.020477815699658702}},".":{"docs":{},"n":{"docs":{},"o":{"docs":{},"r":{"docs":{},"m":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}},"a":{"docs":{},"l":{"docs":{},"i":{"docs":{},"z":{"docs":{},"e":{"docs":{},"(":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{},";":{"docs":{},"n":{"docs":{},"f":{"docs":{},"d":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}}}}}}}}}}}}}},"n":{"docs":{},"o":{"docs":{},"r":{"docs":{},"m":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.005952380952380952}}}}},"a":{"docs":{},"m":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}},"e":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}}}}}}},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}},"c":{"docs":{},"o":{"docs":{},"l":{"docs":{},"o":{"docs":{},"r":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.015706806282722512}}}}}}}}}}},"l":{"docs":{},"a":{"docs":{},"g":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.007936507936507936}}}}},"r":{"docs":{},"i":{"docs":{},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.020604395604395604}},".":{"docs":{},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"g":{"docs":{},"r":{"docs":{},"e":{"docs":{},"e":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.008241758241758242}},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"(":{"docs":{},")":{"docs":{},".":{"docs":{},"c":{"docs":{},"a":{"docs":{},"l":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}}}}}}}}}}}}}}}}}}}},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.014018691588785047},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0034129692832764505}},"s":{"docs":{},".":{"docs":{},"l":{"docs":{},"e":{"docs":{},"n":{"docs":{},"g":{"docs":{},"t":{"docs":{},"h":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}}}}}}}}},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.017857142857142856},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.006825938566552901},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.016483516483516484}},";":{"0":{"1":{"2":{"docs":{},"a":{"docs":{},"c":{"docs":{},"b":{"docs":{},"d":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}}}}}},"docs":{}},"docs":{}},"1":{"0":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.002336448598130841}}}}}}}},"2":{"3":{"4":{"5":{"6":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0020477815699658703}}}}}}}},"docs":{}},"docs":{}},"docs":{}},"docs":{}},"docs":{}},"2":{"docs":{},".":{"5":{"0":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}},"docs":{}},"docs":{}}},"5":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.004120879120879121}}}}}}}},"docs":{},"a":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.004672897196261682},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}},"b":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}},"c":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}},"a":{"docs":{},"b":{"docs":{},"c":{"docs":{},"a":{"docs":{},"b":{"docs":{},"c":{"docs":{},"a":{"docs":{},"b":{"docs":{},"c":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}}}}},"e":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}},"n":{"docs":{},"o":{"docs":{},"n":{"docs":{},"y":{"docs":{},"m":{"docs":{},"o":{"docs":{},"u":{"docs":{},"s":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}}}}}}}}}}},"r":{"docs":{},"r":{"docs":{},"o":{"docs":{},"w":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}},"u":{"docs":{},"t":{"docs":{},"h":{"docs":{},"o":{"docs":{},"r":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}}}},"b":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.004672897196261682},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0027303754266211604}}}}}}},"l":{"docs":{},"u":{"docs":{},"e":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.011682242990654205},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.017452006980802792}}}}}}}}},"a":{"docs":{},"c":{"docs":{},"k":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0017452006980802793}}}}}}}}}}},"o":{"docs":{},"u":{"docs":{},"n":{"docs":{},"d":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0020477815699658703}},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}},"a":{"docs":{},"r":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.005235602094240838}}}}}}}}}},"c":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.007009345794392523},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0020477815699658703}}}}}}},"s":{"docs":{},"s":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.004120879120879121}}}}}}}}}},"g":{"docs":{},"o":{"docs":{},"o":{"docs":{},"d":{"docs":{},"b":{"docs":{},"y":{"docs":{},"e":{"docs":{},"!":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.002336448598130841}}}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"g":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.004672897196261682},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.005494505494505495}}}}}}}},"e":{"docs":{},"n":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.029668411867364748}}}}}}}}}}},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968}}}}}}},"e":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}},"h":{"docs":{},"e":{"docs":{},"l":{"docs":{},"l":{"docs":{},"o":{"1":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.011904761904761904}}},"2":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968}}},"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.002976190476190476},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.008241758241758242}},"!":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.011682242990654205}}}}}}}},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.013736263736263736}}}}}}},"h":{"docs":{},"e":{"docs":{},"l":{"docs":{},"l":{"docs":{},"o":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}}}}}}},"i":{"docs":{},"!":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.009345794392523364},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}}}},"n":{"docs":{},"i":{"docs":{},"c":{"docs":{},"h":{"docs":{},"o":{"docs":{},"l":{"docs":{},"a":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}},"s":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.002336448598130841},"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.005460750853242321},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.017857142857142856}}}}}}}}}}}}}},"f":{"docs":{},"c":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}},"d":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}},"k":{"docs":{},"c":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}},"d":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}},"a":{"docs":{},"m":{"docs":{},"e":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}}}}},"u":{"docs":{},"n":{"docs":{},"d":{"docs":{},"e":{"docs":{},"f":{"docs":{},"i":{"docs":{},"n":{"docs":{},"e":{"docs":{},"d":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.004672897196261682},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0034129692832764505}}}}}}}}}}}},"r":{"docs":{},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"n":{"docs":{},"d":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}},"s":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0061433447098976105},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0027472527472527475}}}},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.00496031746031746}}}}}}},".":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}},"r":{"docs":{},"e":{"docs":{},"p":{"docs":{},"e":{"docs":{},"a":{"docs":{},"t":{"docs":{},"(":{"4":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}},"docs":{}}}}}}}}},"/":{"docs":{},"a":{"docs":{},"b":{"docs":{},"/":{"docs":{},"g":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}}}}}},"i":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}},"f":{"docs":{},"o":{"docs":{},"o":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0017452006980802793}}}}}}}},"\\":{"docs":{},"\\":{"docs":{},"n":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}},"`":{"docs":{},"h":{"docs":{},"e":{"docs":{},"l":{"docs":{},"l":{"docs":{},"o":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}},"e":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}},"x":{"docs":{},"a":{"docs":{},"m":{"docs":{},"p":{"docs":{},"l":{"docs":{},"e":{"docs":{},".":{"docs":{},"c":{"docs":{},"o":{"docs":{},"m":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0017452006980802793}}}}}}}}}}}}}}}}}},"m":{"docs":{},"u":{"docs":{},"l":{"docs":{},"t":{"docs":{},"i":{"docs":{},"l":{"docs":{},"i":{"docs":{},"n":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.00992063492063492}},"e":{"docs":{},"\\":{"docs":{},"\\":{"docs":{},"n":{"docs":{},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}}}}}}}}}}}}}}}}}}}}}}},"i":{"docs":{},"c":{"docs":{},"h":{"docs":{},"a":{"docs":{},"e":{"docs":{},"l":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}}}}}}}}}},"o":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}},"r":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0020477815699658703}}}}}},"d":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.02443280977312391}}}}}}}}}},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.003968253968253968}}}}}}}}}}}},"a":{"docs":{},"y":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{},"e":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}}}}}}},"e":{"docs":{},"c":{"docs":{},"o":{"docs":{},"n":{"docs":{},"d":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}},"t":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}},"w":{"docs":{},"o":{"docs":{},"r":{"docs":{},"l":{"docs":{},"d":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}},"o":{"docs":{},"f":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.005494505494505495}}}}}}}}}}},"x":{"docs":{},"x":{"docs":{},"x":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}},"y":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}},"e":{"docs":{},"a":{"docs":{},"r":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}},"æ":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}},"�":{"docs":{},"�":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.002976190476190476}}}}}}},"a":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}},"b":{"docs":{},"c":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}}}}}}},"[":{"docs":{},"o":{"docs":{},"b":{"docs":{},"j":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}},"r":{"docs":{},"e":{"docs":{},"d":{"docs":{},",":{"docs":{},"g":{"docs":{},"r":{"docs":{},"e":{"docs":{},"e":{"docs":{},"n":{"docs":{},",":{"docs":{},"b":{"docs":{},"l":{"docs":{},"u":{"docs":{},"e":{"docs":{},"]":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0034904013961605585}}}}}}}}}}}}}}}}}}}}}}},"d":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0020477815699658703}}}}}}},"o":{"docs":{},"a":{"docs":{},"n":{"docs":{},"o":{"docs":{},"t":{"docs":{},"h":{"docs":{},"e":{"docs":{},"r":{"docs":{},"t":{"docs":{},"h":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"o":{"docs":{},"m":{"docs":{},"e":{"docs":{},"t":{"docs":{},"h":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}}},"e":{"docs":{},"l":{"docs":{},"s":{"docs":{},"e":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}}}}}}}}}}}}}}}}}},"f":{"docs":{},"u":{"docs":{},"n":{"docs":{},"c":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0034129692832764505}}}}}}}}}}}}}},"i":{"docs":{},"l":{"docs":{},"e":{"docs":{},".":{"docs":{},"j":{"docs":{},"s":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.008241758241758242}}}}}}}}}}}},"r":{"docs":{},"s":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.006868131868131868}},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}}}}},"o":{"docs":{},"o":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.02617801047120419}}}}}}}}}},"t":{"docs":{},"e":{"docs":{},"m":{"docs":{},"p":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0013651877133105802}}}}}}}}}}},"j":{"docs":{},"s":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.005235602094240838}}}}}}}}},"l":{"docs":{},"a":{"docs":{},"s":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.006868131868131868}},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}}}}}}}}},"i":{"docs":{},"g":{"docs":{},"h":{"docs":{},"t":{"docs":{},"g":{"docs":{},"r":{"docs":{},"e":{"docs":{},"e":{"docs":{},"n":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0017452006980802793}}}}}}}}}}}}}}},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{},"a":{"docs":{},"l":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0034904013961605585}}}}}}}}}}}}}},"z":{"docs":{},"a":{"docs":{},"k":{"docs":{},"a":{"docs":{},"s":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.009615384615384616}}}}}}}}}}}},"і":{"docs":{},"м":{"docs":{},"&":{"docs":{},"#":{"3":{"9":{"docs":{"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737}}},"docs":{}},"docs":{}}}}},"i":{"docs":{},"d":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},"i":{"docs":{},"f":{"docs":{},"i":{"docs":{},"e":{"docs":{},"r":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.029668411867364748}}}}}}}}}}}}}}}}},"p":{"docs":{},"u":{"docs":{},"r":{"docs":{},"p":{"docs":{},"l":{"docs":{},"e":{"docs":{},"&":{"docs":{},"q":{"docs":{},"u":{"docs":{},"o":{"docs":{},"t":{"docs":{"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.0017452006980802793}}}}}}}}}}}}}}}}}},"u":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.015873015873015872}},"n":{"docs":{},"d":{"docs":{},"e":{"docs":{},"f":{"docs":{},"i":{"docs":{},"n":{"docs":{"manuscript/01-Block-Bindings.html":{"ref":"manuscript/01-Block-Bindings.html","tf":0.007009345794392523},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.00477815699658703},"manuscript/04-Objects.html":{"ref":"manuscript/04-Objects.html","tf":0.0013736263736263737},"manuscript/05-Destructuring.html":{"ref":"manuscript/05-Destructuring.html","tf":0.02617801047120419}}}}},"r":{"docs":{},"s":{"docs":{},"c":{"docs":{},"o":{"docs":{},"r":{"docs":{},"e":{"docs":{},".":{"docs":{},"j":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}}}}}}}}},"i":{"docs":{},"c":{"docs":{},"o":{"docs":{},"d":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.01488095238095238}}}}},"t":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}},"c":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.001984126984126984}}},"s":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492},"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0034129692832764505}}},"t":{"docs":{},"f":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.00992063492063492}}}},"r":{"docs":{},"l":{"docs":{"manuscript/03-Functions.html":{"ref":"manuscript/03-Functions.html","tf":0.0006825938566552901}}}}},"x":{"docs":{},"s":{"docs":{},"s":{"docs":{"manuscript/02-Strings-and-Regular-Expressions.html":{"ref":"manuscript/02-Strings-and-Regular-Expressions.html","tf":0.000992063492063492}}}}}},"length":973},"corpusTokens":["0","0.25","0xffff","1","10","100","11","12","13","134071","14","16","17","1999","2","2.50.&quot","2000","2007","2008","2014","2015","2016","25","262","2^16","3","3.0","3.1","30","31","32","360000000","39","39;new&#39","4","40","4149","4378","5","50","500","5069","5501","55362","57271","6","6&quot","60000","7","75","8","9","97","a&gt","ab/g","ab/i","add","add(1","add(first","add(undefin","ag","ajax","anotherperson","anotherperson(&quot;nicholas&quot","anotherperson(nam","api","appli","args[0]&quot","argument","arguments.length","arguments[0","arguments[1","arraw","array","arrow","arrowfunct","assign","author","b","bind","bind(thi","book","bookdata","boundsum","c","c.codepointat(0","call","call(thi","callback","can&#39;t","canon","catch","cc","charat","charcodeat","checkarg","checkargs(&quot;a&quot","checkargs(...arg","clonedcolor","code","codepointat","codepointlength(text","color","colors.concat","column","compar","compat","composit","concat","condit","console.log","console.log(&quot;abc&quot;.repeat(4","console.log(&quot;handl","console.log(&quot;hello&quot;.repeat(2","console.log(&quot;ncz&quot","console.log(&quot;x&quot;.repeat(3","console.log((new","console.log(+0","console.log(/^.$/.test(text","console.log(/^.$/u.test(text","console.log(5","console.log(a","console.log(add(1","console.log(add(undefin","console.log(args.length","console.log(args[0","console.log(args[1","console.log(arguments.length","console.log(arrowfunct","console.log(b","console.log(bookdata.author","console.log(bookdata.year","console.log(boundsum","console.log(clonedcolor","console.log(codepointlength(&quot;abc&quot","console.log(codepointlength(&quot;𠮷bc&quot","console.log(compar","console.log(descriptor.get","console.log(descriptor.valu","console.log(doanotherthing.nam","console.log(dosomething.bind().nam","console.log(dosomething.nam","console.log(first","console.log(firstcolor","console.log(friend.getgreet","console.log(getflags(r","console.log(globalpattern.lastindex","console.log(globalresult[0","console.log(i","console.log(is32bit(&quot;a&quot","console.log(is32bit(&quot;𠮷&quot","console.log(key","console.log(localnam","console.log(localstart.column","console.log(localstart.lin","console.log(localtyp","console.log(math.max(...valu","console.log(math.max(25","console.log(math.max(value1","console.log(math.max.apply(math","console.log(messag","console.log(message.length","console.log(message1","console.log(message2","console.log(msg.endswith(&quot;!&quot","console.log(msg.endswith(&quot;o&quot","console.log(msg.endswith(&quot;world!&quot","console.log(msg.includes(&quot;o&quot","console.log(msg.includes(&quot;x&quot","console.log(msg.startswith(&quot;hello&quot","console.log(msg.startswith(&quot;o&quot","console.log(nam","console.log(nan","console.log(ncz","console.log(notaperson","console.log(object.getownpropertynames(obj).join(&quot;&quot","console.log(object.getprototypeof(friend","console.log(object.is(+0","console.log(object.is(5","console.log(object.is(nan","console.log(pattern.lastindex","console.log(pattern.sticki","console.log(person","console.log(person.firstname.nam","console.log(person.getgreet","console.log(person.getnam","console.log(person.nam","console.log(person.sayname.nam","console.log(person[&quot;first","console.log(person[&quot;last","console.log(person[lastnam","console.log(pickfirst(1","console.log(re.flag","console.log(re.sourc","console.log(re1.test(&quot;ab&quot","console.log(re1.tostr","console.log(re2.test(&quot;ab&quot","console.log(re2.tostr","console.log(receiver.nam","console.log(receiver.typ","console.log(regexp","console.log(relative.getgreet","console.log(restcolors.length","console.log(restcolors[0","console.log(restcolors[1","console.log(result[0","console.log(second","console.log(secondcolor","console.log(start.column","console.log(start.lin","console.log(startindex","console.log(stickypattern.lastindex","console.log(stickyresult[0","console.log(string.fromcodepoint(134071","console.log(sum.apply(nul","console.log(sum.call(nul","console.log(text.charat(0","console.log(text.charat(1","console.log(text.charcodeat(0","console.log(text.charcodeat(1","console.log(text.charcodeat(2","console.log(text.codepointat(0","console.log(text.codepointat(1","console.log(text.codepointat(2","console.log(text.length","console.log(thirdcolor","console.log(this.nam","console.log(typ","console.log(typeof","console.log(valu","console.log(window.ncz","console.log(window.regexp","const","construct","constructor","cooki","cost","count","createarrowfunctionreturningfirstarg","createarrowfunctionreturningfirstarg(5","createperson","createperson(nam","d","date","date(date.now","decomposit","deni","descriptor","destructur","doanotherth","document","document.addeventlistener(&quot;click&quot","doesn&#39;t","dog","domain","donoth","dosometh","dosomething&quot","dosomething(bodi","dosomething.nam","dosomethingels","dovhan","dsl","ecma","ecmascript","ecmasctipt","emit","end","endswith","epub","error","error(&quot;y","es5","es6","escap","event","eventtarget","eventtarget.prototyp","ex","exec","exist","expir","express","extend","factori","factorial(n","fals","ffff","firefox","first","first&quot","first.norm","first.normalize(&quot;nfd&quot","firstcolor","firstnam","firstname&quot","firstnorm","flag","fon","form","friend","friend.getgreet","friend.getgreeting().cal","func","funcs.foreach(function(func","funcs.push((function(valu","funcs.push(funct","function","function(&quot;...args&quot","function(&quot;first&quot","function()).nam","function(bodi","function(ev","function(id","function(nam","function(num1","function(typ","function(valu","g","getflags(r","getglobalgreet","getgreet","getnam","gettempitem","getvalu","getvalue(condit","getvalue(first","getvalue(valu","globalpattern","globalpattern.exec(text","globalpattern.lastindex","globalresult","googl","gt","harmoni","hasregexpi","hasregexpu","hello","hello2","hello3&quot","hello\\d/i","hello\\d\\","hello\\d\\s?/g","hello\\d\\s?/i","here","hi!&quot","homeobject","html","http://groups.google.com/group/zakasbook","https://github.com/denysdovhan/understandinges6ua","https://github.com/nzakas/understandinges6","i&gt","i=0","id","iif","immedi","includ","indent","indent.repeat(++indentlevel","indentlevel","indexof","init","instanceof","instead","invok","is32bit(c","isnan","issu","item","javascript","javascript&#39;","join(&quot;\\n&quot","json","json.stringifi","key","keys.length","last","lastindex","lastindexof","lastnam","leanpub","len","length","line","liter","literals.length","literals.raw","literals.raw[0","literals.raw[i","literals.raw[literals.length","literals[0","literals[i","literals[literals.length","loc","localnam","localstart","localtyp","lt","lt;/div&gt;`.trim","lt;div&gt","lt;h1&gt;title&lt;/h1&gt","lеt","makerequest","makerequest(&quot;/foo&quot","makerequest(url","map","match","math.max","math.max.appli","maxitem","messag","message1","message2","microsoft","mix","mixarg","mixargs(&quot;a&quot","mixargs(first","mixin","mixin(myobject","mixin(receiv","mobi","mode","more","msg","msg.endswith(&quot;o&quot","msg.includes(&quot;o&quot","msg.startswith(&quot;o&quot","multilin","multiline\\nstr","myobject","myobject.emit(&quot;somethingchanged&quot","mytyp","n","n&quot","name","name&quot","name(...valu","nan","nc","ncz","nd","new","new.target","newind","nfc","nichola","nicholas.&quot","node","node.j","node.loc.start","node.nam","node.range[0","node.typ","node.valu","non","nonstrict","normal","normalized.sort(function(first","notaperson","null","num","num1","num2","nzt","o","obj","obj.d","object","object.assign","object.assign(myobject","object.assign(receiv","object.cr","object.create(friend","object.create(nul","object.create(person","object.getownpropertydescriptor(receiv","object.getownpropertynam","object.getprototypeof","object.getprototypeof(thi","object.getprototypeof(this).getgreeting.call(thi","object.i","object.key","object.keys(supplier).foreach(function(key","object.mixin","object.prototyp","object.setprototypeof","object.setprototypeof(friend","object[arguments[i","object[keys[i","object]&quot","option","options.domain","options.expir","options.path","options.repeat","options.sav","options.secur","outputinfo","outputinfo(valu","oзвo","p","pagehandl","param","paramet","passthru","passthru(liter","passthru`${count","path","pattern","pattern.exec(text","pattern.lastindex","pdf","permiss","person","person(&quot;nicholas&quot","person(nam","person.&quot","person.cal","person.call(person","person.call(thi","person.firstnam","person.getgreet","person.nam","person.saynam","person[&quot;first","person[lastnam","pick","pick(book","pick(object","pickfirst","point","press","price","price).tofixed(2","process(items[i","prototyp","pull","quot","quot;&quot","quot;.&quot","quot;.repeat(4","quot;/&quot","quot;/ab/g&quot","quot;/ab/i&quot","quot;/foo&quot","quot;012acbd&quot","quot;10","quot;10&quot","quot;123456&quot","quot;2.50&quot","quot;5&quot","quot;[object","quot;[red,green,blue]&quot","quot;\\\\n&quot","quot;`hello","quot;a&quot","quot;ab&quot","quot;abc&quot","quot;abcabcabcabc&quot","quot;ae&quot","quot;anonymous&quot","quot;arrow&quot","quot;author&quot","quot;b&quot","quot;bar&quot","quot;black&quot","quot;blue&quot","quot;bound","quot;bound&quot","quot;c&quot","quot;css&quot","quot;d&quot","quot;doanotherthing&quot","quot;dosomething&quot","quot;dosomethingelse&quot","quot;e&quot","quot;example.com&quot","quot;file.js&quot","quot;first","quot;first&quot","quot;foo&quot","quot;function&quot","quot;g&quot","quot;get","quot;goodbye!&quot","quot;green&quot","quot;greg&quot","quot;hello","quot;hello!&quot","quot;hello&quot","quot;hello1","quot;hello2","quot;hellohello&quot","quot;hi!&quot","quot;identifier&quot","quot;js&quot","quot;last","quot;last&quot","quot;lightgreen&quot","quot;literal&quot","quot;michael&quot","quot;multilin","quot;multiline\\\\nstring&quot","quot;name&quot","quot;nfc&quot","quot;nfd&quot","quot;nfkc&quot","quot;nfkd&quot","quot;nichola","quot;nicholas&quot","quot;o&quot","quot;purple&quot","quot;r&quot","quot;red&quot","quot;return","quot;sayname&quot","quot;second","quot;second&quot","quot;set&quot","quot;string&quot","quot;temp&quot","quot;u&quot","quot;undefined&quot","quot;understand","quot;us","quot;woof","quot;woof&quot","quot;world&quot","quot;xxx&quot","quot;y&quot","quot;year&quot","quot;zakas&quot","quot;æ&quot","quot;ім&#39","quot;𠮷&quot","quot;𠮷a&quot","quot;𠮷bc&quot","rang","raw","raw(liter","raw`multiline\\nstr","re","re.tostr","re1","re2","receiv","receiver.nam","receiver.typ","receiver[key","reduc","reflect","reflect.ownkey","regexp","regexp(&quot;.&quot","regexp(re1","regular","rel","relative.getgreet","repeat","request","rest","restcolor","result","result.length","result[arguments[i","result[keys[i","return","rrow","sahaidak","save","saynam","second","second&quot","second.norm","second.normalize(&quot;nfd&quot","secondcolor","secondnorm","section","secur","set","setcooki","setcookie(&quot;type&quot","setcookie(nam","setter","sharegreet","sort","sourc","spread","sql","starch","start","startindex","startswith","sticki","stickypattern","stickypattern.exec(text","stickypattern.lastindex","stickyresult","strawman","strict","strict&quot","string","string&quot","string.fromcharcod","string.fromcodepoint","string.raw","string.raw`multiline\\nstr","substitut","substitutions.length","substitutions[i","suffix","sum","sum.bind(nul","super","super&quot","super.getgreet","supplier","supplier.nam","supplier[key","syntax","tag","tag(liter","tag`hello","tail","tc","templat","terri","test","text","text.length","text.match(/[\\s\\s]/gu","text.norm","text.substring(text.lastindexof(&quot;/&quot","thirdcolor","this.dosometh","this.dosomething(event.typ","this.id","this.nam","throw","timeout","titl","tmp","tofix","tostr","translat","tri","trim","true","type","typeof","u","uc","undefin","underscore.j","unicod","unit","url","us","utf","valu","value1","value2","values.map(function(text","values.sort((a","values.sort(function(a","values.sort(function(first","var","w&gt","weakmap","weakset","window","windows.regexp","world","world!&quot","xss","y","yahoo","year","yo!&quot","zaka","zakas&quot"],"pipeline":["trimmer","stopWordFilter","stemmer"]},"store":{"./":{"url":"./","title":"Рoзуміння ECMAScript 6","body":"Рoзуміння ECMAScript 6\n\n\n \n\n\n\n\n\nПерекладенo з дoзвoлу No Starch Press та Нікoласа Закаса.Translated with permission from No Starch Press and Nicholas C. Zakas.\n\nECMASctipt 6 відображає найбільші зміни ядра JavaScript у його історії. Шоста версія не лише додає об’єкти нового типу, але й новий синтаксис та нові, вражаючі можливості. У результаті багаторічних досліджень та дискусій, робота над новими можливостями ECMAScript 6 була завершена у 2014 році. Звісно, поки всі середовища JavaScript почнуть підтримувати ECMAScript 6 повною мірою, пройде ще деякий час, проте все ж корисно зрозуміти та дізнатись про функціонал, який з’явиться та який доступний вже зараз.\nЦя книга є керівництвом для переходу з 5-ї на 6-у весію ECMAScript. Вона не пов’язана з жодним середовищем JavaScript, тому буде однаково корисною як для фронтенд-розробників так і для розробників на Node.js\nВи дізнаєтесь про:\n\nвсі зміни у мові, починаючи з ECMAScript 5;\nяк новий синтаксис класів пов’язаний зі звичною концепцією JavaScript;\nчому ітератори та генератори корисні;\nяк arrow-функції відрізняються від звичайних функцій;\nдодаткові можливості для зберігання данних з допомогою sets, maps та ін.;\nсилу успадкування від рідних типів;\nчому люди в захопленні від промісів та асинхронного програмування;\nяк модулі змінять організацію вашого коду.\n\nДе читати\nПереклад доступний для завантаження у форматах PDF, ePub та Mobi. Онлайн-версія перекладу доступна для читання безкоштовно та містить найсвіжіші зміни. Розділи можуть бути незакінченими, проте переклад має бути правильним. Переклад оновлюється кілька разів на місяць. \nОригінальний англомовний варіант книги також можна читати онлайн.\nПридбати копію\nВи можете замовити електронну копію оригінальної версії книги через Leanpub. Детальніше дізнавайтесь за посиланням.\nДруковану версію англомовного видання можна буде придбати у видавництві No Starch Press, яке видасть її як тільки книга буде завершена (орієнтовно на початку 2016-го).\nНа жаль, друковану версію перекладу придбати неможливо, через відсутність видавця. Якщо ви хочете стати нашим видавцем або маєте будь-які ідеї щодо друку перекладу, напишіть нам.\nДопомога автору\nВи можете допомогти Ніколасу Закасу швидше завершити роботу над книгою, ставши його патроном.\nПідтримка перекладу\nЯкщо Вам сподобався цей переклад і ви хочете допомогти нам, перш за все, ми дякуємо Вам! Є декілька способів посприяти нам:\nНаписати нам\nЯкщо Ви помітили яку-небудь помилку, повідомте нас, або виправте та надішліть pull request.\nНе соромтесь надсилати запитання та побажання, які стосуються перекладу книги. Ми обов’язково візьмемо до уваги конструктивну критику з вашого боку.\nПерекласти розділ\nВи можете обрати один з досі неперекладених розділів і спробувати перекласти його. Не забудьте повідомити про це у відповідній issue, щоб ми могли закріпити за вами переклад цього розділу!\nЯк тільки ви завершите переклад, надішліть нам pull request, з посиланням на відповідну issue.\nПідтримати матеріально\nВи також можете надіслати кошти в підтримку проекту на картку:\n4149 4378 5069 5501\nЛіцензія\nCC BY-NC-ND 3.0 © Denys Dovhan and Terry Sahaidak\n\n\n"},"manuscript/00-Introduction.html":{"url":"manuscript/00-Introduction.html","title":"Вступ","body":"Вступ\nОсобливості ядра мови JavaScript визначені у стандарті під назвою ECMA-262. Мова, яку визначає цей стандарт, називається ECMAScript, з якої JavaScript у браузерах та оточенні Node.js є надбудовою. У той час, коли браузери та Node.js можуть розширювати можливості за допомогою додаткових об’єктів та методів, ядро мови залишається таким, яким воно визначене у ECMAScript, тому розвиток ECMA-262 є життєво важливим для успіху JavaScript в цілому.\nУ 2007 році JavaScript опинився на роздоріжжі. Популярність Ajax породила нову епоху динамічних веб–додатків у той час, коли JavaScript не змінювався зі своєї третьої редакції ECMA-262, опублікованої у 1999 році. TC-39, комітет відповідальний за розвиток ECMAScript, зібрав великий проект специфікації ECMAScript 4. ECMAScript 4 був всеохоплюючим, вносячи у мову як маленькі так і великі зміни. Нововведення включали новий синтаксис, модулі, класи, класичне наслідування, приватні методи, можливість оголошувати власні типи та інше.\nЗміни, що охоплювали ECMAScript 4 викликали розкол у TC-39: деякі учасники вважали, що четверта редакція надто радикальна. Група лідерів з Yahoo, Google, та Microsoft запропонували альтернативу наступній версії ECMAScript, яку спочатку назвали ECMAScript 3.1. Версія «3.1» мала демонструвати поступові зміни у існуючому стандарті.\nECMAScript 3.1 вводив кілька синтаксичних змін, але не фокусувався на властивостях атрибутів, вбудованій підтримці JSON, додаванні методів до вже існуючих об’єктів. Хоча спочатку були спроби узгодити ECMAScript 3.1 та ECMAScript 4, зрештою це не вдалось, оскільки обидва табори мали вкрай різні погляди на те, в якому напрямку повинна розвиватись мова.\nУ 2008, Брендан Айк, творець JavaScript, анонсував, що TC-39 зосередить свої зусилля на стандартизації ECMAScript 3.1. Вони вирішили, що представлять мажорні синтаксичні та функціональні зміни ECMAScript 4 тільки після того, як нова версія ECMAScript буде стандартизованою, і всі члени комітету будуть працювати для того, щоб зібрати найкраще з ECMAScript 3.1 та 4 разом — ці зусилля були названі ECMAScript Harmony.\nЗрештою, ECMAScript 3.1 був стандартизований п’ятою версією ECMA-262, також відомою як ECMAScript 5. Комітет ухвалив рішення не випускати стандарт ECMAScript 4, щоб уникнути плутанини зі стандартом, який мав таке ж ім’я, проте припинив своє існування. Потім розпочалась робота над ECMAScript Harmony, а ECMAScript 6 став першим стандартом, випущеним у цьому новому «гармонійному» руслі.\nECMAScript 6 досягнув функціонально завершеного статусу у 2015 році та був офіційно названим «ECMAScript 2015» (хоча цей текст досі називає його ECMAScript 6, оскільки така назва більш звична розробникам). Нововведення варіюються від повністю нових об’єктів та патернів до синтаксичних змін нових методів вже існуючих об’єктів. Найцікавіша річ у ECMAScript 6 — це те, що всі ці зміни спрямовані на проблеми, з якими безпосередньо зустрічаються розробники. Хоч потрібен час на те, щоб ECMAScript 6 був адаптований та реалізований хоч на мінімум, якого очікують розробники, зате ми вже можемо багато чого навчитись, дізнавшись про те, яким виглядає майбутнє JavaScript.\nСумісність з браузерами та Node.js\nБагато середовищ JavaScript, як от веб–браузери та Node.js, активно працюють над імплементацією ECMAScript 6. Ця книга не має на меті порівнювати різні реалізації, натомість вона сфокусована на тому, що специфікація визначає правильною поведінкою. Таким чином, цілком можливо, що поведінка вашого оточення JavaScript може не відповідати тій поведінці, яка описана у цій книзі.\nДля кого ця книга\nЦя книга є керівництвом для тих, хто вже знайомий з JavaScript та ECMAScript 5. Глибокі знання мови не є необхідними для читання, проте стануть у нагоді для розуміння відмінностей між ECMAScript 5 та 6. Зокрема, ця книга націлена на розробників середнього та високого рівня (незалежно від браузерного чи Node.js оточення), які хочуть дізнатись про майбутнє цієї мови.\nЦя книга не для початківців, які ніколи не писали на JavaScript. Вам потрібне хороше, ґрунтовне розуміння мови, щоб користуватись цією книгою.\nОгляд\nГлава 1: Блочне зв’язування розповідає про let та const — замінники var з блочною областю видимості.\nГлава 2: Рядки та регулярні вирази охоплює розширенні можливості маніпуляцій рядками та вступ до шаблонних рядків.\nГлава 3: Функції розбирає різноманітні зміни у функціях. Включаює arrow-функції, параметри за замовчуванням, залишкові параметри та інше.\nГлава 4: Об’єкти пояснює відмінності у створенні, модифікації та зміні об’єктів. Тема включає зміни у синтаксисі об’єктних літералів та нові методи відображення.\nГлава 5: Деструктурування вводить в деструктурування об’єктів та масивів, що дає нам можливість розкладати об’єкти та масиви, використовуючи короткий синтаксис.\nГлава 6: Символи вводить нас в концепцію символів — новий спосіб задання властивостей. Символи — новий примітивний тип, який можна використати для оголошення неявних (але не прихованих) властивостей та методів об’єкта.\nГлава 7: Sets та Maps розповідає про тонкощі роботи з новими типами колекцій: Set, WeakSet, Map, та WeakMap. Ці типи розширюють можливості масивів, додаючи семантику, дедублікацію та керування пам’яттю, розроблену спеціально для JavaScript.\nГлава 8: Ітератори та генератори пояснює яким чином працювати з ітераторами та генераторами, що дають нам можливість оперувати колекціями данних способом, який був недоступний у попередніх версіях JavaScript.\nГлава 9: Класи вводить у початкову концепцію класів у JavaScript. Це часто викликало плутанину у тих, хто переходив з інших мов програмування. Введення синтаксису класів у JavaScript робить мову більш доступною для новачків та більш виразною для ентузіастів.\nГлава 10: Масиви розповідає про зміни, які стосуються масивів та нові шляхи їх застосування у JavaScript.\nГлава 11: Проміси пояснює про нову частину мови — проміси. Проміси були розроблені звичайними розробниками та набули популярності завдяки зручності та розширеній підтримці іншими бібліотеками. ECMAScript 6 формалізує проміси та робить їх доступними за замовчуванням.\nГлава 12: Проксі та Рефлексія вводить формалізоване API рефлексії та новий об’єкт проксі, що дозволяє нам перехоплювати кожну операцію, яка виконана над об’єктом. Проксі дають розробникам безпрецедентний контроль над об’єктами, як от необмежені можливості для визначення нових патернів взаємодії.\nГлава 13: Модулі описує офіційний формат модулів для JavaScript. Модулі покликані стати єдиною заміною численним способам визначення модулів, що виникли останніми роками.\nДопомога та підтримка\nВи можете написати про помилку, порадити зміни та відкрити pull requests до цієї книги завітавши сюди:\n\nhttps://github.com/denysdovhan/understandinges6ua (Переклад)\nhttps://github.com/nzakas/understandinges6 (Оригінал)\n\nСтосовно будь-чого іншого, будь-ласка надсилайте повідомлення сюди: http://groups.google.com/group/zakasbooks.\n"},"manuscript/01-Block-Bindings.html":{"url":"manuscript/01-Block-Bindings.html","title":"Блочне зв’язування","body":"Блочне зв&#39;язування\nТак склалось, що одна із найхитріших частин програмування на JavaScript - спосіб, яким оголошуються змінні. У більшості С-подібних мов змінні (або їх зв&#39;язування) створюються там, де їх оголошують. Проте в JavaScript це не зовсім так. Місце створення ваших змінних залежить від того, як ви їх оголосили і ECMAScript 6 надає вам простіший спосіб контролювати область видимості. Ця глава ілюструє чому класичне var оголошення може заплутати, вводить блочне зв&#39;язування в ECMAScript 6, а тоді пропонує деякі рекомендації для їх використання.\nvar-оголошення та виринання\nВикористовуючи var оголошення, змінна переміщується на початок функції (або в глобальну область видимості, якщо оголошення відбулось поза функцією) незалежно від того, де воно відбулось насправді - це називається виринання. Щоб продемонструвати цю поведінку, розглянемо наступну функцію:\nfunction getValue(condition) {\n\n    if (condition) {\n        var value = &quot;blue&quot;;\n\n        // інший код\n\n        return value;\n    } else {\n\n        // тут змінна value буде існувати зі значенням undefined\n\n        return null;\n    }\n\n    // тут змінна value буде існувати зі значенням undefined\n}\n\nЯкщо ви не знайомі з JavaScript, скоріш за все ви очікуєте, що змінна value буде створена тільки тоді, коли condition буде дорівнювати true. Насправді value буде створена незалежно від цього. Під капотом рушій JavaScript змінює функцію getValue таким чином, що вона виглядає так:\nfunction getValue(condition) {\n\n    var value;\n\n    if (condition) {\n        value = &quot;blue&quot;;\n\n        // інший код тут\n\n        return value;\n    } else {\n\n        return null;\n    }\n}\n\nЗмінна value виринає вгорі блоку і в тому ж місці відбувається ініціалізація. Це означає, що змінна value все ще доступна в блоці else. Проте, якщо звернутись до неї, отримаємо undefined, тому що вона ще не проініціалізована.\nЧасто новачкам у JavaScript розробці важко звикнути до того як працює оголошення змінних, і нерозуміння цієї неочевидної поведінки може призвести до помилок. З цієї причини, ECMAScript 6 вводить блочну область видимості, щоб забезпечити більш гнучкий контроль над життєвим циклом змінних.\nБлочне оголошення\nБлочним називають оголошення, в якому змінні не доступні поза поточною блочною областю видимості. Блочна область видимості виникає:\n\nвсередині функції;\nвсередині блоків (між символами { та } ).\n\nБагато C-подібних мов програмування працюють за принципом блочної області видимості, тому введення її в ECMAScript 6 надає таку ж гнучкість (і однорідність) в JavaScript.\nLet-оголошення\nСинтаксис let оголошення нічим не відрізняється від var. Ви можете просто замінити var на let, проте тим самим ви обмежите область видимості змінної блоком, в якому вона оголошена (крім того є ще декілька важливих відмінностей, про які ми поговоримо згодом). Так як з let оголошенням змінна не буде доступна поза блоком, в якому вона оголошена, вам буде потрібно здійснювати let оголошення на початку блоку, щоб вона була доступна також у внутрішніх блоках. Наприклад:\nfunction getValue(condition) {\n\n    if (condition) {\n        let value = &quot;blue&quot;;\n\n        // інший код\n\n        return value;\n    } else {\n\n        // value doesn&#39;t exist here\n\n        return null;\n    }\n\n    // value doesn&#39;t exist here\n}\n\nПоведінка цієї версії функції getValue більше схожа на те, що ви очікуєте від інших C-подібних мов програмування. Оскільки змінна value оголошена, використовуючи let, а не var, оголошення не виринає на початку визначення функції, і змінна value буде знищена після того, як виконається блок if. Якщо ж condition буде false, value ніколи не буде оголошена або проініціалізована.\nЖодного перевизначення\nЯкщо ідентифікатор змінної вже визначений в поточній області видимості, то let оголошення, використовуючи цей ідентифікатор, викликає помилку. Для прикладу:\nvar count = 30;\n\n// Помилка синтаксису\nlet count = 40;\n\nВ цьому прикладі count визначена двічі: одного разу із var, іншого - використовуючи let. Оскільки let не перевизначає ідентифікатори, які вже визначені в даній області видимості, оголошення викликає помилку. Натомість ніякої помилки не буде, якщо let оголошення створить нову змінну в області видимості з таким самим ім’ям, як і в змінної, яка знаходиться в області видимості, яке міститься в попередньому, що й ілюструє наступний код:  \nvar count = 30;\n\n// Не викличе помилку\nif (condition) {\n\n    let count = 40;\n\n    // more code\n}\n\nЦе let оголошення не викличе помилку, тому що воно створить нову змінну count лише у if виразі, а не в навколишньому блоці. В середині if блоку нова змінна перекриває глобальну count, запобігаючи доступу до неї, допоки виконання не покине блок.\nconst-оголошення\nІнший спосіб визначення змінних в ECMAScript 6 - використовувати синтаксис оголошення const. Змінні, оголошені використовуючи const, вважаються константами, тобто вони не можуть бути змінені присвоєнням нового значення. Тому кожна const змінна повинна бути проініціалізована і оголошена так, як це показано в прикладі:\n// Правильна константа\nconst maxItems = 30;\n\n// Помилка синтаксису: відсутня ініціалізація\nconst name;\n\nЗмінна maxItems проініціалізована, тому const оголошення має працювати без проблем. Натомість змінна name спричинить помилку синтаксису, якщо ви спробуєте запустити програму, яка містить цей код, тому що вона не проініціалізована.\nconst-оголошення проти let-оголошення\nОголошення константи, так як і let оголошення є блочними оголошеннями. Це означає, що константи будуть знищенні відразу ж, як виконання покине блок, в якому вони оголошені, також не буде виринання, що і показано в прикладі:\nif (condition) {\n    const maxItems = 5;\n\n    // ще якийсь код\n}\n\n// maxItems тут не доступня\n\nВ цьому коді константа maxItems оголошена в if виразі. Коли виконання виразу закінчиться, maxItems буде видалена і не буде доступна поза блоком.\nІнша подібність let та const - оголошення викличе помилку, якщо використати для оголошення ідентифікатор змінної, яка вже оголошена в цій області видимості. І не важливо чи змінна була оголошена використовуючи var (для глобальної або для області видимості на рівні функції) чи let (для області видимості на рівні блоку). Для прикладу, розглянемо цей код:\nvar message = &quot;Hello!&quot;;\nlet age = 25;\n\n// Оголошення кожної із цих змінних викличе помилку\nconst message = &quot;Goodbye!&quot;;\nconst age = 30;\n\nКожне із const оголошень буде валідним, проте враховуючи попередні var та let оголошення, жодне не буде працювати так, як передбачалось.\nНезважаючи на ці подібності, є одна велика відмінність між let та const, яку потрібно пам&#39;ятати. Спроба призначити const-змінну іншій вже визначеній константі викличе помилку як в strict, так і в non-strict режимі.\nconst maxItems = 5;\n\nmaxItems = 6;      // викличе помилку\n\nТак як і константи в інших мовах, змінній maxItems не можна призначити нове значення пізніше. Проте, на відміну від констант в інших мовах, значення може бути видозмінене, якщо це об&#39;єкт.\nОголошення об&#39;єктів з const\nОголошення з const запобігає видозміні зв&#39;язку, а не самого значення. Це означає, що const визначення об&#39;єктів не запобігає їх модифікації. Наприклад:\nconst person = {\n    name: &quot;Nicholas&quot;\n};\n\n// працює\nperson.name = &quot;Greg&quot;;\n\n// викличе помилку\nperson = {\n    name: &quot;Greg&quot;\n};\n\nТут посилання person створюється з початковим значенням об&#39;єкта із однією властивістю. Зміна person.name не викличе помилку, тому що змінюється значення person, а не те, на що person посилається. Коли цей код спробує призначити нове значення (намагаючись змінити посилання), буде викликана помилка. Дуже просто заплутатись в тонкощах того, як const працює із об&#39;єктами. Просто запам&#39;ятайте: const запобігає видозміні посилання, а не його значення.\nW&gt; В деяких браузерах реалізована попередня  перед ECMAScript 6 версія const, тому зважайте на це, використовуючи цей вид визначення. Реалізації варіюються від простого синоніму var (дозволяючи перевизначення значення), до визначення констант насправді, але тільки в глобальній та області визначення на рівні функції. Тому будьте  особливо обережні, використовуючи const в продакшині. Функціональності, яку ви очікуєте, може не бути.\nТимчасова мертва зона\nНа відміну від var, let та const не мають виринаючої характеристики.  До змінних оголошених раніше, не можна звернутись доти, доки вони не визначені знову.  Спроба зробити це спричинить помилку посилання, навіть якщо використовувати таку звичну та безпечну операцію як typeof:\nif (condition) {\n    console.log(typeof value);  // Помилка посилання!\n    let value = &quot;blue&quot;;\n}\n\nТут змінна value визначена та ініціалізована, використовуючи let, проте вираз ніколи не буде виконаний, оскільки попередній рядок призведе до помилки. Проблема в тому, що value існує в області, відомій JavaScript спільноті як тимчасова мертва зона (ТМЗ). ТМЗ ніколи не згадується безпосередньо в специфікації, проте це термін, який часто вживається, щоб описати неспливаючу поведінку let та const. Цей розділ  розповідає про деякі тонкощі визначення в місцях, які є ТМЗ, і хоча всі приклади використовують let, те саме рівноцінно також для const.\nКоли JavaScript рушій переглядає блок, який буде виконуватись і знаходить визначення змінних, він їх або змушує «спливти» (якщо це var), або переміщує в ТМЗ (якщо це let або const). Всі спроби звернутись до змінної, яка знаходиться в ТМЗ спровокують помилку виконання. Змінна буде видалена з ТМЗ, а також буде можна її використовувати лише тоді, коли виконання дійде до визначення змінної.\nЦе справджується кожного разу, коли ви намагаєтесь використати змінну визначену з let перш ніж вона була визначена, навіть використовуючи звичний і безпечний оператор typeof. Проте ви можете використовувати typeof зі змінними поза блоком, в якому вони визначені, хоч це може не дати результату. Розглянемо цей код:\nconsole.log(typeof value);     // &quot;undefined&quot;\n\nif (condition) {\n    let value = &quot;blue&quot;;\n}\n\nЗмінної value немає в ТМЗ, коли виконується оператор typeof, тому що це відбувається поза блоком в якому value визначена. Це означає, що ще немає посилання на value, і typeof просто повертає &quot;undefined&quot;.\nТМЗ - всього лише один унікальний аспект блочного зв&#39;язування. Іншим аспектом є використання в середині циклів.\nБлочне зв&#39;язування в середині циклів\nМожливо, випадок, коли розробникам найбільше потрібна блочна область видимості для змінних - цикли for, де оголошена змінна лічильника має використовуватись тільки в середині циклу. Наприклад, цей код - цілком звичний в JavaScript:\nfor (var i=0; i &lt; 10; i++) {\n    process(items[i]);\n}\n\n// змінна i досі доступна\nconsole.log(i);                     // 10\n\nВ інших мовах, де блочна область видимості за замовчуванням, код цього типу працює як і планувалось, і тільки цикл for має доступ до змінної i. В JavaScript змінна i досі доступна після того, як цикл завершиться, через виринаючий характер var. Натомість використання let як в коді наведеному нижче, дозволить вам отримати очікувану поведінку:\nfor (let i=0; i &lt; 10; i++) {\n    process(items[i]);\n}\n\n// змінна i тут недоступна, тому буде викликана помилка\nconsole.log(i);\n\nУ цьому прикладі змінна i тільки існує всередині циклу for. Як тільки цикл закінчить своє виконання, змінна буде знищена та стане недоступною деінде.\nФункції в циклах\nТак склалось, що через властивості var, створення функцій всередині циклів було проблемою через доступність змінних циклу поза областю його видимості. Розглянемо наступний код:\nvar funcs = [];\n\nfor (var i=0; i &lt; 10; i++) {\n    funcs.push(function() { console.log(i); });\n}\n\nfuncs.forEach(function(func) {\n    func();     // виводить число &quot;10&quot; десять разів\n});\n\nВи, мабуть, очікуєте, що цей код виведе числа від 0 до 9, проте він виводить число 10 десять разів підряд. Все тому що змінна i спільна для кожної ітерацій циклу, тобто функції, які створюються всередині циклу, беруть посилання на ту ж змінну. Коли цикл закінчиться, значення змінної i буде рівне 10, тому коли виконується console.log(i), це і є значенням, яке виводиться кожного разу.\nЩоб вирішити цю проблему, розробники використовують негайно виконуваний функціональний вираз (НВФВ) (immediately-invoked function expression (IIFE)) всередині циклів, щоб вимушено створити нову копію змінної, яку вони хочуть використовувати в ітерації, тобто як в коді нижче:\nvar funcs = [];\n\nfor (var i=0; i &lt; 10; i++) {\n    funcs.push((function(value) {\n        return function() {\n            console.log(value);\n        }\n    }(i)));\n}\n\nfuncs.forEach(function(func) {\n    func();     // виводить 0, тоді 1, тоді 2, і так до 9\n});\n\nТут, в середині циклу, використовується НВФВ. Змінна i передається до НВФВ, який створює власну копію і зберігає її як value. Це значення змінної, яке використовується функцією для цієї ітерації, тому викликаючи кожну функцію, ми отримуємо значення лічильника циклу - від 0 до 9. На щастя, блочна область видимості з let та const можуть спростити цей цикл для вас.\nlet-оголошення в циклах\nТип оголошення з let спрощує цикли, фактично виконуючи те, що НВФВ робили в попередньому прикладі. Кожної ітерації цикл створює нову змінну та ініціалізує її зі значенням змінної з таким самим ім&#39;ям в попередній ітерації. Це означає, що ви можете не використовувати НВФВ і отримати очікуваний результат, як цей:\nvar funcs = [];\n\nfor (let i=0; i &lt; 10; i++) {\n    funcs.push(function() {\n        console.log(i);\n    });\n}\n\nfuncs.forEach(function(func) {\n    func();     // виводить 0, тоді 1, тоді 2, і так до 9\n})\n\nЦей код працює так само, як код, який використовує var та НВФВ, проте, можливо, він більш зрозумілий. Оголошення із let створює нову змінну кожного разу впродовж циклу, тому кожна функція створена в циклі отримує власну копію i. Кожна копія i має значення, яке було призначене на початку ітерації циклу, в якому вона була створена. Теж саме підійде також для for-in та for-of циклів, як це показано тут:\nvar funcs = [],\n    object = {\n        a: true,\n        b: true,\n        c: true\n    };\n\nfor (let key in object) {\n    funcs.push(function() {\n        console.log(key);\n    });\n}\n\nfuncs.forEach(function(func) {\n    func();     // виводить &quot;a&quot;, тоді &quot;b&quot; і тоді &quot;c&quot;\n});\n\nВ цьому прикладі цикл for-in відтворює таку ж поведінку, як і в цикл for. Кожного разу впродовж циклу створюється нове посилання key, тому кожна функція має власну копію змінної key. Як результат кожна функцію виводить інше значення. Якщо б ми використовували var для визначення key, кожна функція виводила б &quot;c&quot;.\n|&gt; Важливо розуміти, що поведінка let визначення в циклах спеціально визначена в специфікації, і не пов&#39;язана з невиринаючою властивістю let. Насправді ж ранні реалізації let не мали цієї поведінки - це було додано пізніше в процесі створення специфікації.\nОголошення констант в циклах\nФактично специфікація ECMAScript 6 не забороняє const визначення в циклах; проте поведінка залежить від циклу, який ви використовуєте. Для звичного циклу for ви можете використовувати const в ініціалізації, але цикл виведе попередження, якщо ви спробуєте змінити значення. Наприклад:\nvar funcs = [];\n\n// виведе помилку після першої ітерації\n\nfor (const i=0; i &lt; 10; i++) {\n    funcs.push(function() {\n        console.log(i);\n    });\n}\n\nВ цьому коді змінна i визначена як константа. Перша ітерація циклу, де i рівне 0, виконається успішно. Помилку викличе виконання i++, так як це спроба змінити константу. Тому ви можете використовувати const для того, щоб визначати змінні в ініціалізації циклу тільки якщо ви не будете їх змінювати.\nЗ іншого боку, використовуючи const змінну в циклах for-in та fon-of, поведінка буде така ж, як і let змінної. Тому наступний код помилки не викличе:\nvar funcs = [],\n    object = {\n        a: true,\n        b: true,\n        c: true\n    };\n\n// не виведе помилку\nfor (const key in object) {\n    funcs.push(function() {\n        console.log(key);\n    });\n}\n\nfuncs.forEach(function(func) {\n    func();     // виведе &quot;a&quot;, тоді &quot;b&quot; і тоді &quot;c&quot;\n});\n\nЦей код практично такий самий, як і в другому прикладі в розділу «let оголошення в циклах». Єдиною відмінністю є те, що значення key неможливо змінити всередині циклу. Цикли for-in та for-of працюють із const, тому що ініціалізатор циклу створює нове посилання при кожній ітерації, а не намагається змінити значення за посиланням, яке вже існує (як це відбувалось в попередньому прикладі, використовуючи for, а не fon-in).\nГлобальне блочне зв&#39;язування\nІншою відмінністю let та const від var є поведінка в глобальній області видимості. Коли створюють нову глобальну змінну використовуючи var, створюється глобальна змінна, яка є полем глобального об&#39;єкту (windows браузерах). Це означає, що ви можете випадково перезаписати існуючу глобальну змінну, використовуючи var, так як відбувається тут:\n// в браузері\nvar RegExp = &quot;Hello!&quot;;\nconsole.log(window.RegExp);     // &quot;Hello!&quot;\n\nvar ncz = &quot;Hi!&quot;;\nconsole.log(window.ncz);        // &quot;Hi!&quot;\n\nХоча глобальний RegExp визначений в window, його можна перезаписати, використовуючи var оголошення. Цей приклад оголошує нову глобальну змінну RegExp, яка перезаписує оригінал. Так само як і ncz визначений як глобальна змінна і відразу ж визначається як поле об&#39;єкта windows. Так JavaScript працював завжди.\nПроте якщо ви будете використовувати let та const в глобальній області видимості, будуть створені нові глобальні посилання на змінні без додавання їх як поля глобального об&#39;єкту. Це також означає, що ви не зможете перезаписати глобальну змінну, використовуючи let та const, а тільки перекрити їх. Наприклад:\n// в браузері\nlet RegExp = &quot;Hello!&quot;;\nconsole.log(RegExp);                    // &quot;Hello!&quot;\nconsole.log(window.RegExp === RegExp);  // false\n\nconst ncz = &quot;Hi!&quot;;\nconsole.log(ncz);                       // &quot;Hi!&quot;\nconsole.log(&quot;ncz&quot; in window);           // false\n\nВ цьому коді нове let оголошення  для RegExp створює нове посилання, яке перекриває глобальну RegExp. Тобто windows.RegExp та RegExp - не одне і те ж, тому немає ніяких збоїв у глобальній області видимості. Також const оголошення nzt створює нове посилання, але не створює нове поле в глобальному об&#39;єкті. Ця особливість робить let та const набагато безпечнішими для використання в глобальній області видимості, якщо ви не хочете створювати поле в глобальному об&#39;єкті.\n|&gt; Ви як і раніше можете використовувати var для оголошення змінних в глобальній області видимості, якщо ваш код має бути доступний через глобальний об&#39;єкт. Це може бути необхідним в браузерах, коли вам потрібний доступ до коду із іншого вікна чи фрейму.\nРекомендаці щодо блочного зв&#39;язування\nДопоки ECMAScript 6 був у розробці, була розповсюджена думка про те, що для оголошення змінних потрібно використовувати let за замовчуванням, а не var для оголошення змінних. Для багатьох JavaScript розробників поведінка let є саме такою, якою мала би бути поведінка var, тому пряме заміщення є логічним. У цьому випадку ви використовуватимете const тільки для змінних, які не повинні змінюватись.\nОднак, що більше розробників мігрувало на ECMAScript 6, то більшу популярність набрав альтернативний підхід: використовувати const за замовчуванням, а let тільки тоді, коли ви знаєте, що значення змінної потрібно буде змінити. Основною причиною для цього є те, що змінна не повинна змінюватись після ініціалізації, тому що несподівані зміни значення є джерелом помилок. Цей підхід набрав популярність, проте варто вивчити ваш код, щоб зрозуміти як пишите код на ECMAScript 6 ви.\nПідсумок\nБлочне зв&#39;язування, з використанням let та const, принесло лексичну область видимості в JavaScript. Ці оголошення не виринають та існують тільки всередині блоку, в якому вони були визначені. Крім того, блочне зв&#39;язування ECMAScript 2015 надає поведінку, яка є більш схожою на поведінку змінних в інших мовах, тим самим оберігає від випадкових помилок, тому що змінні можуть бути визначенні саме там, де вони необхідні. Побічним ефектом є те, що ви не можете звернутись до змінної, перш ніж вона була оголошена, навіть із безпечними операторами, такими як typeof. Спроба це зробити спровокує помилку у зв&#39;язку із необхідністю наявності зв&#39;язаного посилання в тимчасовій мертвій зоні (ТМЗ).\nВ більшості випадків поведінка lеt та const схожа до поведінки var, однак в циклах це не так. Для let та const цикли for-in та for-of створюють нове посилання для кожної ітерації впродовж циклу. Це означає, що функції створенні в тілі циклу можуть звернутись до значення, яке зв&#39;язане з ним впродовж поточної ітерації, а не навіть після закінчення останньої ітерації (поведінка var). Це ж вірно і для let оголошень у циклах for, в той час як спроба використання const визначення для циклу for спричинить помилку.\nПоточною рекомендацією для блочного зв&#39;язування є використання const в усіх випадках, окрім тих, коли ви знаєте, що повинні змінити значення змінної, тоді використовуйте let. Цим ви забезпечуєте початковий рівень імутабельності в коді, який може запобігти виникненню деяких видів помилок.\n"},"manuscript/02-Strings-and-Regular-Expressions.html":{"url":"manuscript/02-Strings-and-Regular-Expressions.html","title":"Рядки та регулярні вирази","body":"Рядки та регулярні вирази\nРядки, можливо, є найбільш важливими типами даних в програмуванні. Вони є майже у всіх високорівневих мовах програмування, а вміння працювати з ними ефективно є необхідністю для розробника, при створенні корисних програм. Втім, будучи відвертими, регулярні вирази є не менш важливими, тому що вони дають розробнику додаткові потужні можливості при роботі з рядками. Зважаючи на це, розробники ECMAScript 6 вдосконалили рядки і регулярні вирази, додавши нові можливості та довгоочікуваний функціонал. Ця глава розгляне зміни в обох типах.\nКраща підтримка Unicode\nДо появи ECMAScript 6, рядки в JavaScript базувались на 16-бітній системі кодування символів. Усі властивості і методи рядків, як, наприклад, властивість length та метод charAt(), базувалися на ідеї, що 16-бітна послідовність представляє єдиній символ. ECMAScript 5 дозволяв JavaScript інтерпретаторам обирати поміж двома варіантами кодування: UCS-2 або UTF-16. (Обидві системи використовують послідовності 16-бітових кодових слів (code unites), однаково обробляючи усі відстежуванні операції.) Але вважалося що для кодування символів не потрібно більше ніж 16 біт, на щастя це більше не є абсолютом, дякуючи введенню розширеного набору символів Unicode.\nКодування UTF-16\nОбмеження довжини кодування символів до 16 біт не дає можливості реалізувати основну мету Unicode: надання глобального унікального ідентифікатора кожному символу у світі. Ці глобальні унікальні ідентифікатори, так звані коди (code point), просто номери, які починаються з 0.\nКоди UTF-16 схожі на коди символів, але між ними існує невелика різниця. Кодування символів перекладає коди в кодові слова, які внутрішньо несуперечливі. В той час як UCS-2 зв’язує коди з кодовими словами у співвідношенні один до одного, зв’язування в UTF-16 відбувається не завжди один до одного.\nПерші 2^16 кодів в UTF-16 представлені як одиничні 16-бітні кодові слова. Цей діапазон називається Основна Багатомовна Матриця (ОБМ). Все, що поза межами цього діапазону вважається додатковою матрицею, де кодові слова вже не можуть бути представлені лише у 16 бітах. UTF-16 вирішує цю проблему за допомогою сурогатних пар, в яких один код представлений двома 16-бітними кодовими словами. Це означає, що будь який символ у рядку може бути представлений як одним кодовим словом для ОБМ символів, даючи в сумі 16 біт, так і двома кодовими словами для символів додаткової матриці, даючи в сумі 32 біти.\nУ ECMAScript 5, всі рядкові операції працюють в діапазоні 16-бітових кодових слів, тому, можна припустити, що ви отримаєте неочікувані результати у рядку кодованому в UTF-16, який містить сурогатні пари. Наприклад:\nvar text = &quot;𠮷&quot;;\n\nconsole.log(text.length);           // 2\nconsole.log(/^.$/.test(text));      // false\nconsole.log(text.charAt(0));        // &quot;&quot;\nconsole.log(text.charAt(1));        // &quot;&quot;\nconsole.log(text.charCodeAt(0));    // 55362\nconsole.log(text.charCodeAt(1));    // 57271\n\nУ цьому прикладі, єдиний Unicode символ представлений сурогатною парою, тому JavaScript операції з рядком відбуваються, як з таким, що має два 16-бітні символи. Це означає:\n\nвластивість length змінної text буде 2;\nрегулярний вираз, який спробує знайти одиничний символ, дасть false;\nметод charAt() не в змозі повернути рядок;\n\nМетод charCodeAt() повертає відповідний 16-бітний номер для кожного кодового слова, але це тільки наближене до реального значення, яке ви можете отримати в ECMAScript 5.\nECMAScript 6 забезпечує повну підтримку кодування рядків в UTF-16. Стандартизація операцій з рядками, які базуються на цьому кодуванні, означає що JavaScript може підтримувати функціонал розроблений спеціально для роботи з сурогатними парами. Решта цього розділу розглядає кілька ключових прикладів цієї функціональності.\nМетод codePointAt()\nОдним з методів доданих в ECMAScript 6 для повної підтримки UTF-16 є метод codePointAt(), який отримує коди Unicode, які пов’язані з відповідною позицією у рядку. Цей метод отримує позицію коду замість позиції символу та повертає числове значення, як показує цей приклад console.log():\nvar text = &quot;𠮷a&quot;;\n\nconsole.log(text.charCodeAt(0));    // 55362\nconsole.log(text.charCodeAt(1));    // 57271\nconsole.log(text.charCodeAt(2));    // 97\n\nconsole.log(text.codePointAt(0));   // 134071\nconsole.log(text.codePointAt(1));   // 57271\nconsole.log(text.codePointAt(2));   // 97\n\nМетод codePointAt() повертає те саме значення, що й метод charCodeAt() за винятком того, що він оперує також не-ОБМ символами. Перший символ змінної text є не-ОБМ символом і він представлений двома кодовими словами; таким чином рядок має довжину трьох символів замість двох. Метод charCodeAt() повертає тільки перше кодове слово для позиції 0, але codePointAt() повертає повний код незважаючи на те, що він містить два кодові слова. Обидва методи повертають таке саме значення для позиції 1 (другий кодовий блок для першого символу) та 2 (символ &quot;a&quot;).\nВиклик методу codePointAt() для символу є найпростішим способом дізнатися складається символ з одного або двох кодових слів. Ось функція, яку ви можете написати для перевірки:\nfunction is32Bit(c) {\n    return c.codePointAt(0) &gt; 0xFFFF;\n}\n\nconsole.log(is32Bit(&quot;𠮷&quot;));         // true\nconsole.log(is32Bit(&quot;a&quot;));          // false\n\nВерхня межа 16-бітових символів представлених в шістнадцятковому вигляді є FFFF, тому будь-який код більший ніж це число має бути представлений двома кодовими словами, в цілому 32 біта.\nМетод String.fromCodePoint()\nТоді як ECMAScript надає можливість щось роботи, він також впроваджує спосіб роботи те саме у зворотному порядку. Ви можете використати codePointAt() щоб визначити код для символу в рядку, в той час як String.fromCodePoint() дає значення символу у рядку відповідно до коду. Наприклад:\nconsole.log(String.fromCodePoint(134071));  // &quot;𠮷&quot;\n\nСлід вважати, що String.fromCodePoint() — вдосконалена версія String.fromCharCode(). Обидва дають ті самі результати для символів в межах ОБМ. Різницю ви зможете помітити лише якщо будете працювати з символами за межами ОБМ.\nМетод normalize()\nІншим цікавим аспектом Unicode є те, що різні символи можуть вважатися еквівалентними для сортування або інших операцій, що базуються на порівнянні. Є два шляхи визначення цих зв’язків. Перший, канонічна рівність має на увазі, що дві послідовності кодових слів є взаємозамінними у всіх відносинах. Наприклад, комбінація двох символів може бути канонічним еквівалентом одного символу. Друге співвідношення — сумісність. Дві сумісні послідовності кодових слів можуть здаватися різними, але бути взаємозамінними в певних ситуаціях.\nВідповідно до цих зв’язків рядки, які виводять з одного боку той самий текст, можуть мати різну послідовність кодових слів. Наприклад символ &quot;æ&quot; та рядок с двох символів &quot;ae&quot; можуть використовуватись однаково, але не бути повністю еквівалентними, поки їх певним чином не нормалізувати.\nECMAScript 6 підтримує нормалізацію форм Unicode, передаючи рядку метод normalize(). Цей метод опціонально приймає один параметр у вигляді рядка, який має містити одну з наступних форм Unicode нормалізації для подальшого використання:\n\n&quot;NFC&quot; (Normalization Form Canonical Composition) — форма нормалізації «Канонічна Композиція»; використовується за замовчуванням\n&quot;NFD&quot; (Normalization Form Canonical Decomposition) — форма нормалізації «Канонічна Декомпозиція»;\n&quot;NFKC&quot; (Normalization Form Compatibility Composition) — форма нормалізації «Сумісна Композиція»;\n&quot;NFKD&quot; (Normalization Form Compatibility Decomposition) — форма нормалізації «Сумісна Декомпозиція».\n\nПояснення відмінностей між цими чотирма формами виходить за межі цієї книги. Тільки майте на увазі, що коли порівнюєте рядки, обидва мають бути нормалізовані до однієї форми. Наприклад:\nvar normalized = values.map(function(text) {\n    return text.normalize();\n});\n\nnormalized.sort(function(first, second) {\n    if (first &lt; second) {\n        return -1;\n    } else if (first === second) {\n        return 0;\n    } else {\n        return 1;\n    }\n});\n\nЦей код конвертує рядки в масив values у нормалізованій формі, таким чином масив може бути правильно відсортований. Ви також можете відсортувати оригінальний масив, використовуючи метод normalize() як частину умови, наприклад:\nvalues.sort(function(first, second) {\n    var firstNormalized = first.normalize(),\n        secondNormalized = second.normalize();\n\n    if (firstNormalized &lt; secondNormalized) {\n        return -1;\n    } else if (firstNormalized === secondNormalized) {\n        return 0;\n    } else {\n        return 1;\n    }\n});\n\nПовторимо ще раз, що найважливішим в цьому коді є те, що обидва аргументи, first та second, будуть нормалізовані однаковим чином. Ці приклади використовують форму нормалізації за замовчуванням, NFC, але ви можете легко визначити іншу, наприклад:\nvalues.sort(function(first, second) {\n    var firstNormalized = first.normalize(&quot;NFD&quot;),\n        secondNormalized = second.normalize(&quot;NFD&quot;);\n\n    if (firstNormalized &lt; secondNormalized) {\n        return -1;\n    } else if (firstNormalized === secondNormalized) {\n        return 0;\n    } else {\n        return 1;\n    }\n});\n\nЯкщо ви не турбувалися про нормалізацію Unicode раніше тоді, напевно, цей метод не буде мати особливого значення. Але якщо ви колись будете працювати з кодом для інтернаціональних програм, метод normalize() стане вам у нагоді.\nМетоди — не єдині покращення, які ECMAScript 6 впроваджує для роботи з рядками Unicode. Стандарт також пропонує два нові елементи синтаксису.\nОпція пошуку (flag) u в Регулярних Виразах\nЗа допомогою регулярних виразів ви можете виконати багато базових операцій з рядками. Але треба пам’ятати, що регулярні вирази використовують 16-бітові кодові слова, де кожен представляє один символ. Щоб зарадити цій проблемі, ECMAScript 6 вводить опцію пошуку u для регулярних виразів, які працюють з Unicode.\nЯкщо регулярний вираз має опцію u, то він переключається в стан роботи з символами, а не з кодовими словами. Це означає, що регулярний вираз вже, незалежно від сурогатних пар в рядку, буде поводитись як треба. Як приклад, розглянемо цей код:\nvar text = &quot;𠮷&quot;;\n\nconsole.log(text.length);           // 2\nconsole.log(/^.$/.test(text));      // false\nconsole.log(/^.$/u.test(text));     // true\n\nРегулярний вираз /^.$/ не знаходить жодного рядка, який би складався з одного символу. Використаний без опції u, цей регулярний вираз порівнює кодові слова, тому Японський символ (якій представлений двома кодовими словами) не відповідає регулярному виразу. Коли ж використовується опція u, регулярний вираз порівнює символи замість кодових слів і таким чином Японський символ відповідає виразу.\nНа жаль, ECMAScript 6 не може визначити скільки кодових пунктів містить рядок, але з визначеною опцією u, ви можете використати регулярний вираз, щоб реалізувати це таким чином:\nfunction codePointLength(text) {\n    var result = text.match(/[\\s\\S]/gu);\n    return result ? result.length : 0;\n}\n\nconsole.log(codePointLength(&quot;abc&quot;));    // 3\nconsole.log(codePointLength(&quot;𠮷bc&quot;));   // 3\n\nУ цьому прикладі використовується match(), щоб перевірити text на символи пробілів і не пробілів, за допомогою регулярного виразу, який застосовано глобально та з підтримкою Unicode. Результат містить масив збігів, якщо наявний хоча б один збіг, то довжина масиву буде числом кодів у рядку. В Unicode, рядки &quot;abc&quot; та &quot;𠮷bc&quot; мають три символи, тому довжина масиву буде три.\nW&gt; Даний підхід працює, але не дуже швидко, особливо коли його застосувати до довгих рядків. Тому намагайтеся зменшити підрахунок кодів, якщо це можливо. На щастя, ECMAScript 7 буде мати вбудований метод підрахунку кодів.\nОскільки опція u є синтаксичною зміною, спроби використання її в JavaScript інтерпретаторах, які не сумісні з ECMAScript 6 будуть провокувати синтаксичну помилку. Найнебезпечнішим шляхом встановити, чи підтримується опція u буде функція, на кшталт цієї:\nfunction hasRegExpU() {\n    try {\n        var pattern = new RegExp(&quot;.&quot;, &quot;u&quot;);\n        return true;\n    } catch (ex) {\n        return false;\n    }\n}\n\nЦя функція використовує конструктор RegExp, щоб передати опцію u як аргумент. Такий синтаксис підтримується навіть старими JavaScript інтерпретаторами, але конструктор буде видавати помилку, якщо u не підтримується.\nI&gt; Якщо потрібно, щоб ваш код працював зі старими JavaScript інтерпретаторами, завжди використовуйте конструктор RegExp з використанням опції u. Це попередить виникнення синтаксичних помилок і дозволить визначити чи підтримується опція uбез скасування виконання коду.\nІнші зміни для рядків\nФункціонал рядків JavaScript завжди відставав від аналогічного в інших мовах. Тільки в ECMAScript 5 рядки, нарешті, отримали метод trim(). ECMAScript 6 продовжує розвивати функціонал JavaScript для роботи з рядками.\nМетоди для визначення підрядків\nЗ того часу, коли JavaScript був вперше представлений, розробники використовували метод indexOf() щоб визначити рядок всередині рядка. ECMAScript 6 містить наступні три методи для реалізації цієї дії:\n\nМетод includes() повертає true, якщо даний тест знайдений деінде у рядку. Та повертає false, якщо ні.\nМетод startsWith() повертає true, якщо даний текст знайдено на початку рядка. Та повертає false, якщо ні.\nМетод endsWith() повертає true, якщо даний текст знайдено у кінці рядка. Та повертає false, якщо ні.\n\nКожен з цих методів приймає два аргументи: текст, який треба знайти, та необов&#39;язковий аргумент у вигляді індексу рядка з якого треба шукати. Коли надано другий аргумент, includes() та startsWith() починає пошук з вказаного індексу, в той час як endsWith() починає шукати з індексу, який рівний довжині рядка мінус вказаний аргумент; коли другий аргумент не надано, includes() та startsWith() шукають з початку рядка, в той час як endsWith() починає з кінця. Кажучи інакше, другий аргумент зменшує діапазон пошуку в рядку. Ось кілька прикладів цих методів в дії:\nvar msg = &quot;Hello world!&quot;;\n\nconsole.log(msg.startsWith(&quot;Hello&quot;));       // true\nconsole.log(msg.endsWith(&quot;!&quot;));             // true\nconsole.log(msg.includes(&quot;o&quot;));             // true\n\nconsole.log(msg.startsWith(&quot;o&quot;));           // false\nconsole.log(msg.endsWith(&quot;world!&quot;));        // true\nconsole.log(msg.includes(&quot;x&quot;));             // false\n\nconsole.log(msg.startsWith(&quot;o&quot;, 4));        // true\nconsole.log(msg.endsWith(&quot;o&quot;, 8));          // true\nconsole.log(msg.includes(&quot;o&quot;, 8));          // false\n\nВ перших трьох викликах другий аргумент не вказано, тож пошук ведеться по всій довжині рядка. Останні три виклики перевіряють лише частину рядка. Виклик msg.startsWith(&quot;o&quot;, 4) починає шукати з індексу 4 змінної msg (що є &quot;o&quot; в &quot;Hello&quot;); виклик msg.endsWith(&quot;o&quot;, 8) починає шукати з індексу 4, тому що аргумент 8 віднімаємо від довжини рядка (12); виклик msg.includes(&quot;o&quot;, 8) починає шукати з індексу 8 (що буде &quot;r&quot; в &quot;world&quot;).\nНе зважаючи на те, що ці методи роблять визначення підрядка у рядку легшим, кожен з них повертає лише булеве значення. Якщо вам потрібно знайти дійсну позицію підрядка в рядку, треба використовувати методи indexOf() або lastIndexOf().\nW&gt; Методи startsWith(), endsWith() та includes() будуть видавати помилку, якщо ви передасте регулярний вираз замість рядка в якості аргументу. На відміну від indexOf() та lastIndexOf(), які конвертують регулярний вираз в рядок а потім шукають цей рядок.\nМетод repeat()\nECMAScript 6 також додає до рядків метод repeat(), який в якості аргументу приймає число рівне кількості повторів рядка. Він повертає новий рядок, який містить оригінальний рядок повторений вказану кількість разів. Наприклад:\nconsole.log(&quot;x&quot;.repeat(3));         // &quot;xxx&quot;\nconsole.log(&quot;hello&quot;.repeat(2));     // &quot;hellohello&quot;\nconsole.log(&quot;abc&quot;.repeat(4));       // &quot;abcabcabcabc&quot;\n\nЦей метод надає важливий функціонал, який може бути надзвичайно корисним при маніпулюванні текстом. Це важливо в інструментах для форматування коду, наприклад:\n// відступ, використовуючи визначену кількість пробілів\nvar indent = &quot; &quot;.repeat(4),\n    indentLevel = 0;\n\n// кожного разу, коли ви збільшуєте відступ\nvar newIndent = indent.repeat(++indentLevel);\n\nПерший виклик repeat() створить рядок з чотирма пробілами, а змінна indentLevel буде записувати рівень відступів. Тепер ви можете просто викликати repeat() зі збільшеним indentLevel, щоб змінити кількість відступів.\nECMAScript 6 також надає деякі корисні зміни до регулярних виразів, які не можна виділити в окрему категорію. Наступний розділ розгляне деякі з них.\nІнші зміни у регулярних виразах\nРегулярні вирази важлива частина роботи з рядками в JavaScript, і як більша частина мови, вони не змінювались істотним чином у попередніх версіях. ECMAScript 6 пропонує деякі покрашення для регулярних виразів, принаймні, щоб йти поруч з рядками.\nОпція (flag) y для регулярних виразів\nECMAScript 6 зробив опцію y стандартом flag після того, як вона була запроваджена в Firefox в якості пропрієтароного доповнення для опрацювання регулярних виразів. Опція y стосується такої властивості регулярних виразів, як sticky, яка каже пошуку почати шукати відповідні символи в рядку з позиції, зазначеної у властивості lastIndex регулярного виразу. Якщо в цій позиції немає збігів, то регулярний вираз зупиняє пошук відповідностей. Щоб побачити, як це працює, розглянемо наступний код:\nvar text = &quot;hello1 hello2 hello3&quot;,\n    pattern = /hello\\d\\s?/,\n    result = pattern.exec(text),\n    globalPattern = /hello\\d\\s?/g,\n    globalResult = globalPattern.exec(text),\n    stickyPattern = /hello\\d\\s?/y,\n    stickyResult = stickyPattern.exec(text);\n\nconsole.log(result[0]);         // &quot;hello1 &quot;\nconsole.log(globalResult[0]);   // &quot;hello1 &quot;\nconsole.log(stickyResult[0]);   // &quot;hello1 &quot;\n\npattern.lastIndex = 1;\nglobalPattern.lastIndex = 1;\nstickyPattern.lastIndex = 1;\n\nresult = pattern.exec(text);\nglobalResult = globalPattern.exec(text);\nstickyResult = stickyPattern.exec(text);\n\nconsole.log(result[0]);         // &quot;hello1 &quot;\nconsole.log(globalResult[0]);   // &quot;hello2 &quot;\nconsole.log(stickyResult[0]);   // Error! stickyResult is null\n\nЦей приклад має три регулярні вирази. Вираз в pattern немає опцій, другий в globalPattern використовує опцію g, останній stickyPattern використовує опцію y. У перших трьох викликах console.log(), усі три регулярні вирази мають повернути &quot;hello1 &quot; (з пробілом у кінці).\nПісля цього властивість lastIndex було змінено на 1 у всіх трьох шаблонах, маючи на увазі, що регулярний вираз повинен шукати збіги з другого символу у всіх випадках. Регулярний вираз без опцій повністю ігнорує зміни у lastIndex та все ще повертає &quot;hello1 &quot; без проблем. Регулярний вираз з опцією g повертає збіг з &quot;hello2 &quot;, тому що він починає пошук з другого символу рядка (&quot;e&quot;). Регулярний вираз з опцією y не знаходить жодних збігів, починаючи з другого символу рядка, тому stickyResult є null.\nОпція y зберігає індекс наступного символу після останнього в lastIndex під час виконання операції. Якщо в результаті операції немає збігів, тоді lastIndex повертається до 0. Опція g поводиться таким чином, як показано тут:\nvar text = &quot;hello1 hello2 hello3&quot;,\n    pattern = /hello\\d\\s?/,\n    result = pattern.exec(text),\n    globalPattern = /hello\\d\\s?/g,\n    globalResult = globalPattern.exec(text),\n    stickyPattern = /hello\\d\\s?/y,\n    stickyResult = stickyPattern.exec(text);\n\nconsole.log(result[0]);         // &quot;hello1 &quot;\nconsole.log(globalResult[0]);   // &quot;hello1 &quot;\nconsole.log(stickyResult[0]);   // &quot;hello1 &quot;\n\nconsole.log(pattern.lastIndex);         // 0\nconsole.log(globalPattern.lastIndex);   // 7\nconsole.log(stickyPattern.lastIndex);   // 7\n\nresult = pattern.exec(text);\nglobalResult = globalPattern.exec(text);\nstickyResult = stickyPattern.exec(text);\n\nconsole.log(result[0]);         // &quot;hello1 &quot;\nconsole.log(globalResult[0]);   // &quot;hello2 &quot;\nconsole.log(stickyResult[0]);   // &quot;hello2 &quot;\n\nconsole.log(pattern.lastIndex);         // 0\nconsole.log(globalPattern.lastIndex);   // 14\nconsole.log(stickyPattern.lastIndex);   // 14\n\nЗначення lastIndex змінюється на 7 після першого виклику exec() та на 14 після другого виклику, як для змінної stickyPattern так і для globalPattern.\nЄ дві важливі деталі, які треба мати на увазі стосовно опціі y:\n\nВластивість lastIndex буде враховуватися тільки при використанні з методами, які існують для регулярних виразів, на кшталт exec() або test(). Передавання регулярного виразу до рядкового методу, як match(), не поверне результату.\nКоли ми використовуємо символ ^ щоб почати пошук з початку рядка, регулярний вираз з опцією y шукає збіги тільки з початку рядка (або початку лінії в багатолінійному коді). Якщо lastIndex є 0, символ ^ робить регулярний вираз таким самим як і загального типу. Якщо lastIndex не відповідає початку рядка або початку рядка в багаторядковому режимі, регулярний вираз з опцією y ніколи не поверне збіг.\n\nТак само як і з іншими опціями регулярних виразів, ви можете визначити наявність опції y, використовуючи властивість sticky. В цьому разі ви маєте перевірити наявність властивості sticky, як показано у коді:\nvar pattern = /hello\\d/y;\n\nconsole.log(pattern.sticky);    // true\n\nПеревірка на властивість sticky буде повертати true, якщо опція y наявна у виразі, та false, якщо ні. Властивість sticky є доступною тільки для читання і не може буди зміненою в коді.\nТак само як опція u, опція y є синтаксичною зміною, тому вона буде викликати синтаксичну помилку у старих інтерпретаторах JavaScript. Ви можете використати наступний підхід для перевірки підтримки:\nfunction hasRegExpY() {\n    try {\n        var pattern = new RegExp(&quot;.&quot;, &quot;y&quot;);\n        return true;\n    } catch (ex) {\n        return false;\n    }\n}\n\nТак само як перевірка на опцію u, код повертає false, якщо не в змозі створити регулярний вираз з опцією y. Подібно до використання u, якщо вам треба використати y в коді, який обробляється у старих інтерпретаторах JavaScript, будьте певними, що використовуєте конструктор RegExp коли визначаєте регулярний вираз, щоб уникнути помилок.\nДублювання Regular Expressions\nВ ECMAScript 5, ви можете дублювати регулярні вирази, передавши до конструктора RegExp таким чином:\nvar re1 = /ab/i,\n    re2 = new RegExp(re1);\n\nЗмінна re2 є звичайною копією змінної re1. Але якщо ви передасте другий аргумент до конструктору RegExp, який буде визначати опцію для вашого регулярного виразу, ви отримаєте помилку, як в цьому прикладі:\nvar re1 = /ab/i,\n\n    // видає помилку в ES5 , працює в ES6\n    re2 = new RegExp(re1, &quot;g&quot;);\n\nЯкщо ви виконаєте цей код в оточенні ECMAScript 5, ви отримаєте помилку, яка вказуватиме на те, що другий аргумент не може бути використаний, якщо перший аргумент є регулярним виразом . ECMAScript 6 змінює цю поведінку таким чином, що другий аргумент є дозволеним та буде переписувати будь-яку опцію, яка буде міститися у першому аргументі. Наприклад:\nvar re1 = /ab/i,\n\n    // видає помилку в ES5 , працює в ES6\n    re2 = new RegExp(re1, &quot;g&quot;);\n\n\nconsole.log(re1.toString());            // &quot;/ab/i&quot;\nconsole.log(re2.toString());            // &quot;/ab/g&quot;\n\nconsole.log(re1.test(&quot;ab&quot;));            // true\nconsole.log(re2.test(&quot;ab&quot;));            // true\n\nconsole.log(re1.test(&quot;AB&quot;));            // true\nconsole.log(re2.test(&quot;AB&quot;));            // false\n\nВ цьому коді, re1 має чутливу до регістру опцію i, в той час як re2 має тільки опцію g. Конструктор RegExp дублює вираз по шаблону re1 та змінює опцію g на опцію i. Без другого аргументу, re2 буде мати ті самі опції, що й re1.\nВластивість flags\nРазом з доданням нової опції та зміни засобів роботи з опціями, ECMAScript 6 додає нову властивість пов’язану з ними. В ECMAScript 5 ви могли отримати текст регулярного виразу, використовуючи властивість source, але щоб отримати рядкове представлення опції, вам було потрібно парсити результат метода toString(), як показано нижче:\nfunction getFlags(re) {\n    var text = re.toString();\n    return text.substring(text.lastIndexOf(&quot;/&quot;) + 1, text.length);\n}\n\n// toString() є &quot;/ab/g&quot;\nvar re = /ab/g;\n\nconsole.log(getFlags(re));          // &quot;g&quot;\n\nЦей код конвертує регулярний вираз в рядок, а потім повертає символи знайдені після останнього /. Ці символ і є опції.\nECMAScript 6 робить визначення опцій легше, додаючи властивість flags до існуючої властивості source. Обидві властивості є засобами доступу до властивостей прототипу, що робить їх доступними тільки до зчитування. Властивість flags робить опрацювання регулярних виразів легшим, як для налагоджування так і для успадкування.\nДодана до ECMAScript 6 в останню чергу, властивість flags повертає рядкове відображення будь-якої опції доданої до регулярного виразу, наприклад:\nvar re = /ab/g;\n\nconsole.log(re.source);     // &quot;ab&quot;\nconsole.log(re.flags);      // &quot;g&quot;\n\nКод отримує всі опції від re та виводить їх до консолі значно легшим шляхом в той час, коли техніка це робить з використанням методу toString(). Використання source та flags разом дозволить вам отримувати частини регулярного виразу без використання технік з парсингом.\nВсі зміни до рядків і регулярних виразів, які розглянуті в цьому розділі є безумовно потужними, але ECMAScript 6 надає ширші можливості роботи з рядками. Він додає новий літерал до таблиці, що робить рядки більш гнучкими.\nШаблонні літерали\nРядки в JavaScript&#39;s завжди були досить обмеженими в порівнянні з іншими мовами. З початку становлення JavaScript, рядкам не вистачало методів розглянутих вище в цьому розділі, а конкатенація рядків є досить простою. Шаблонні літерали додають новий синтаксис для створення специфічної для домену мови (DSLs), щоб працювати з контентом у більш безпечний спосіб ніж ми робимо це зараз. DSLs мова розроблена для специфічного, вузького використання (на відміну від JavaScript, який є мовою широкого використання) і можливість створювати DSLs в середені JavaScript була дуже бажаною для розробників JavaScript, для розв’язання найбільш складних проблем. Вікі ECMAScript пропонує наступне визначення для template literal strawman:\n\nЦя схема розширює синтаксис ECMAScript додаванням синтаксичного цукру, щоб дозволити іншим бібліотекам впроваджувати DSLs для легкого створення запитів та маніпулювання контентом з інших мов, які стійкі для ін’єкцій та атак, як XSS, SQL Ін’єкції, та інші.\n\nНасправді, шаблонні літерали ECMAScript 6 — це відповідь усім недолікам, які мав JavaScript в цьому плані з моменту виходу ECMAScript 5:\n\nбагаторядковий режим формальна концепція багатолінійних рядків;\nбазове форматування рядків можливість заміщувати частину рядка значеннями з певних змінних;\nHTML escaping можливість трансформувати рядки, щоб безпечно вставляти іх в HTML.\n\nЗамість того, щоб додати більше можливостей існуючому функціоналу з опрацювання рядків JavaScript, літерали рядків пропонують повністю новий підхід для вирішення цих проблем.\nЗагальний синтаксис\nДякуючи своїй простоті, шаблонні літерали працюють як звичайні рядки оточенні зворотніми лапками (` ) замість подвійних або одинарних. Розглянемо цей приклад:\nlet message = `Hello world!`;\n\nconsole.log(message);               // &quot;Hello world!&quot;\nconsole.log(typeof message);        // &quot;string&quot;\nconsole.log(message.length);        // 12\n\nЦей код показує, що змінна message містить звичайний рядок JavaScript. В даному випадку синтаксис шаблонного літералу використано тільки для того, щоб створити рядкове значення, яке згодом буде прив’язане до змінної message.\nЯкщо ви хочете використовувати зворотні рядку й надалі, тоді треба екранувати їх зворотнім слешем (\\), як в цьому варіанті змінної message:\nlet message = `\\`Hello\\` world!`;\n\nconsole.log(message);               // &quot;`Hello` world!&quot;\nconsole.log(typeof message);        // &quot;string&quot;\nconsole.log(message.length);        // 14\n\nВи не повинні екранувати подвійні або одинарні лапки в синтаксисі шаблонного літералу.\nБагаторядковий режим\nJavaScript розробники шукали можливість працювати в багаторядковому режимі з моменту створення мови. Але коли ми використовуємо подвійні або одинарні лапки, рядок має бути розташований тільки на одному рядку коду.\nОбхідні шляхи до появи ECMAScript 6\nДякуючи давно відомому синтаксичному багу, JavaScript має обхідні шляхи. Ви можете працювати в багаторядковому режимі, якщо перед новим рядком коду ставити зворотній слеш (\\). Ось, наприклад:\nvar message = &quot;Multiline \\\nstring&quot;;\n\nconsole.log(message);       // &quot;Multiline string&quot;\n\nРядок message не має нових рядків в консолі, тому що зворотній слеш сприймаєтеся як продовження поточного рядка, а не початок нового. Для того щоб визначити новий рядок, вам потрібно його позначити:\nvar message = &quot;Multiline \\n\\\nstring&quot;;\n\nconsole.log(message);       // &quot;Multiline\n                            //  string&quot;\n\nЦе має вивести Multiline String на двох роздільних рядках у більшості JavaScript інтерпретаторів, але, по суті, така поведінка визначається як баг, тому більшість розробників радять не користатися таким трюком.\nІншими шляхами працювати у багаторядковому режимі до появи ECMAScript 6 було звернення до масивів або конкатенація рядків, наприклад:\nvar message = [\n    &quot;Multiline &quot;,\n    &quot;string&quot;\n].join(&quot;\\n&quot;);\n\nlet message = &quot;Multiline \\n&quot; +\n    &quot;string&quot;;\n\nПроте у цих всіх обхідних шляхах не вистачало того, що було потрібно розробникам.\nБагаторядковий режим простим чином\nШаблонні літерали ECMAScript 6 роблять роботу у багаторядковому режимі досить легкою, тому що не мають спеціального синтаксису. Просто робіть новий рядок де вам треба і він буде оброблений. Наприклад:\nlet message = `Multiline\nstring`;\n\nconsole.log(message);           // &quot;Multiline\n                                //  string&quot;\nconsole.log(message.length);    // 16\n\nУсі пробіли всередині зворотних лапок є частиною рядка, тому будьте уважними з відступами. Наприклад:\nlet message = `Multiline\n               string`;\n\nconsole.log(message);           // &quot;Multiline\n                                //                 string&quot;\nconsole.log(message.length);    // 31\n\nУ цьому коді, всі пробіли перед другим рядком шаблону фактично вважаються частиною самого рядка. Якщо зробити текстовий рядок з правильними відступами для вас важливо, то потрібно залиши порожнім перший рядок у багаторядковому шаблонному літералі, а потім починати робити відступи в нових рядках, а саме:\nlet html = `\n&lt;div&gt;\n    &lt;h1&gt;Title&lt;/h1&gt;\n&lt;/div&gt;`.trim();\n\nЦей код починає шаблонний літерал на першому рядку, але він не має ніякого тексту аж до другого. Теги HTML мають відступи для гарного вигляду, а потім метод trim() викликається щоб видалити перший порожній рядок.\nA&gt; Якщо ви бажаєте, ви також можете використовувати символ \\n в шаблонному літералі, щоб показати де має бути створена нова лінія:\nlet message = `Multiline\\nstring`;\nconsole.log(message);           // &quot;Multiline\n                                //  string&quot;\nconsole.log(message.length);    // 16\n\nРобимо підстановки\nВ цьому сенсі, шаблонні літерали можуть здаватися більш вдосконаленою версією звичайних JavaScript рядків. Реальна різниця між ними якраз і міститься в шаблонному літералі підстановки. Підстановки дозволяють вам помістити любий валідний JavaScript вираз в середину шаблонного літералу і вивести результат як частину рядка.\nПідстановки оточені відкриваючим ${ і закриваючим }, що може містити будь-який JavaScript вираз. Найпростіша підстановка дозволить вам помістити локальні змінні в підсумковий рядок, наприклад:\nlet name = &quot;Nicholas&quot;,\n    message = `Hello, ${name}.`;\n\nconsole.log(message);       // &quot;Hello, Nicholas.&quot;\n\nПідстановка в ${name} має доступ до локальної змінної name щоб вставити name в рядок message. Змінна message одразу ж виводить результат підстановки.\nI&gt; Шаблонний літерал може мати доступ до будь-якої наявної змінної в області видимості, до якої він належить. Спроба використати в шаблонному літералі не визначену змінну призведе до помилки як у строгому, так і нестрогому режимі.\nОскільки всі підстановки є JavaScript виразами, ви можете підставляти не тільки прості імена змінних. Ви можете легко використати результати обчислень або функцій. Наприклад:\nlet count = 10,\n    price = 0.25,\n    message = `${count} items cost $${(count * price).toFixed(2)}.`;\n\nconsole.log(message);       // &quot;10 items cost $2.50.&quot;\n\nЦей код виконує обчислення, як частину шаблонного літералу. До змінних count та price застосовується операція множення, щоб отримати результат, а потім форматування до двох символів після коми за допомогою .toFixed(). Знак долару перед другою підстановкою виводиться як є, тому що після нього немає відкриваючої фігурної дужки.\nТеговані шаблони\nВи побачили як шаблонні літерали можуть створювати багаторядкові рядки та вставляти значення в рядки без конкатенації. Але справжню силу шаблонних літералів можна відчути з тегованими шаблонами. Тег шаблону виконує трансформацію шаблонного літералу і повертає остаточне значення рядка. Такий тег визначається на початку рядка, одразу перед першим символом ` , як показано тут:\nlet message = tag`Hello world`;\n\nВ цьому прикладі, tag є тегом шаблону щоб застосувати шаблонного літералу `Hello world` .\nВизначаємо теги\nНасправді тег це просто функція яка виконується при обробці даних шаблонного літералу. Тег отримує данні про шаблонні літерали як окремі частини коду і має зібрати ці частини разом. Перший аргумент — це масив рядків шаблонного літералу як їх інтерпретує JavaScript. Кожен наступний аргумент — це відтворене значення кожної підстановки.\nФункції тегів як правило викликаються з аргументами, як показано нижче, щоб полегшити роботу з даними:\nfunction tag(literals, ...substitutions) {\n    // повертає рядок\n}\n\nЩоб краще зрозуміти що передається до тегів, розглянемо наступне:\nlet count = 10,\n    price = 0.25,\n    message = passthru`${count} items cost $${(count * price).toFixed(2)}.`;\n\nЯкщо ви матимете функцію з назвою passthru(), то вона отримає три аргументи. По-перше, вона отримає масив literals, який матиме наступні елементи:\n\nпустий рядок перед першою підстановкою (&quot;&quot;);\nрядок після першої і перед другою підстановкою (&quot; items cost $&quot;);\nрядок після другої підстановки (&quot;.&quot;).\n\nНаступний аргумент буде 10, що є значенням змінної count. Він стає першим елементом в масиві substitutions. Останнім аргументом буде &quot;2.50&quot;, що є здобутим значенням для (count * price).toFixed(2) та другого елементу в масиві substitutions.\nЗауважте, що перший елемент в literals є порожнім рядком. Таким чином ми впевнені, що literals[0] є завжди початком рядка, так само як literals[literals.length - 1] завжди кінець рядка. Підстановок завжди на одну менше ніж літералів, таким чином вираз substitutions.length === literals.length - 1 завжди правильний.\nВикористовуючи цей шаблон, масиви literals та substitutions можуть бути зв’язані, щоб утворити результуючий рядок. Перший елемент в literals йде першим, перший елемент substitutions йде за ним, і так далі, поки рядок не буде опрацьовано. Наприклад, ви можете імітувати поведінку літералу шаблону, чергуючи значення цих двох масивів:\nfunction passthru(literals, ...substitutions) {\n    let result = &quot;&quot;;\n\n    // запускаємо цикл тільки для підрахунку substitutions\n    for (let i = 0; i &lt; substitutions.length; i++) {\n        result += literals[i];\n        result += substitutions[i];\n    }\n\n    // додаємо осатаній літерал\n    result += literals[literals.length - 1];\n\n    return result;\n}\n\nlet count = 10,\n    price = 0.25,\n    message = passthru`${count} items cost $${(count * price).toFixed(2)}.`;\n\nconsole.log(message);       // &quot;10 items cost $2.50.&quot;\n\nВ цьому прикладі визначається тег passthru який виконує ту ж саму трансформацію що й шаблонний літерал за замовчуванням. Єдина хитрість тут — це використання substitutions.length для циклу замість literals.length, щоб уникнути ненавмисного виходу за рамки масиву substitutions. Це працює тому, що відношення між literals та substitutions добре визначені в ECMAScript 6.\nI&gt; Значення в substitutions не обов&#39;язково мають бути рядками. Якщо у виразі виконується число, як в попередньому прикладі, тоді буде передаватися числове значення. Визначення кількості значень, що мають бути виведені в результаті частини роботи тегів.\nВикористання первинних значень у шаблонних літералах\nТеги шаблонів також мають доступ до первинної інформації, що в першу чергу означає доступ до символів екранування перш ніж вони будуть трансформовані в їх символьні еквіваленти. Найпростішим засобом для роботи з первинними значеннями рядків є використання вбудованого тегу String.raw(). Наприклад:\nlet message1 = `Multiline\\nstring`,\n    message2 = String.raw`Multiline\\nstring`;\n\nconsole.log(message1);          // &quot;Multiline\n                                //  string&quot;\nconsole.log(message2);          // &quot;Multiline\\\\nstring&quot;\n\nВ цьому коді, \\n в message1 інтерпретується як символ нової лінії, в той час як \\n в message2 інтерпретується в його первинній формі &quot;\\\\n&quot; (символи слешу й n). Доступ до первинної інформації, як в цьому прикладі, дозволяє виконувати більш комплексні операції за необхідності.\nПервинна інформація рядка також передається в теги шаблону. Перший аргумент в функції тегу — масив з екстра властивістю незваною raw. Властивість raw є масивом який вміщає первинний еквівалент кожного значення літералу. Наприклад, значення в literals[0] завжди має еквівалент literals.raw[0], який містить інформацію рядка. Знаючи це, ви можете імітувати String.raw(), використовуючи наступний код:\nfunction raw(literals, ...substitutions) {\n    let result = &quot;&quot;;\n\n    // запускаємо цикл тільки для підрахунку substitutions\n    for (let i = 0; i &lt; substitutions.length; i++) {\n        result += literals.raw[i];      // use raw values instead\n        result += substitutions[i];\n    }\n\n    // додаємо останній літерал\n    result += literals.raw[literals.length - 1];\n\n    return result;\n}\n\nlet message = raw`Multiline\\nstring`;\n\nconsole.log(message);           // &quot;Multiline\\\\nstring&quot;\nconsole.log(message.length);    // 17\n\nКод використовує literals.raw замість literals щоб вивести результуючий рядок. Це означає, що будь-які символи, що екрануються, в тому числі коди Unicode, мають бути повернені в їх первинній формі. Первинна форма рядків стає у нагоді, коли ви хочете вивести рядок, який містить код в якому ви хочете вивести екрановані символи (наприклад, коли ви хочете генерувати документацію про якийсь код, ви, можливо, захочете вивести код у такому вигляді як він є).\nПідсумок\nПовна підтримка Unicode дозволяє JavaScript працювати з символами UTF-16 логічним чином. Можливість переходів між кодами та символами через codePointAt() та String.fromCodePoint() є важливим кроком в маніпуляціях з рядками. Додавання опції u до регулярних виразів дає можливість оперувати кодами замість 16-бітових символів, а метод normalize() дозволяє краще порівнювати рядки.\nECMAScript 6 також додає нові методи для роботи з рядками, дозволяючи вам краще визначати субрядки, дивлячись на їх позицію в батьківському рядку. Також більше функціоналу було надано регулярним виразам.\nШаблонні літерали є важливим додатком до ECMAScript 6, що дозволяє вам створювати специфічні до домену мови (DSLs), щоб полегшити створення рядків. Можливість вставляти змінні безпосередньо в шаблонний літерал означає, що розробники мають безпечніший інструмент ніж конкатенація рядків при поєднанні довгих рядків зі змінними.\nВбудована підтримка багаторядкових рядків також робить шаблонні літерали корисним доповненням до рядків JavaScript, які досі не мали такої можливості. Не зважаючи на можливість використання нових рядків безпосередньо всередині шаблонного літералу, ви все ще можете використовувати \\n та інші екрановані символи.\nТеги шаблону є найбільш важливою частиною цього покращення для створення DSLs. Теги — це функції, що отримують частини літералу шаблону як аргументи. В подальшому ви можете використовувати ці данні, щоб повернути відповідне значення рядка. Впроваджені данні включають літерали, їхні вихідні еквіваленти, та будь−які значення заміщень. Ці частини інформації в подальшому можуть буди використані, щоб визначити коректний вивід тегу.\n"},"manuscript/03-Functions.html":{"url":"manuscript/03-Functions.html","title":"Функції","body":"Функції\nФункції — важлива частина будь–якої мови програмування. До ECMAScript 6, функції в JavaScript з моменту створення мови, не зазнавали значних змін. Це накопичувало проблеми та нюанси поведінки, які призводили до помилкок та потребували більше коду для виконання базових завдань.\nФункції в ECMAScript 6 зробили великий крок уперед, беручи до уваги скарги та прохання JavaScript–розробників. Результатом стали численні покращення ECMAScript 5 функцій, що допоможуть уникнути помилок у програмуванні на JavaScript та зроблять його більш потужним.\nФункції з параметрами за замовчуванням\nФункції в JavaScript є унікальними тому, що дозволяють приймати будь-яку кількість параметрів, незалежно від того, яку кількість параметрів було оголошено під час визначення функції. Це дозволяє вам визначати функції, що можуть оперувати різною кількістю параметрів просто підставляючи значення за замовчуванням, коли вони не передані. Цей розділ розповідає про те, як параметри за замовчуванням працюють до та в ECMAScript 6 разом з важливою інформацією про об’єкт arguments, використання виразів у якості параметрів та інші нюанси.\nІмітування параметрів за замовчуванням у ECMAScript 5\nУ ECMAScript 5 та раніше ви, напевно, використовували такий шаблон для створення функції з параметрами за замовчуванням:\nfunction makeRequest(url, timeout, callback) {\n\n    timeout = timeout || 2000;\n    callback = callback || function() {};\n\n    // решта функції\n\n}\n\nУ цьому прикладі і timeout, і callback є насправді необов’язковими, тому що їм передаються значення за замовчуваннями, якщо вони не вказані. Логічний оператор AБО (||) завжди повертає другий оперант, якщо перший є хибним. Оскільки вказані параметри не вказані, їм буде встановелене значення undefined, таким чином оператор логічного АБО часто використовується для встановлення пропущеним параметрам значень за замовчуванням. Однак, у такому підході є недолік: у тому випадку, якщо timeout матиме значення 0, яке є валідним, воно буде замінене на 2000, тому що 0 є хибою.\nУ цьому випадку, безпечнішою альтернативою первірки чи було передано аргумент є використання typeof, як у цьому прикладі:\nfunction makeRequest(url, timeout, callback) {\n\n    timeout = (typeof timeout !== &quot;undefined&quot;) ? timeout : 2000;\n    callback = (typeof callback !== &quot;undefined&quot;) ? callback : function() {};\n\n    // решта функції\n\n}\n\nЦей підхід безпечніший, але він потребує багато зайвого коду для такої простої операції. Популярні JavaScript–бібліотеки часто використовують подібний патерн, оскільки цей підхід є загальним.\nПараметри за замовчуванням у ECMAScript 6\nECMAScript 6 полегшує передачу значень параметрам за замовчуванням шляхом ініціалізації, яка відбувається, коли параметр не був переданий. Наприклад:\nfunction makeRequest(url, timeout = 2000, callback = function() {}) {\n\n    // the rest of the function\n\n}\n\nЦя функція очікує, що лише перший параметр буде передаватись завжди. Інші два параметри мають значення за замовчуванням, що робить тіло функції меншим, оскільки вам не потрібно писати додатковий код для перевірки значень.\nКоли makeRequest() з усіма трьома параметрами, параметри за замовчуванням не будуть використовуватись. Наприклад:\n// використовує значення timeout та callback за замовчуванням\nmakeRequest(&quot;/foo&quot;);\n\n// використовує callback за замовчуванням\nmakeRequest(&quot;/foo&quot;, 500);\n\n// не використовує значення за замовчуванням\nmakeRequest(&quot;/foo&quot;, 500, function(body) {\n    doSomething(body);\n});\n\nECMAScript 6 розглядає url як обов’язковий параметр, тому ми передаємо &quot;/foo&quot; у всіх трьох викликах makeRequest(). Два параметри зі значеннями за замовчуванням розглядаються як необов’язкові.\nМожливо задавати значення за замовчуванням для будь–яких аргументів, враховуючи ті, які знаходяться у оголошенні функції перед аргументами без значень за замовчуванням. Наприклад, такий код працює як і очікується:\nfunction makeRequest(url, timeout = 2000, callback) {\n\n    // решта функції\n\n}\n\nУ цьому випадку значення timeout за замовчування використовуватиметься лише тоді, коли другий аргумент не переданий, або якщо в якості другого аргументу безпосередньо передати undefined, як у цьому прикладі:\n// використовує timeout за замовчуванням\nmakeRequest(&quot;/foo&quot;, undefined, function(body) {\n    doSomething(body);\n});\n\n// використовує значення timeout за замовчуванням\nmakeRequest(&quot;/foo&quot;);\n\n// не використовує значення timeout за замовчуванням\nmakeRequest(&quot;/foo&quot;, null, function(body) {\n    doSomething(body);\n});\n\nУ цьому випадку, значення null сприймається як валідне і означає, що в третьому виклику makeRequest() значення timeout за замовчуванням не буде використовуватись.\nЯк параметри за замовчуванням впливають на об’єкт arguments\nПросто запам’ятайте, що поведніка об’єкту arguments відрізняється від звичної, якщо використовуються значення за замовчуванням. У нестрогому режимі (nonstrict mode) ECMAScript 5 об’єкт arguments відображає зміни в іменованих параметрах функції. Нижче наведений код, який ілюструє як це працює:\nfunction mixArgs(first, second) {\n    console.log(first === arguments[0]);\n    console.log(second === arguments[1]);\n    first = &quot;c&quot;;\n    second = &quot;d&quot;;\n    console.log(first === arguments[0]);\n    console.log(second === arguments[1]);\n}\n\nmixArgs(&quot;a&quot;, &quot;b&quot;);\n\nВивід:\ntrue\ntrue\ntrue\ntrue\nУ нестрогому режимі об’єкт arguments завжди оновлюється, щоб відображати зміни в іменованих параметрах. Тобто, якщо для first та second присвоїти нові значення, arguments[0] та arguments[1] оновляться миттєво, тому порівняння === даватиме результат true.\nОднак строгий режим (strict mode) ECMAScript 5 усуває цю неочевидну властивість об’єкта arguments. У строгому режимі, об’єкт arguments не відображає зміни в іменованих параметрах. Нижче знову наведена функція mixArgs(), але у строгому режимі:\nfunction mixArgs(first, second) {\n    &quot;use strict&quot;;\n\n    console.log(first === arguments[0]);\n    console.log(second === arguments[1]);\n    first = &quot;c&quot;;\n    second = &quot;d&quot;\n    console.log(first === arguments[0]);\n    console.log(second === arguments[1]);\n}\n\nmixArgs(&quot;a&quot;, &quot;b&quot;);\n\nВиклик mixArgs() виведе:\ntrue\ntrue\nfalse\nfalse\nЦього разу зміни first та second не вплинули на arguments, тому вивід буде саме таким, яким ви його очікуєте.\nОб’єкт arguments у функціях, що використовують ECMAScript 6 параметри за замовчуванням, однак, завжди поводитимуться так, як вони поводяться у строгому режимі ECMAScript 5, незалежно від того, чи функція працює у строгому режимі, чи ні. Наявність параметрів за замовчуванням робить об’єкт arguments незалежним від іменованих параметрів. Це тонка, але важлива деталь того, як об’єкт arguments може бути використаний. Розгляньте наступне:\n// не строгий режим\nfunction mixArgs(first, second = &quot;b&quot;) {\n    console.log(arguments.length);\n    console.log(first === arguments[0]);\n    console.log(second === arguments[1]);\n    first = &quot;c&quot;;\n    second = &quot;d&quot;\n    console.log(first === arguments[0]);\n    console.log(second === arguments[1]);\n}\n\nmixArgs(&quot;a&quot;);\n\nВиведе:\n1\ntrue\nfalse\nfalse\nfalse\nУ цьому прикладі, arguments.length рівне 1 тому, що лише один аргумент було передано до mixArgs(). Це також означає, що arguments[1] рівний undefined, що є очікованою поведінкою, коли лише один аргумент передається у функцію. Це також означає, що first є рівним arguments[0]. Зміна first та second не повпливає на arguments. Така поведінка буде  як у строгому, так і в нестрогому режимах, тож ви можете бути певні, що arguments завжди відображатиме початковий стан виклику.\nВирази в параметрах за замовчуванням\nОдним з найбільш цікавих нововведень параметрів за замовчуванням є те, що їхні значення не обов’язково мають бути примітивними. Ви можете, наприклад, викликати функцію, що повертатиме значення параметру, ось так:\nfunction getValue() {\n    return 5;\n}\n\nfunction add(first, second = getValue()) {\n    return first + second;\n}\n\nconsole.log(add(1, 1));     // 2\nconsole.log(add(1));        // 6\n\nТут, якщо останній аргумент не переданий, викликається фукнція getValue(), що повертає правильне значення за замовчуванням. Пам’ятайте, що getValue() буде викликана лише тоді, коли add() буде викликана без другого аргументу, а не тоді, коли оголошення функції буде оброблене інтерпретатором. Це означає, що якщо getValue() була написана змінною, вона буде повертати різні значення. Для розуміння:\nlet value = 5;\n\nfunction getValue() {\n    return value++;\n}\n\nfunction add(first, second = getValue()) {\n    return first + second;\n}\n\nconsole.log(add(1, 1));     // 2\nconsole.log(add(1));        // 6\nconsole.log(add(1));        // 7\n\nУ цьому прикладі, value має значення п’ять і збільшується на одну одиницю щоразу, коли викликається getValue(). Перший виклик add(1) повертає 6, а другий виклик add(1) повертає 7, тому що value був збільшений на одиницю. Оскільки значення second за замовчуванням обчислюється під час виклику функції, можна змінити це значення у будь–який час.\nW&gt; Будьте обережні при використанні виклику фукнцій в якості параметрів за замовчуванням. Якщо ви забудете дужки, як ось second = getValue у останньому прикладі, ви отримаєте посилання на функцію замість результату її виклику.\nТака поведінка демонструє іншу цікаву особливість. Ви можете використовувати параметр за замовчування для наступного параметра. Ось приклад:\nfunction add(first, second = first) {\n    return first + second;\n}\n\nconsole.log(add(1, 1));     // 2\nconsole.log(add(1));        // 2\n\nУ цьому прикладі, параметр second отримує значення first за замовчуванням, що означає, що виклик фукнції з одним аргументом присвоїть обом параметрам однакове значення. Тому add(1, 1) поверне 2 так само, як це робить add(1). Навіть більше, ви можете передати first у функцію, щоб отримаи значення second ось так:\nfunction getValue(value) {\n    return value + 5;\n}\n\nfunction add(first, second = getValue(first)) {\n    return first + second;\n}\n\nconsole.log(add(1, 1));     // 2\nconsole.log(add(1));        // 7\n\nЦей приклад встановлює second рівним значенню, яке було повернуте getValue(first), тому add(1, 1) продовжує повертати 2, а add(1) поверне 7 (1 + 6).\nМожливість посилатись на параметри працює лише за умови звернення до попередніх аргументів, тому аргументи попереду не мають доступу до наступних аргументів. Наприклад:\nfunction add(first = second, second) {\n    return first + second;\n}\n\nconsole.log(add(1, 1));     // 2\nconsole.log(add(1));        // викине помилку\n\nВиклик add(1) викине помилку, тому що second визначений після first і тому недоступний в якості значення за замовчуванням. Щоб зрозуміти що тут відбувається, важливо згадати що таке тимчасова мертва зона.\nТимчасова мертва зона параметрів за замовчуванням\nГлава 1 ввела поняття тимчасової мертвої зони (ТМЗ) яка стосувалась let та const, втім, параметри за замовчуванням також мають ТМЗ, з якої параметри будуть недоступними. Подібно до let–оголошення, кожен параметр створює новий ідентифікатор зв’язування, на який не можна посилатись до його ініціалізації, не спричинивши помилки. Ініціалізація параметра відбувається або тоді, коли функція викликається, або при передачі параметрам значення, або при використанні значень параметрів за замовчуванням.\nЩоб дослідити ТМЗ параметрів за замовчуванням, розглянемо цей приклад з розділу «Вирази в параметрах за замовчуванням»:\nfunction getValue(value) {\n    return value + 5;\n}\n\nfunction add(first, second = getValue(first)) {\n    return first + second;\n}\n\nconsole.log(add(1, 1));     // 2\nconsole.log(add(1));        // 7\n\nВиклики add(1, 1) та add(1) ефективно виконують присвоєння first та second значень за замовчуванням:\n// JavaScript представлення виклику add(1, 1)\nlet first = 1;\nlet second = 1;\n\n// JavaScript представлення виклику add(1)\nlet first = 1;\nlet second = getValue(first);\n\nКоли функція add() виконується вперше, зв’язування first та second додаються до специфічної для параметрів ТМЗ (схоже на те, як поводить себе let). Тому хоча second може бути ініціалізований зі значенням first, оскільки first у той момент буде вже ініціалізованим, але протилежне не є вірним. Тепер розглянемо змінену функцію add():\nfunction add(first = second, second) {\n    return first + second;\n}\n\nconsole.log(add(1, 1));         // 2\nconsole.log(add(undefined, 1)); // кидає помилку\n\nДавайте розглянемо, що відбувається за лаштунками під час виклику add(1, 1) та add(undefined, 1) у цьому прикладі:\n// JavaScript представлення виклику add(1, 1)\nlet first = 1;\nlet second = 1;\n\n// JavaScript представлення виклику add(undefined, 1)\nlet first = second;\nlet second = 1;\n\nУ цьому випадку, виклик add(undefined, 1) призводить до помилки, тому що second ще не був ініціалізований тоді, коли ініціалізувався first. У цьому випадку, second знаходиться у ТМЗ, і тому будь–яке посилання на нього призведе до помилки. Схожу поведінку let–оголошень було розглянуто у Главі 1.\nI&gt; Параметри функцій мають власну області видимості та власні ТМЗ, що відрізняються від області видимості функцій. Це означає, що значення параметрів за замовчуванням не можуть звертатись до будь–якої змінної, оголошеної всередині тіла функції.\nРобота з неіменованими параметрами\nДосі, приклади у цій главі були пов’язані лише з параметрами, які мали імена у виразі функції. Однак, функції JavaScript не обмежують кількість параметрів, які ми можемо передавати у функцію, кількістю параметрів, які вказані при заданні функції. Ви завжди можете передати менше або більше параметрів, ніж формально оголошено. Значення за замовчування допомагають тоді, коли функція може приймати менше параметрів, але ECMAScript 6 також пропонує вирішення проблеми з передачею більшої кількості параметрів, ніж вказано в оголошенні.\nНеіменовані параметри в ECMAScript 5\nРаніше JavaScript пропонував об’єкт arguments для того, щоб працювати з усіма параметрами, які були передані у функцію, без необхдіності вказувати кожен параметр індивідуально. Об’єкт arguments чудово працює у більшості випадків, проте цей об’єкт може бути занадто громіздким. Наприклад, дослідіть цей код, який оперує об’єктом arguments:\nfunction pick(object) {\n    let result = Object.create(null);\n\n    // починаючи з другого параметра\n    for (let i = 1, len = arguments.length; i &lt; len; i++) {\n        result[arguments[i]] = object[arguments[i]];\n    }\n\n    return result;\n}\n\nlet book = {\n    title: &quot;Understanding ECMAScript 6&quot;,\n    author: &quot;Nicholas C. Zakas&quot;,\n    year: 2015\n};\n\nlet bookData = pick(book, &quot;author&quot;, &quot;year&quot;);\n\nconsole.log(bookData.author);   // &quot;Nicholas C. Zakas&quot;\nconsole.log(bookData.year);     // 2015\n\nЦя фукнція відтворює метод pick() з бібліотеки Underscore.js, який повертає копію даного об’єкту з деякою підмножиною властивостей оригінального об’єкту. У цьому прикладі оголошується лише один аргумент і очікується, що він буде об’єктом, з якого будуть копіюватись властивості. Усі інші аргументи, які передаються — це імена властивостей, які мають бути копійованими до результату.\nЄ кілька речей, які потрібно зауважити у функції pick(). По–перше, не зовсім очевидно, що функція може обробляти більше одного параметра. Ви могли б задати більше параметрів, але було б не достатньо очевидно, що фукнція може приймати будь–яку кількість параметрів. По–друге, оскільки перший параметр іменований та використовується безпосередньо, якщо ви звернете увагу на властивості, які мають бути скопійовані, то муситиме звертатись до об’єкта arguments починаючи з індексу 1 замість індексу 0. Запам’ятовування відповідних індексів для arguments не є складним, проте це ще одна річ, за якою потрібно стежити.\nECMAScript 6 вводить залишкові (rest) параметри, щоб вирішити цю проблему.\nЗалишкові (rest) параметри\nЗалишкові параметри (або rest–параметри) позначаються трьома крапками (...) перед іменованим параметром. Цей іменований параметр стає масивом (Array), що містить решту параметрів, які були передані функції. Наприклад, pick() можна переписати з використанням залишкових параметрів ось так:\nfunction pick(object, ...keys) {\n    let result = Object.create(null);\n\n    for (let i = 0, len = keys.length; i &lt; len; i++) {\n        result[keys[i]] = object[keys[i]];\n    }\n\n    return result;\n}\n\nУ цій версії функції, keys — це залишковий параметр, який містить всі параметри, передані після object (на відміну від arguments, який містить всі параметри, враховуючи перший). Це означає, що ви без проблем можете ітеруватись по keys від початку і до кінця. В якості бонусу, ви можете з одразу помітити, що функція працює з будь–якою кількістю параметрів.\nI&gt; Залишкові параметри не впливають на властивість функції length, яка вказує на кількість іменованих параметрів функції. Значення length для pick() у цьому прикладі є рівним 1, оскільки буде враховутись лише object.\nОбмеження залишкових параметрів\nЄ два обмеження пов’язані з залишковими параметрами. Перше обмеження: може бути лише один залишковий параметр і він має бути останнім. Для прикладу, такий код не працюватиме.\n// Syntax error: Can&#39;t have a named parameter after rest parameters\nfunction pick(object, ...keys, last) {\n    let result = Object.create(null);\n\n    for (let i = 0, len = keys.length; i &lt; len; i++) {\n        result[keys[i]] = object[keys[i]];\n    }\n\n    return result;\n}\n\nТут, праметр last слідує за залишковим параметром keys, що спричинило б синтактичну помилку.\nДруге обмеження — це те, що залишковий параметр не може використовуватись у сетерах об’єктних літералів. Це означає, що такий код також призведе до помилки:\nlet object = {\n\n    // Syntax error: Can&#39;t use rest param in setter\n    set name(...value) {\n        // якийсь код\n    }\n};\n\nЦе обмеження має місце тому, що сетери об’єктних літералів обмежуються одним аргументом. Залишкові параметри, за визначенням, є нескінченною кількістю аргументів, тож вони не дозволені у цьому контексті.\nЯк залишкові параметри впливають на об’єкт arguments\nЗалишкові параметри покликані замінити arguments в ECMAScript. Спочатку, ECMAScript 4 покінчив з arguments та включав залишкові параметри, які дозволяли б передавати необмежену кількість аргументів у функцію. ECMAScript 4 не був прийнятим, але ця ідея була збережена та відтворена у ECMAScript 6, незважаючи на те, що arguments не був видалений з мови.\nОб’єкт arguments працює разом із залишковими параметрами, відображаючи аргументи, які були передані до функції при виклику. Це ілюструє така програма:\nfunction checkArgs(...args) {\n    console.log(args.length);\n    console.log(arguments.length);\n    console.log(args[0], arguments[0]);\n    console.log(args[1], arguments[1]);\n}\n\ncheckArgs(&quot;a&quot;, &quot;b&quot;);\n\nВиклик checkArgs() виведе:\n2\n2\na a\nb b\nОб’єкт arguments завжди коректно відображає параметри, що були передані до функції незалежно від використання залишкових параметрів.\nЦе все, що вам потрібно знати про залишкові параметри, щоб почати використовувати їх. Наступний розділ продовжить розповідь про оператор розкладу (spread), який є дуже схожим на залишкові параметри.\nРозширені можливості конструктора Function\nКонструктор Function є рідковикористовуваною частиною JavaScript, яка дозволяє вам динамічно створювати нові функції. Аргументами конструктора є параметри для функції та тіло функції (всі аргументи у вигляді рядків). Ось приклад:\nvar add = new Function(&quot;first&quot;, &quot;second&quot;, &quot;return first + second&quot;);\n\nconsole.log(add(1, 1));     // 2\n\nECMAScript 6 доповнює Function можливостями задання параметрів за замовчуванням та залишкових параметрів. Вам потрібно лише додати знак рівності між значенням та ім’ям параметра:\nvar add = new Function(&quot;first&quot;, &quot;second = first&quot;,\n        &quot;return first + second&quot;);\n\nconsole.log(add(1, 1));     // 2\nconsole.log(add(1));        // 2\n\nУ цьому прикладі параметру second присвоюється значення first, коли переданий лише один параметр. Синтаксис такий же, як і для функцій, що не використовують Function.\nДля залишкових параметрів, просто додайте ... перед останнім параметром, як тут:\nvar pickFirst = new Function(&quot;...args&quot;, &quot;return args[0]&quot;);\n\nconsole.log(pickFirst(1, 2));   // 1\n\nЦей код створює функцію, яка використовує лише один залишковий параметр та повертає перший аргумент, який був переданий у функцію.\nДоповнення параметрами за замовчуванням та залишковими параметрами прирівнює можливості Function до можливостей декларативних форм оголошення функцій.\nОператор розкладу (spread)\nБлизьким до залишкових параметрів є оператор розкладу (spread). Залишкові параметри дозволяють вам вказати, як кілька незалежних аргументів можуть комбінуватись у масив тоді, як оператор розкладу дозволяє вам задати як масив має розкласти свої елементи у окремі аргументи функції. Розгляньте метод Math.max(), який приймає будь–яку кількість аргументів та повертає найбільше значення. Ось приклад використання цього методу:\nlet value1 = 25,\n    value2 = 50;\n\nconsole.log(Math.max(value1, value2));      // 50\n\nКоли ви працюєте з двома значеннями, як у цьому прикладі, Math.max() використовувати легко. Два значення передаються і повертається найбільше. Але що, якщо ви працюєте з значеннями масиву, і вам потрібно знайти найбільше значення? Метод Math.max() не дозволяє вам передавати масив, тому в ECMAScript 5 та раніше ви би застрягли шукаючи значення самостійно або використовували б apply() як ось тут:\nlet values = [25, 50, 75, 100]\n\nconsole.log(Math.max.apply(Math, values));  // 100\n\nЦе рішення працює, але використання apply() в такому вигляді вносить деяку плутанину. Це виглядає, наче навмисне заплутування коду додатковим синтаксисом.\nОператор розкладу ECMAScript 6 вирішує цю проблему дуже легко. Замість виклику apply(), ви можете передати масив у Math.max() напряму, додавши попереду ..., як і у випадку з залишковими параметрами. Рушій JavaScript розкладе масив у окремі аргументи та передасть їх у функцію, ось так:\nlet values = [25, 50, 75, 100]\n\n// еквівалент для\n// console.log(Math.max(25, 50, 75, 100));\nconsole.log(Math.max(...values));           // 100\n\nТепер виклик Math.max() виглядає більш звично та уникає складності, пов’язаної з заданням this–зв’язування (першого аргументу Math.max.apply() у попередньому прикладі) для простої математичної операції.\nВи можете змішувати та комбінувати оператор розкладу з іншими аргументами. Припустимо, вам потрібно, щоб найменшим числом, яке поверне Math.max() був 0 (просто для випадку, якщо якесь число менше 0 закрадеться у масив). Ви можете передати аргумент окремо та продовжувати використовувати оператор розкладу для інших аргументів:\nlet values = [-25, -50, -75, -100]\n\nconsole.log(Math.max(...values, 0));        // 0\n\nУ цьому прикладі, останній аргумент, переданий до Math.max() буде 0, який був переданий після всіх інших аргументів, переданих з використанням оператору розкладу.\nОператор розкладу для передачі аргументів робить використання масивів у функцях набагато легшим. Ви знайдете зручну заміну для методу apply() у більшості випадках.\nНа додачу до прикладів використання залишкових та параметрів за замовчуванням, в ECMAScript 6, ви можете також використовувати обидва типи у JavaScript–конструкторі  Function.\nВластивість name в ECMAScript 6\nІдентифікування функцій в JavaScript може виявитись складним завданням, зважаючи на численні способи визначення функцій. Крім того, поширення анонімних функцій робить відлагоджування набагато складнішим, адже стек викликів є складним для розуміння. Виходячи з цих міркувань, ECMAScript 6 вводить властивість name для всіх функцій.\nВибір відповідного імені\nВсі функції в програмах на ECMAScript 6 будуть мати відповідні значення властивості name. Щоб побачити це в дії, погляньте на приклад нижче, який демонструє фукнцію і функціональний вираз та виводить властивість name для обох:\nfunction doSomething() {\n    // ...\n}\n\nvar doAnotherThing = function() {\n    // ...\n};\n\nconsole.log(doSomething.name);          // &quot;doSomething&quot;\nconsole.log(doAnotherThing.name);       // &quot;doAnotherThing&quot;\n\nУ цьому коді, doSomething() має властивість name, що рівна &quot;doSomething&quot;, оскільки це оголошення функції. Вираз з анонімною функцією doAnotherThing() має name рівне &quot;doAnotherThing&quot;, тому що таке ім’я змінної, якій він був присвоєний.\nОсобливі випадки властивості name\nВідповідні імена для оголошень фукнцій та функціональних виразів знайти легко, але ECMAScript 6 іде далі, щоб впевнетись, що всі функції мають відповідні імена. Щоб зрозуміти це, розгляньте наступний приклад:\nvar doSomething = function doSomethingElse() {\n    // ...\n};\n\nvar person = {\n    get firstName() {\n        return &quot;Nicholas&quot;\n    },\n    sayName: function() {\n        console.log(this.name);\n    }\n}\n\nconsole.log(doSomething.name);      // &quot;doSomethingElse&quot;\nconsole.log(person.sayName.name);   // &quot;sayName&quot;\nconsole.log(person.firstName.name); // &quot;get firstName&quot;\n\nУ цьому прикладі,doSomething.name є &quot;doSomethingElse&quot; оскільки функціональний вираз має власне ім’я, яке має пріоритет над змінною, якій ця функція була присвоєна. Властивість name у person.sayName() рівна &quot;sayName&quot;, бо це значення було інтерпретоване з об’єктного літералу. Так само, person.firstName насправді є функцією–гетером, тож її ім’я &quot;get firstName&quot;, що вказує на цю відмінність. Функції–сетери так само позначаються через &quot;set&quot;.\nТакож є кілька інших особливих випадків для імен функцій. Функції, створені з використанням bind(), будуть мати імена з префіксованим &quot;bound&quot;, а функції, створені конструктором Function мають ім’я &quot;anonymous&quot;:\nvar doSomething = function() {\n    // ...\n};\n\nconsole.log(doSomething.bind().name);   // &quot;bound doSomething&quot;\n\nconsole.log((new Function()).name);     // &quot;anonymous&quot;\n\nname зв’язаної функції буде завжди name функції, що була зв’язана з префіксом &quot;bound &quot;, тому зв’язана версія doSomething() буде &quot;bound doSomething&quot;.\nЗапам’ятайте, що значення name для будь–якої функції не обов’язково посилається на змінну з таким самим ім’ям. Властивість name не покликана допомагати у відлагодженні, тому неможливо використати значення name для отримання посилання на функцію.\nРоз’яснення подвійної ролі функцій\nв ECMAScript 5 та раніше, функції можна було створити двома способами: з або без new. При використанні new, значення this всередині функції було новим об’єктом і цей об’єкт повертався, так як це ілюстровано в цьому прикладі:\nfunction Person(name) {\n    this.name = name;\n}\n\nvar person = new Person(&quot;Nicholas&quot;);\nvar notAPerson = Person(&quot;Nicholas&quot;);\n\nconsole.log(person);        // &quot;[Object object]&quot;\nconsole.log(notAPerson);    // &quot;undefined&quot;\n\nПри створенні notAPerson, виклик Person() без new повертає undefined (та встановлює властивість name глобального об’єкта у нестрогому режимі). В програмах на JavaScript прийнято, що Person з великої літери — це єдиний індикатор того, що функція має бути викликана з використанням new. Таке подвійне призначення функцій призводило до плутанини і тому зазнало деяких змін у ECMAScript 6.\nJavaScript має два різних внутрішніх методи для функцій: [[Call]] та [[Construct]]. Коли функція викликається без new, виконується метод [[Call]], який виконує тіло функцій так, як це описано в коді. Коли функція викликається з new, тоді викликається [[Construct]]. Метод [[Construct]] відповідальний за створення нового об’єкта, і тоді виконання тіла функції з this, встановленим для нового об’єкта. Функції, які мають метод [[Construct]] називаються конструкторами.\nI&gt; Запам’ятайте, що не всі функції мають [[Construct]], тому не всі вони можуть бути викликані з new.  Arrow–функції, про які буде йтись у відповідному розділі, не мають методу [[Construct]].\nВизначення того, як функція була викликана у ECMAScript 5\nНайпопулярніший спосіб визначити, що функція була викликана з new (а отже й з конструктором) у ECMAScript 5 — це використати instanceof, для прикладу:\nfunction Person(name) {\n    if (this instanceof Person) {\n        this.name = name;   // використано new\n    } else {\n        throw new Error(&quot;You must use new with Person.&quot;)\n    }\n}\n\nvar person = new Person(&quot;Nicholas&quot;);\nvar notAPerson = Person(&quot;Nicholas&quot;);  // кидає помилку\n\nТут значення this перевіряється, чи воно відповідає конструтору. Якщо воно відповідає, то виконання виконується так, як і слід. Якщо this не відповідає Person, тоді кидається помилка. Це працює тому, що метод [[Construct]] створює новий екземпляр Person та присвоює його в this. На жаль, такий підхід недостатньо надійний, оскільки this може відповідати Person і без використання new, наприклад:\nfunction Person(name) {\n    if (this instanceof Person) {\n        this.name = name;   // з використанням new\n    } else {\n        throw new Error(&quot;You must use new with Person.&quot;)\n    }\n}\n\nvar person = new Person(&quot;Nicholas&quot;);\nvar notAPerson = Person.call(person, &quot;Michael&quot;);    // працює!\n\nВиклику Person.call() передається змінна person в якості першого аргументу, що означає this встановлений в person всередині функції Person. Для функцій немає ніякого способу відрізнити це від виклику з new.\nМетавластивість new.target\nЩоб вирішити цю проблему, ECMAScript 6 вводить метавластивість new.target. Метавластивість — це властивість для необ’єктів, яка надає додаткову інформацію, яка стосується цільового об’єкта (як от new). Коли метод [[Construct]] функції викликаний, new.target заповнюється цільовим об’єктом оператора new. Цей цільовий об’єкт є зазвичай новоствореним екземпляром об’єкту, який стає this всередині тіла функції. Якщо виконано [[Call]], тоді new.target буде undefined.\nЦя нова метавластивість дозволяє вам безпечно перевіряти, чи функція була викликана з new, простою перевіркою того, чи було встановлено new.target є:\nfunction Person(name) {\n    if (typeof new.target !== &quot;undefined&quot;) {\n        this.name = name;   // з використанням new\n    } else {\n        throw new Error(&quot;You must use new with Person.&quot;)\n    }\n}\n\nvar person = new Person(&quot;Nicholas&quot;);\nvar notAPerson = Person.call(person, &quot;Michael&quot;);    // помилка!\n\nЗ використанням new.target замість this instanceof Person, конструктор Person тепер кидатиме помилку при використанні без new.\nВи також можете перевірити, чи new.target було викликано з певним конструктором. Для прикладу:\nfunction Person(name) {\n    if (typeof new.target === Person) {\n        this.name = name;   // використовуючи new\n    } else {\n        throw new Error(&quot;You must use new with Person.&quot;)\n    }\n}\n\nfunction AnotherPerson(name) {\n    Person.call(this, name);\n}\n\nvar person = new Person(&quot;Nicholas&quot;);\nvar anotherPerson = new AnotherPerson(&quot;Nicholas&quot;);  // помилка!\n\nУ цьому прикладі, new.target мусить бути Person для коректної роботи. Коли new AnotherPerson(&quot;Nicholas&quot;) створюється, new.target встановлюється в AnotherPerson, тому наступний виклик Person.call(this, name) кине помилку попри те, що new.target буде встановлено.\nW&gt; Увага: використання new.target поза функцією призведе до помилки.\nДодаючи new.target, ECMAScript 6 допомагає прояснити деякі незрозумілості, пов’язані з викликом функцій. Продовжуючи тему, ECMAScript 6 також вводить раніше незрозумілу частину мови — оголошення функцій всередині блоків.\nБлочні функції\nУ ECMAScript 3 та раніше оголошення функції всередині блоку (блочні функції) технічно було синтаксичною помилкою, проте всі браузери продовжували підтримувати це. На жаль, кожен браузер, що дозволяв такий синтаксис, поводився по різному, тому було прийнято уникати оголошення функцій всередині блоків (найкращою альтернативою було використання функціональних виразів).\nНамагаючись обмежети таку несумісну поведінку, строгий режим в ECMAScript 5 призводив до помилки при кожному оголошенні функції всередині блока:\n&quot;use strict&quot;;\n\nif (true) {\n\n    // Кидає синтаксичну помилку у ES5, але не в ES6\n    function doSomething() {\n        // ...\n    }\n}\n\nУ ECMAScript 5 такий код кидає синтаксичну помилку. У ECMAScript 6 функція doSomething() розглядається як блочне оголошення і може бути доступною та викликаною всередині блока, в якому вона була оголошена. Наприклад:\n&quot;use strict&quot;;\n\nif (true) {\n\n    console.log(typeof doSomething);        // &quot;function&quot;\n\n    function doSomething() {\n        // ...\n    }\n\n    doSomething();\n}\n\nconsole.log(typeof doSomething);            // &quot;undefined&quot;\n\nБлочні функції виринають на вершину блока, в якому вони були оголошені, тому typeof doSomething повертає &quot;function&quot;, не дивлячись на те, що ця інструкція знаходиться перед оголошенням функції. Як тільки блок if закінчить виконання, doSomething() більше не існуватиме.\nКоли використовувати блочні функції\nБлочні функції схожі на функціональні вирази з let. За умови такого визначення, функції видаляються, як тільки хід виконання програми виходить з блока, у якому вони були оголошені. Основна відмінність у тому, що блочні функції виринають на вершину блока, у якому вони оголошені. Функціональні вирази, що використовують let, не виринають, як це показано у цьому прикладі:\n&quot;use strict&quot;;\n\nif (true) {\n\n    console.log(typeof doSomething);        // кине помилку\n\n    let doSomething = function () {\n        // ...\n    }\n\n    doSomething();\n}\n\nconsole.log(typeof doSomething);\n\nТут виконання коду зупиниться, коли typeof doSomething буде виконано, оскільки оператор let  ще не було виконано, залишивши doSomething() у ТМЗ. Знанючи цю відмінність, ви можете обирати, де використовувати блочні функції, а де вирази з let, в залежності від того, чи потрібне вам виринання, чи ні.\nБлочні функції у нестрогому режимі\nECMAScript 6 також дозволяє блочні функції у нестрогому режимі, але з дещо іншою поведінкою. Замість виринання цього оголошення на вершину блока, вони будуть виринати на вершину функції або глобального оточення, в якому містяться. До прикладу:\n// Поведінка ECMAScript 6\nif (true) {\n\n    console.log(typeof doSomething);        // &quot;function&quot;\n\n    function doSomething() {\n        // ...\n    }\n\n    doSomething();\n}\n\nconsole.log(typeof doSomething);            // &quot;function&quot;\n\nУ цьому прикладі, doSomething() виринає у глобальну область видимості, тому вона існує поза блоком if. ECMAScript 6 стандартизує цю поведінку, щоб прибрати несумісну поведінку браузерів, яка існувала до цього, тож всі оточення ECMAScript 6 повинні працювати однаково.\nМожливість використання блочних функцій розширює ваші можливості оголошення функцій у JavaScript, проте ECMAScript 6 також вводить абсолютно новий спосіб оголошення функцій.\nArrow–функції\nОднією з найцікавіших частин ECMAScript 6 є arrow–функції. Arrow–функції — це, як можна здогадатись, функції, що оголошуються з новим синтаксисом, який використовує стрілку (&quot;arrow&quot;) (=&gt;). Проте arrow–функції мають кілька важливих відмінностей від JavaScript–функцій:\n\nЖодних this, super, arguments та new.target зв’язувань – значення this, super, arguments та new.target всередині функції наслідується від найближчої зовнішньої не–arraw–функції. (super буде розгянуто у Главі 4.)\nНе можуть викликатись з new - аrrow–функції не мають методу [[Construct]], і тому не можуть використовуватись у якості конструкторів. Arrow–функції кидають помилку при використанні з new.\nЖодних прототипів - оскільки ви не можете використовувати new з arrow–функцією, немає потреби у прототипі. Властивості prototype у arrow–функції не існує.\nНе можна змінювати this - значення this всередині функції не може змінюватись. Воно залишається незмінним протягом усього життєвого циклу функції.\nЖодного об’єкту arguments - оскільки arrow–функції не мають зв’язування з arguments, ви мусите покладатись лише на іменовані та залишкові параметри для доступу до аргументів.\nНіяких дубльованих іменованих аргументів - arrow–функції не можуть мати дубьованих іменованих параметрів у строгому та нестрогому режимах, на відміну він не–arrow–функцій, що не можуть мати їх лише у строгому режимі.\n\nЄ кілька причин для цих відмінностей. Перша і найголовніша: зв’язування this є основним джерелом помилок у JavaScript. Дуже легко загубити значення this всередині функції, що може призвести до неочікуваної поведінки програми. Arrow–функції позбавляють нас цієї проблеми. Друге полягає у тому, що arrow–функцій можуть лише виконувати код з єдиним значенням this. Рушії JavaScript можуть легше оптимізувати такі операції, на відміну від звичайних функцій, які можуть бути використані в якості конструктора, або бути модифікованим іншим чином.\nРешту відмінностей спрямовані на те, щоб скоротити помилки та невизначеності пов’язані з arrow–функціями. Завдяки цьому JavaScript рушії зможуть краще оптимізувати виконання arrow–фукнцій.\nI&gt; Зауважте: Arrow–також мають властивість name, яка формується за тим же правилом, як і в інших функцій.\nСинтаксис аrrow–фукнцій\nСинтаксис arrow–функцій може бути різним в залежності від того, якого результату ви намагаєтесь досягти. Усі варіанти починаються з аргументів функції, за якими слідує стрілка, за якою слідує тіло функції. Як аргументи, так і тіло можуть набувати різного вигляду, в залежності від використання. До прикладу, наступна arrow–функція приймає один аргумент та просто повертає його:\nvar reflect = value =&gt; value;\n\n// простіший запис для:\n\nvar reflect = function(value) {\n    return value;\n};\n\nКоли arrow–функція приймає лише один аргумет, цей один аргумент можна використовувати без будь–якого іншого синтаксису. Далі слідує стрілка та вираз праворуч від стрілки, який буде обчислено та повернено. Не дивлячись на відсутність інструкції return, ця arrow–функція поверне перший аргумент, який було передано.\nЯкщо ви передаєте більше, ніж один аргумент, то повинні огорнути їх круглими дужками, ось так:\nvar sum = (num1, num2) =&gt; num1 + num2;\n\n// простіший запис для:\n\nvar sum = function(num1, num2) {\n    return num1 + num2;\n};\n\nФункція sum() просто додає два аргументи та повертає результат. Єдина відмінність між цією arrow–фунцією та функцією reflect() — аргументи знаходяться в круглих дужках та розділені комами (як і в звичайних функціях).\nЯкщо функція не приймає аргументів, тоді ви повинні залишити порожні круглі дужки, як показано у прикладі:\nvar getName = () =&gt; &quot;Nicholas&quot;;\n\n// простіший запис для:\n\nvar getName = function() {\n    return &quot;Nicholas&quot;;\n};\n\nЯкщо вам потрібне більш традиційне тіло функції, що, можливо, складається з більше, ніж одного виразу, тоді вам потрібно огорнути тіло функції у фігурні дужки та безпосередньо вказати значення, яке має бути повернутим, як у цій версії sum():\nvar sum = (num1, num2) =&gt; {\n    return num1 + num2;\n};\n\n// простіший запис для:\n\nvar sum = function(num1, num2) {\n    return num1 + num2;\n};\n\nТак чи інакше, ви можете розглядати все, що між фігурними дужками, як звичайну фукнцію, за вийнятком того, що arguments в ній буде недоступний.\nЯкщо ви хочете створити функцію, яка не робить нічого, тоді вам потрібно написати порожні фігурні дужки:\nvar doNothing = () =&gt; {};\n\n// простіший запис для:\n\nvar doNothing = function() {};\n\nФігурні дужки використовуються для опису тіла функції і працюють так само, як ви вже бачили в попередніх прикладах. Проте arrow–функція, що повертає літерал об’єкта, має знаходитись у круглих дужках. Наприклад:\nvar getTempItem = id =&gt; ({ id: id, name: &quot;Temp&quot; });\n\n// простіший запис для:\n\nvar getTempItem = function(id) {\n\n    return {\n        id: id,\n        name: &quot;Temp&quot;\n    };\n};\n\nЗнаходження літералу об&#39;єкта у круглих дужках сигналізує, що фігурні дужки є літералом об’єкту, а не тілом функції.\nСтворення негайно–виконуваних функціональних виразів\nОдним з найпопулярніших застосувань функцій в JavaScript є створення негайно–виконуваних функціональних виразів (НВФВ). НВФВ дозволяють вам визначати анонімну функцію та викликати її миттєво, без збереження посилання. Такий підхід стає в нагоді, коли вам потрібно зробити область видимості, захищену від решти програми. Наприклад:\nlet person = function(name) {\n\n    return {\n        getName: function() {\n            return name;\n        }\n    };\n\n}(&quot;Nicholas&quot;);\n\nconsole.log(person.getName());      // &quot;Nicholas&quot;\n\nУ цьому коді, НВФВ використовується, щоб створити об’єкт з методом getName(). Цей метод повертає значення name, роблячи name приватним значенням об’єкта, що повертається.\nВи можете зробити те саме, використовуючи arrow–функції, огорнувши її у круглі дужки:\nlet person = ((name) =&gt; {\n\n    return {\n        getName: function() {\n            return name;\n        }\n    };\n\n})(&quot;Nicholas&quot;);\n\nconsole.log(person.getName());      // &quot;Nicholas&quot;\n\nЗауважте, що круглі дужки охоплюють лише вираз arrow–функції, не враховуючи (&quot;Nicholas&quot;). Це відмінність від звичайних функцій, з якими круглі дужки також можуть огортати параметри, що передаються.\nЖодного зв’язування this\nОдне з найбільших джерел проблем у JavaScript — це зв’язування this всередині функцій. Оскільки значення this всередині функції може змінюватись в залежності від контексту, в якому функція викликається, можливо помилково вплинути на один об’єкт, тоді як ви мали на увазі зовсім інший. Розгляньте такий приклад:\nvar PageHandler = {\n\n    id: &quot;123456&quot;,\n\n    init: function() {\n        document.addEventListener(&quot;click&quot;, function(event) {\n            this.doSomething(event.type);     // помилка\n        }, false);\n    },\n\n    doSomething: function(type) {\n        console.log(&quot;Handling &quot; + type  + &quot; for &quot; + this.id);\n    }\n};\n\nУ цьому коді, об’єкт PageHandler створений для обробки взаємодій зі сторінкою. Метод init() викликається для встановлення обробника події і передає керування до this.doSomething(). Однак цей код не працює так, як очікується.\nВиклик this.doSomething() не спрацює, оскільки this є посиланням на об’єкт, на який була спрямована подія (у цьому випадку document), що був пов’язаний з PageHandler. Якщо ви спробуєте запустити цей код, ви отримаєте помилку, оскільки this.doSomething() не існує в контексті об’єкту document.\nВи можете виправити це зв’язуванням значення this з PageHandler через  використання методу bind(), ось так:\nvar PageHandler = {\n\n    id: &quot;123456&quot;,\n\n    init: function() {\n        document.addEventListener(&quot;click&quot;, (function(event) {\n            this.doSomething(event.type);     // немає помилки\n        }).bind(this), false);\n    },\n\n    doSomething: function(type) {\n        console.log(&quot;Handling &quot; + type  + &quot; for &quot; + this.id);\n    }\n};\n\nТепер цей код працює так, як очікувалось, проте виглядає дещо дивно. Викликаючи bind(this), ви насправді створюєте нову функцію, в якої this є зв’язаним з поточним this, яким є PageHandler. Щоб запобігти створенню додаткової фунції, краще скористатись arrow–функцією.\nArrow—функція не має зв’язування з this. Це означає, що значення this всередині arrow–функції визначається ланцюжком областей видимості. Якщо arrow–функція міститься всередині не–arrow–функції, this буде таким, як у зовнішньої функції. В іншому випадку, this буде не заданим (undefined). Ось один зі способів написати цей код з допомогою arrow–функції:\nvar PageHandler = {\n\n    id: &quot;123456&quot;,\n\n    init: function() {\n        document.addEventListener(&quot;click&quot;,\n                event =&gt; this.doSomething(event.type), false);\n    },\n\n    doSomething: function(type) {\n        console.log(&quot;Handling &quot; + type  + &quot; for &quot; + this.id);\n    }\n};\n\nОбробник події у цьому випадку є arrow–функцією, що викликає this.doSomething(). Значення this є таким самим, як і всередині init(), тому такий код працюватиме так само, як і при використанні bind(this). Навіть хоча метод doSomething() не повертає ніякого значення, він є лише однією інструкцією в тілі функції, тому немає потреби огортати його в фігурні дужки.\nArrow–функції є тимчасовими, тому не можуть бути використаними для задання типів — це наслідок відсутності властивості prototype, яку мають звичайні функції. Якщо ви спробуєте використати оператор new з arrow–функцією, ви отримаєте помилку, як у цьому прикладі:\nvar MyType = () =&gt; {},\n    object = new MyType();  // помилка - ви не можете використовувати arrow–функції з &#39;new&#39;\n\nУ цьому коді, виклик new MyType() падає, оскільки MyType є arrow–функцією і тому не має внутрішнього методу [[Construct]]. Знання того, що arrow–функції не можуть використовуватись з new, дозволяє рушіям JavaScript проводити глибшу оптимізацію їх поведінки.\nТакож, оскільки значення this визначається з зовнішньої функції, в якій arrow–функція є визначеною, ви не можете змінити значення this з допомогою call(), apply() або bind().\nArrow–функції та масиви\nЛаконічний синтакс arrow–функцій робить їх ідеальними для операцій над масивами. До прикладу, якщо ви хочете посортувати масив за власною умовою, ви могли б написати щось таке:\nvar result = values.sort(function(a, b) {\n    return a - b;\n});\n\nЗанадто багато синтаксису для такої простої процедури. Порівняйте це з більш короткою версією, що використовує arrow–функції:\nvar result = values.sort((a, b) =&gt; a - b);\n\nМетоди масивів, що приймають функції зворотнього виклику, як от sort(), map() та reduce(), отримають набагато більше користі від використання arrow–функції, які замінюють здавалося би складні процеси простим кодом.\nНіякого зв’язування arguments\nХоча arrow–функції не мають власного об’єкту arguments, вони можуть звертатись до об’єкта arguments з батьківської функції. Цей об’єкт arguments буде доступний незалежно від того, коли arrow–функція буде потім виконана. Наприклад:\nfunction createArrowFunctionReturningFirstArg() {\n    return () =&gt; arguments[0];\n}\n\nvar arrowFunction = createArrowFunctionReturningFirstArg(5);\n\nconsole.log(arrowFunction());       // 5\n\nВсередині createArrowFunctionReturningFirstArg() створена arrow–функція звертається до елемента arguments[0]. Це посилання містить перший аргумент, що був переданий у функцію createArrowFunctionReturningFirstArg(). Якщо arrow–функція виконається пізніше, вона поверне 5, що і було першим аргументом преданим в createArrowFunctionReturningFirstArg(). Хоча й arrow–функція більше не в області видимості функції, що створила її, arguments залишається доступним через ланцюжок контекстів ідентифікатора arguments.\nІдентифікація аrrow–функцій\nНе дивлячись на інший синтакс, arrow–функції є функціями і також можуть бути ідентифікуваними. Розгляньте такий код:\nvar comparator = (a, b) =&gt; a - b;\n\nconsole.log(typeof comparator);                 // &quot;function&quot;\nconsole.log(comparator instanceof Function);    // true\n\nВивід console.log() демонструє, що, як typeof, так і instanceof з arrow–функціями поводяться однаково, як і з іншими функціями.\nТакож, як і з іншими функціями, ви можете використовувати call(), apply() та bind() на arrow–функціями, хоча this-зв’язування цих функцій не працюватиме. Ось кілька прикладів:\nvar sum = (num1, num2) =&gt; num1 + num2;\n\nconsole.log(sum.call(null, 1, 2));      // 3\nconsole.log(sum.apply(null, [1, 2]));   // 3\n\nvar boundSum = sum.bind(null, 1, 2);\n\nconsole.log(boundSum());                // 3\n\nФункція sum() викликається з використанням call() та apply() для передачі аргументів так, як ви могли б це зробити з будь–якою іншою функцією. Метод bind() використовується, щоб створити boundSum(), яка матиме два прив’язаних аргументи 1 та 2, тож немає необхідності передавати їх безпосередньо.\nArrow–функції доцільно використовувати всюди, де ви зараз використовуєте анонімні функціональні вирази, як ось функції зворотнього виклику. Наступний розділ розгляне інше суттєве покращення ECMAScript 6, яке є внутрішнім і не має нового синтаксису.\nОптимізація хвостового виклику\nНапевно найцікавішою зміною в функціях ECMAScript 6 є оптимізація, яка змінює систему хвостового виклику. Хвостовий виклик (tail call) — це коли функція викликається як остання інструкція в іншій функції, ось так:\nfunction doSomething() {\n    return doSomethingElse();   // хвостовий виклик\n}\n\nХвостовий виклик імплементований у рушіях ECMAScript 5, обробляється так само, як і виклик будь–якої іншої функції: новий зліпок виклику, що представляє виклик функції, створюється і зберігається в стек викликів. Це означає, що кожен попередній зліпок зберігається в пам’яті, тому це стає проблемою, коли стек викликів стає надто великим.\nУ чому відмінність?\nECMAScript 6 прагне скоротити розмір стеку для певних хвостових викликів у строгому режимі (у нестрогому режимі хвостові виклики залишаються недоторканими). З такою оптимізацією, замість того щоб створювати новий зліпок для хвостового виклику в стеку, поточний зліпок очищується і перевикористовується доти, доки будуть виконані такі умови:\n\nХвостовий виклик не потребує доступу до змінних у поточному зліпку (тобто функція не є замиканням)\nФункція, що робить хвостовий виклик, не робить нічого після повернення результату хвостового виклику\nРезультат хвостового виклику повертається як значення функції\n\nЯк приклад, такий код легко буде оптимізованийм, оскільки він відповідає всім трьом критеріям:\n&quot;use strict&quot;;\n\nfunction doSomething() {\n    // оптимізовано\n    return doSomethingElse();\n}\n\nЦя функція робить хвостовий виклик doSomethingElse(), відразу ж повертає результат та не звертається до змінних у локальній області видимості. Одна маленька зміна — не повернення результату — і функція залишеться неоптимізованою:\n&quot;use strict&quot;;\n\nfunction doSomething() {\n    // не оптимізовано - не повертає нічого\n    doSomethingElse();\n}\n\nТак само, якщо ви маєте функцію, що виконує операцію після повернення результату хвостового виклику, тоді функція не буде оптимізованою:\n&quot;use strict&quot;;\n\nfunction doSomething() {\n    // не оптимізовано - додавання після поверненя результату\n    return 1 + doSomethingElse();\n}\n\nЦей приклад додає 1 до результату doSomethingElse() перед поверненням значення, а цього досить, щоб припинити оптимізацію.\nІншим частим способом ненавмисно вимкнути оптимізацію є збереження результату виклику функції у змінну і потім повернути її значення, як ось тут:\n&quot;use strict&quot;;\n\nfunction doSomething() {\n    // не оптимізовано - виклик не є хвостовим\n    var result = doSomethingElse();\n    return result;\n}\n\nЦей приклад не може бути оптимізованим, оскільки значення doSomethingElse() не повертається відразу.\nМожливо, найважче уникнути ситуації з використанням замикань. Оскільки замикання має звертатись до змінних із зовнішньої області видимості, хвостова оптимізація може вимкнутись. До прикладу:\n&quot;use strict&quot;;\n\nfunction doSomething() {\n    var num = 1,\n        func = () =&gt; num;\n\n    // не оптимізовано - функція є замиканням\n    return func();\n}\n\nУ цьому прикладі, замикання func() звертається до локальної змінної num. Навіть хоча виклик func() відразу повертає результат, оптимізація не може бути виконаною через звертання до змінної num.\nЯк опанувати оптимізацію звостового виклику\nНа практиці, оптимізація хвостового виклику відбувається за кулісами, тож вам не слід думати про це, допоки ви не спробуєте оптимізувати функцію. Основним застосуванням оптимізації хвостових викликів є рекурсивні функції — це той випадок, коли оптимізація матиме значний ефект. Розгляньте цю функцію, яка обчислює факторіал:\nfunction factorial(n) {\n\n    if (n &lt;= 1) {\n        return 1;\n    } else {\n\n        // не оптимізовано - множення після повернення результату\n        return n * factorial(n - 1);\n    }\n}\n\nТака версія функції не може бути оптимізованою, оскільки після рекурсивного виклику factorial() відбувається множення. Якщо n дуже велике число, розмір стек виклику зростатиме і потенційно може спричинити перемовнення стеку.\nУ відповідності до оптимізації функцій, вам потрібно впевнетись, що множення не відбувається після останнього виклику функції. Щоб зробити це, ви можете скористатись параметром за замовчуванням, щоб винести операцію множення з оператора return. Отримана функція передає тимчасовий результат до наступної ітерації, тому ця функція поводиться так само, але може бути оптимізованою рушієм ECMAScript 6. Ось новий код:\nfunction factorial(n, p = 1) {\n\n    if (n &lt;= 1) {\n        return 1 * p;\n    } else {\n        let result = n * p;\n\n        // оптимізовано\n        return factorial(n - 1, result);\n    }\n}\n\nУ цій переписаній версії factorial(), другий аргумент p додається як параметр зі значенням за замовчуванням рівним 1. Параметр p зберігає результат попереднього множення, тому наступний результат може бути обчислений без виклику функції. Коли n більше за 1, спершу відбувається множення, і тоді результат передається у якості другого аргументу factorial(). Це дозволяє рушію ECMAScript 6 оптимізувати рекурсивний виклик.\nОптимізація хвостового виклику це те, про що вам сліду думати тоді, коли ви пишете рекурсивну функцію, тому що це дає суттєвий покращення продуктивності, особливо при застосуванні масивних обчислювальних функцій.\nПідсумок\nФункції не зазнали величезних змін у ECMAScript 6. Це, скоріше, ряд поступових змін, які полегшують роботу з ними.\nПараметри за замовчуванням дозволяють вам легко задавати значення, які будуть використовуватись тоді, коли аргумент не передається. До ECMAScript 6 це потребувало би додаткового надлишкового коду всередині функції для перевірки наявності аргументів та присвоєння значень за замовчуванням.\nЗалишкові параметри дозволяють вам отримати масив, в якому будуть зберігатись решта переданих параметрів. Використання реального масиву та можливість визначати, які параметри мають бути включені, робить залишкові параметри набагато гнучкішем рішенням, ніж arguments.\nОператор розкладу є схожим до залишкових параметрів і дозволяє вам розкладати масив на окремі параметри при виклику функції. До ECMAScript 6 було два шляхи передачі окремих параметрів, які зберігаються в масиві: безпосереднє задання кожного параметра або використання apply(). Використовуючи оператор розкладу, ви можете легко передати масив у будь–яку функцію, не турбуючись про контекст this цієї функції.\nДодаткова властивість name має допомогти вам легше ідентифікувати функції при пошуку помилок та аналізі. До того ж, ECMAScript 6 формально визначає поведінку блочних функцій, тому вони більше не спричинятимуть помилок у строгому режимі.\nУ ECMAScript 6 поведінка функції визначається через [[Call]] при нормальному режимі, або через [[Construct]], коли функція визначається з new. Метавластивість new.target також дозволяє вам визначати, чи функція була викликана з використанням new чи ні.\nНайбільшою зміною функцій в ECMAScript 6 було введення arrow–функцій. Arrow–функції розроблені для використання замість анонімних функціональних виразів. Arrow–функції мають більш лаконічний синтакс, лексичне this–зв’язування та не мають об’єкта arguments. Крім того, arrow–функції не можуть змінювати свій контекст this та не можуть використовуватись як конструктори.\nОптимізація хвостового виклику дозволяє оптимізувати виклики деяких функцій шляхом збереження малого стеку викликів, ощадливішим використанням пам’яті та попередженням переповнення стеку. Ця оптимізація застосовується рушієм автоматично, коли це безпечно, однак ви можете переписати рекурсивні функції у відповідності до вимог, щоб скористатись перевагами такої оптимізації.\n"},"manuscript/04-Objects.html":{"url":"manuscript/04-Objects.html","title":"Об’єкти","body":"Розширення функціональності об’єктів\nECMAScript 6 значною мірою спрямований на поліпшення функціональності об’єктів, що має зміст, адже майже будь–яке значення в JavaScript є певною мірою об’єктами. Крім того, кількість об’єктів, що використовують в пересічних JavaScript–програмах продовжує зростати разом зі збільшенням складності JavaScript–додатків, а це означає, що програми постійно створюють все більше і більше об’єктів. Зі збільшенням кількості об’єктів з’являється і необхідність використовувати їх більш ефективно.\nECMAScript 6 покращує ряд властивостей об’єктів: від простого розширення синтаксису до опцій для їх маніпулювання та взаємодії.\nКатегорії об’єктів\nJavaScript використовує змішану термінологію для опису об’єктів, які знаходяться у стандарті, на відміну від об’єктів у різноманітних оточеннях, як от у браузерах чи Node.js. Специфікація ECMAScript 6 має внести чітке визначення для кожної з категорій об’єктів. Важливо зрозуміти цю термінологію, щоб мати хороше розуміння мови в цілому. Об’єкти бувають таких категорій:\n\nЗвичайні об’єкти — мають повну поведінку за замовчуванням для об’єктів у JavaScript.\nНезвичайні об’єкти — мають внутрішню поведінку, яка певним чином відрізняється від поведінки за замовчуванням.\nСтандартні об’єкти — об’єкти визначені у ECMAScript 6, такі як Array, Date і так далі. Стандартні об’єкти можуть бути звичайними або незвичайними.\nВбудовані об’єкти — об’єкти, що присутні у середовищі виконання JavaScript, коли скрипт починає виконуватись. Всі стандартні об’єкти є вбудованими об’єктами.\n\nУ книзі я користуватимусь цією термінологією для пояснення різноманітних об’єктів, визначених у ECMAScript 6.\nРозширення синтаксису об’єктного літерала\nОб’єктний літерал є одним з найбільш популярних патернів у JavaScript. JSON побудований на його синтаксисі, і він є майже у будь—якому JavaScript–файлі в Інтернеті. Об’єктний літерал став таким популярним задяки своєму лаконічному синтаксису для створення об’єктів, що в іншому випадку могло б зайняти кілька рядків коду. На щастя розробників, ECMAScript 6 робить об’єктні літерали більш потужними та навіть більш лаконічними завдяки розширенню синтаксису кількома способами.\nСкорочення ініціалізації властивостей\nУ ECMAScript 5 та раніше, літерали об’єктів були простими колекціями пар &quot;ім&#39;я-значення&quot;. Це означало, що могли виникати дублювання тоді, коли значення властивостей вже ініціалізовані. До прикладу:\nfunction createPerson(name, age) {\n    return {\n        name: name,\n        age: age\n    };\n}\n\nФункція createPerson() створює об’єкт у якого властивість name така ж сама, як і параметр name у функції. У результаті це виглядає як дублювання name та age, хоча й один name є властивістю об’єкта, а інший встановлює значення цій властивості. Ключеві name у об’єкті, що повернеться, буде присвоєно значення, яке міститься у змінній name, а ключеві age, у об’єкті, що повернеться, буде присвоєно значення, що зберігається у змінній age.\nУ ECMAScript 6 ви можете позбутись такого дублювання завдяки скороченню ініціалізації властивостей. Коли ім’я властивості таке ж, як і ім’я локальної змінної, ви можете просто написати ім’я без двокрапки та значення. До прикладу, createPerson() може бути переписана на ECMAScript 6 ось так:\nfunction createPerson(name, age) {\n    return {\n        name,\n        age\n    };\n}\n\nКоли властивість у об’єктному літералі має лише ім’я, рушій JavaScript шукає у суміжній області видимості змінну з таким самим ім’ям. Якщо він знаходить таку, значення цієї змінної присвоюється такому ж імені у об’єктному літералі.У цьому прикладі, властивості name літералу об’єкта присвоюється значення локальної змінної name.\nТаке розширення робить ініціалізацію об’єктних літералів навіть більш лаконічною та допомагає скоротити кількість помилок, пов’язаних з іменуванням. Присвоєння властивості локальної змінної з таким же самим ім’ям є дуже поширеним патерному у JavaScript, що робить це нововведення дуже бажаним.\nЛаконічні методи\nECMAScript 6 також вдосконалює синтаксис присвоєння методів у об’єктних літералах. У ECMAScript 5 та раніше, щоб додати об’єкту метод, ви мусили задавати ім’я, а тоді повне визначення функції, ось так:\nvar person = {\n    name: &quot;Nicholas&quot;,\n    sayName: function() {\n        console.log(this.name);\n    }\n};\n\nУ ECMAScript 6 синтаксис зроблено більше лаконічним, щоб позбутись двокрапки та ключового слова function. Це означає, що ви можете переписати попередній приклад так:\nvar person = {\n    name: &quot;Nicholas&quot;,\n    sayName() {\n        console.log(this.name);\n    }\n};\n\nТакий скорочений синтаксис, який також називають синтаксисом лаконічних методів, створює метод об’єкту person точно так само, як і у попередньому прикладі. Властивості sayName() присвоюється анонімна функція, яка має точно такі ж характеристики, як і функція sayName() на  ECMAScript 5. Єдина відмінність у тому, що лаконічні методи можуть використовувати super (йтиметься пізніше у розділі «Легкий доступ до прототипу через посилання super section), тоді як нелаконічні методи не можуть.\nI&gt; Властивість name методу, що створюється з допомогою цього скорочення, є ім’ям, яке вказане перед круглими дужками. У останньому прикладі, властивістю name для person.sayName() буде &quot;sayName&quot;.\nОбчислювані імена властивостей\nУ ECMAScript 5 та раніше можна було обчислювати імена властивостей об’єкта, встановлюючи їх з допомогою квадратних дужок замість використання крапкового запису. Квадратні дужки дозволяють вам задавати імена властивостей використовуючи змінні та рядкові літерали, що можуть містити символи, які би спричинили синтаксичну помилку, якби використовувались у якості ідентифікаторів. Ось приклад:\nvar person = {},\n    lastName = &quot;last name&quot;;\n\nperson[&quot;first name&quot;] = &quot;Nicholas&quot;;\nperson[lastName] = &quot;Zakas&quot;;\n\nconsole.log(person[&quot;first name&quot;]);      // &quot;Nicholas&quot;\nconsole.log(person[lastName]);          // &quot;Zakas&quot;\n\nОскільки lastName присвоєно значення &quot;last name&quot;, обидві властивості у цьому прикладі містять пробіли, роблячи неможливим звернення до них з допомогою крапкового запису. Однак, квадратні дужки дозволяють використовувати будь–який рядок у якості ім’я властивості, тому присвоєння &quot;first name&quot; значення &quot;Nicholas&quot; та &quot;last name&quot; значення &quot;Zakas&quot; працює.\nОкрім того, ви можете використовувати рядкові літерали, безпосередньо, в якості імен властивостей об’єктних літералів, як тут:\nvar person = {\n    &quot;first name&quot;: &quot;Nicholas&quot;\n};\n\nconsole.log(person[&quot;first name&quot;]);      // &quot;Nicholas&quot;\n\nЦей патерн працює для імен властивостей, що відомі наперед і можуть бути представлені у вигляді рядкового літералу. Однак, якщо б ім&#39;я властивості &quot;first name&quot; зберігалося у змінній (як у попередньому прикладі) або обчислювалось, тоді неможливо було б задати цю властивість з допомогою об’єктного літералу у ECMAScript 5.\nУ ECMAScript 6 обчислювані імена властивостей є частиною синтаксису об’єктного літералу, і вони можуть використовуватись з допомогою тих самих квадратних дужок, що використовувались для посилання на імена властивостей у екземплярах об’єктів. Наприклад:\nvar lastName = &quot;last name&quot;;\n\nvar person = {\n    &quot;first name&quot;: &quot;Nicholas&quot;,\n    [lastName]: &quot;Zakas&quot;\n};\n\nconsole.log(person[&quot;first name&quot;]);      // &quot;Nicholas&quot;\nconsole.log(person[lastName]);          // &quot;Zakas&quot;\n\nКвадратні дужки всередині об’єктного літералу показують, що ім’я властивості має бути обчислюваним, тому його вміст обчислюється як рядок. Це означає, що ви можете також використовувати вирази ось так:\nvar suffix = &quot; name&quot;;\n\nvar person = {\n    [&quot;first&quot; + suffix]: &quot;Nicholas&quot;,\n    [&quot;last&quot; + suffix]: &quot;Zakas&quot;\n};\n\nconsole.log(person[&quot;first name&quot;]);      // &quot;Nicholas&quot;\nconsole.log(person[&quot;last name&quot;]);       // &quot;Zakas&quot;\n\nРезультатом обчислення властивостей будуть &quot;first name&quot; та &quot;last name&quot;, і ці рядки можуть використовуватись для звернення до властивостей згодом. Будь–що, що ви могли би вкласти до квадратних дужок у записі з екземплярами об’єктів, також працюватиме для обчислюваних властивостей всередині об’єктних літералів.\nНові методи\nОднією з цілей ECMAScript, починаючи з ECMAScript 5, було уникання створення нових глобальних функцій та методів у Object.prototype, а замість цього спробувати знайти об’єкти, у яких нові методи повинні бути доступними. У результаті, Глобальний Object отримав більшу кількість методів, у той час як усі інші об’єкти — ні. ECMAScript 6 вводить пару нових методів у глобального Object, які розроблені для спрощення певних завдань.\nМетод Object.is()\nКоли ви хочете порівняти два значення у JavaScript, скоріш за все, ви звикли використовувати оператор рівності (==) або оператор ідентичної рівності (===). Багато розробників надають перевагу останньому, щоб уникнути примусового зведення типів. проте навіть оператор ідентичної рівності є не зовсім точним. Наприклад, значення +0 та -0 розглядаються оператором === рівними, хоча рушії JavaScript описують їх як різні. Також NaN === NaN повертає false, що призводить до необхідності використовувати isNaN(), щоб перевірити NaN точно.\nECMAScript 6 вводить метод Object.is(), щоб компенсувати недоліки оператора ідентичної рівності. Цей метод приймає два аргументи та повертає true, якщо значення є еквівалентними. Два значення вважаються еквівалентними тоді, коли вони є мають однакові типи та значення. Ось кілька прикладів:\nconsole.log(+0 == -0);              // true\nconsole.log(+0 === -0);             // true\nconsole.log(Object.is(+0, -0));     // false\n\nconsole.log(NaN == NaN);            // false\nconsole.log(NaN === NaN);           // false\nconsole.log(Object.is(NaN, NaN));   // true\n\nconsole.log(5 == 5);                // true\nconsole.log(5 == &quot;5&quot;);              // true\nconsole.log(5 === 5);               // true\nconsole.log(5 === &quot;5&quot;);             // false\nconsole.log(Object.is(5, 5));       // true\nconsole.log(Object.is(5, &quot;5&quot;));     // false\n\nУ багатьох випадках, Object.is() працює так само як і оператор ===. Єдина відмінність полягає у тому, що +0 та -0 розглядаються як нееквівалентні та NaN вважається еквівалентним до NaN. Проте немає потреби переставати використовувати оператори рівності зовсім. Визначайте коли користуватись Object.is() замість == або ===, виходячи з того, як має поводитись ваш код.\nМетод Object.assign()\nДомішки (mixins) є одним з найпопулярніших патернів для композиції об’єктів у JavaScript. У домішці один об’єкт отримує властивості та методи від іншого. Багато JavaScript–бібліотек мають метод mixin схожий на цей:\nfunction mixin(receiver, supplier) {\n    Object.keys(supplier).forEach(function(key) {\n        receiver[key] = supplier[key];\n    });\n\n    return receiver;\n}\n\nФункція mixin() ітерується по власних властивостях supplier та копіює їх до receiver (неповну копію, у якій посилання на об’єкти є загальними, тоді як значення властивостей є об’єктами). Це дозволяє receiver отримувати нові властивості без наслідування, як у цьому прикладі:\nfunction EventTarget() { /*...*/ }\nEventTarget.prototype = {\n    constructor: EventTarget,\n    emit: function() { /*...*/ },\n    on: function() { /*...*/ }\n};\n\nvar myObject = {};\nmixin(myObject, EventTarget.prototype);\n\nmyObject.emit(&quot;somethingChanged&quot;);\n\nТут myObject отримує поведінку з об’єкта EventTarget.prototype. Це дає myObject можливість публікувати події та підписуватись на них з допомогою методів emit() та on() відповідно.\nЦей патерн став досить популярним, тому ECMAScript 6 додає метод Object.assign(), який поводиться так само. Зміна імені з mixin() на assign() відображає дійсну операцію, що відбувається. Оскільки метод mixin() використовує оператор присвоєння (=), він не зможе скопіювати властивість-аксесор приймача у вигляді властивості–аксесора. Ім’я Object.assign() було обране щоб відображати цю відмінність. Однак, зауважте, що Object.assign() не копіює властивості, ключі яких є символами, які я опишу у Главі 6.\nI&gt; Схожі методи у різних бібліотеках можуть мати різні імена для одного і того ж функціоналу: популярними альтернативами є включення методів extend() та mix(). У ECMAScript 6 також був метод Object.mixin() на додачу до методу Object.assign(). Основною відмінністю було те, що Object.mixin() копіює ще й властивості-аксесори, але цей метод було виключено через можливість super (описано у розділі &quot;Легкий доступ до прототипу через посилання super&quot; цієї глави).\nВи можете використовувати Object.assign() усюди де, функція mixin() могла би використовуватись. Ось приклад:\nfunction EventTarget() { /*...*/ }\nEventTarget.prototype = {\n    constructor: EventTarget,\n    emit: function() { /*...*/ },\n    on: function() { /*...*/ }\n}\n\nvar myObject = {}\nObject.assign(myObject, EventTarget.prototype);\n\nmyObject.emit(&quot;somethingChanged&quot;);\n\nМетод Object.assign() приймає будь–яку кількість віддавачів властивостей. Приймач отримуватиме властивості у тому порядку, в якому віддавачі були вказані. Це означає, що другий віддавач може перезаписати значення з першого віддавача в отримувачі, що й ілюструє цей приклад:\nvar receiver = {};\n\nObject.assign(receiver,\n    {\n        type: &quot;js&quot;,\n        name: &quot;file.js&quot;\n    },\n    {\n        type: &quot;css&quot;\n    }\n);\n\nconsole.log(receiver.type);     // &quot;css&quot;\nconsole.log(receiver.name);     // &quot;file.js&quot;\n\nЗначенням receiver.type буде &quot;css&quot; оскільки другий віддавач перезаписав значення першого.\nМетод Object.assign() не є великим доповненням до ECMAScript 6, проте він формалізує загальну функцію, яка надається багатьма JavaScript–бібліотеками.\nA&gt; Робота з властивостями–аксесорами\nA&gt; Запам’ятайте, якщо віддавач має властивості–аксесори, то Object.assign() не створить їх у отримувачі. Оскільки Object.assign() використовує оператор присвоєння, властивість аксесора у віддавачі стане полем даних у отримувачі. Наприклад:\n var receiver = {},\n     supplier = {\n         get name() {\n             return &quot;file.js&quot;\n         }\n     };\n\n Object.assign(receiver, supplier);\n\n var descriptor = Object.getOwnPropertyDescriptor(receiver, &quot;name&quot;);\n\n console.log(descriptor.value);      // &quot;file.js&quot;\n console.log(descriptor.get);        // undefined\n\nA&gt; У цьому прикладі, supplier має властивість–аксесор під назвою name. Після використання методу Object.assign(), властивість receiver.name буде полем даних зі значенням &quot;file.js&quot;, тому що supplier.name поверне &quot;file.js&quot;, коли Object.assign() буде викликано.\nДублювання властивостей у об’єктних літералах\nСтрогий режим у ECMAScript 5 вводив перевірку дублювання властивостей у об’єктних літералах, що провокувала помилку, якщо відбувалось дублювання. Наприклад, цей код спричинив би помилку:\n&quot;use strict&quot;;\n\nvar person = {\n    name: &quot;Nicholas&quot;,\n    name: &quot;Greg&quot;        // синтаксична помилка у строгому режимі ES5\n};\n\nПри запуску у строгому режимі ECMAScript 5, друга властивість name призведе до синтаксичної помилки. Проте у ECMAScript 6, перевірка дублювання властивостей була видалена. Як у строгому так і в нестрогому режимах код більше не перевіряється на дублювання властивостей. Замість цього, значення останньої властивості з даним ім’ям стане актуальним значенням, як і показано тут:\n&quot;use strict&quot;;\n\nvar person = {\n    name: &quot;Nicholas&quot;,\n    name: &quot;Greg&quot;        // ніякої помилки у строгому режимі ES6\n};\n\nconsole.log(person.name);       // &quot;Greg&quot;\n\nУ цьому прикладі, значенням person.name буде is &quot;Greg&quot; тому, що це останнє значення присвоєне цій властивості.\nВласний порядок перелічення властивостей\nECMAScript 5 не задає порядку перелічення властивостей об’єкту — це покладалось на постачальників JavaScript–рушіїв. Однак ECMAScript 6 строго задає порядок у якому власні властивості мають повертатись, коли вони перераховані. Це впливає на те, як властивості повертаються з Object.getOwnPropertyNames() та Reflect.ownKeys (описано у Главі 12). Це також впливає на те, як властивості обробляються у Object.assign().\nБазовий порядок переліку власних властивостей такий:\n\nВсі нумеровані ключі у порядку зростання.\nВсі рядкові ключі у порядку, в якому вони були додані до об’єкту.\nВсі символьні ключі (описано у Главі 6) у порядку, в якому вони були додані до об’єкту.\n\nОсь приклад:\nvar obj = {\n    a: 1,\n    0: 1,\n    c: 1,\n    2: 1,\n    b: 1,\n    1: 1\n};\n\nobj.d = 1;\n\nconsole.log(Object.getOwnPropertyNames(obj).join(&quot;&quot;));     // &quot;012acbd&quot;\n\nМетод Object.getOwnPropertyNames() повертає властивості obj у порядку: 0, 1, 2, a, c, b, d. Зауважте, що нумеровані ключі згруповані та відсортовані, хоча в об’єктному літералі вони записані у довільному порядку. Рядкові ключі ідуть після нумерованих та в порядку, в якому їх було додано до obj. Ключі задані у об’єктному літералі йдуть попереду, за ними слідують динамічні ключі, що були додані пізніше (у цьому випадку d).\nW&gt; Цикл for-in продовжує мати незаданий порядок перелічення, оскільки не всі JavaScript–рушії реалізують його однаково. Методи Object.keys() та JSON.stringify() мають однаковий (невказаний) порядок перелічення, як і for-in.\nПорядок перелічення є маленькою зміною у тому як працює JavaScript, адже досить важко знайти програму, коректна робота якої залежить від конкретного порядку перелічення. ECMAScript 6, встановленням порядку перелічення, дозволяє бути певними, що JavaScript–код, який залежиться від порядку переліку буде працювати коректно, незалежно від того, де він виконується.\nБільш потужні прототипи\nПрототипи є фундаментом наслідування у JavaScript, а ECMAScript 6 продовжує робити прототипи більш потужними. Попередні версії JavaScript мають невелику свободу дій над прототипами. Однак зі становленням мови та тим, що розробники починали краще розуміти як працюють прототипи, стало зрозуміло, що розробники бажають більшого контролю над прототипами та легших способів роботи з ними. Як результат, ECMAScript 6 вводить кілька покращень прототипів.\nЗміна прототипу об’єкта\nЗазвичай прототип об’єкту задається під час створення об’єкту, або через конструктор, або через метод Object.create(). Ідея, що прототип об’єкту залишається незмінним після ініціалізації була однією з найбільших допущень програмування JavaScript на ECMAScript 5. ECMAScript 5 додав метод Object.getPrototypeOf() для отримання прототипу будь–якого переданого об’єкту, проте не вистачало способу зміни прототипу об’єкта після ініціалізації.\nECMAScript 6 змінює це допущення шляхом введення методу Object.setPrototypeOf(), який дозволяє змінювати прототип будь–якого переданого об’єкту. Метод Object.setPrototypeOf() приймає два аргументи: об’єкт який потрібно змінити та об’єкт, що стане його прототипом. До прикладу:\nlet person = {\n    getGreeting() {\n        return &quot;Hello&quot;;\n    }\n};\n\nlet dog = {\n    getGreeting() {\n        return &quot;Woof&quot;;\n    }\n};\n\n// person — це прототип\nlet friend = Object.create(person);\nconsole.log(friend.getGreeting());                      // &quot;Hello&quot;\nconsole.log(Object.getPrototypeOf(friend) === person);  // true\n\n// встановлюємо прототип dog\nObject.setPrototypeOf(friend, dog);\nconsole.log(friend.getGreeting());                      // &quot;Woof&quot;\nconsole.log(Object.getPrototypeOf(friend) === dog);     // true\n\nЦей код задає два базових об’єкти: person та dog. Обидва мають метод getGreeting(), що повертає рядок. Об’єкт friend спершу наслідується від об’єкту person, тому getGreeting() виводить &quot;Hello&quot;. Коли прототипом стає об’єкт dog, person.getGreeting() виводить &quot;Woof&quot; тому, що початкове відношення з person було розірване.\nДійсне значення прототипу об’єкту зберігається у суто внутрішній властивості під назвою [[Prototype]]. Метод Object.getPrototypeOf() повертає значення, що зберігається у [[Prototype]], а Object.setPrototypeOf() змінює значення, що зберігається у [[Prototype]]. Однак, це не єдиний спосіб взаємодії зі значенням [[Prototype]].\nЛегкий доступ до прототипу через посилання super\nЯк вже згадувалось раніше, прототипи дуже важливі для JavaScript і у ECMAScript 6 було зроблено багато для того, щоб зробити їх використання легшим. Ще одним покращенням є введення посилання super, яке робить легшим доступ до функціоналу прототипу. Наприклад, щоб перезаписати метод у екземпляра об’єкта, що також викликає метод прототипу з таким самим ім’ям, на ECMAScript 5 ви зробили б щось таке:\nlet person = {\n    getGreeting() {\n        return &quot;Hello&quot;;\n    }\n};\n\nlet dog = {\n    getGreeting() {\n        return &quot;Woof&quot;;\n    }\n};\n\n\nlet friend = {\n    getGreeting() {\n        return Object.getPrototypeOf(this).getGreeting.call(this) + &quot;, hi!&quot;;\n    }\n};\n\n// встановлюємо прототип person\nObject.setPrototypeOf(friend, person);\nconsole.log(friend.getGreeting());                      // &quot;Hello, hi!&quot;\nconsole.log(Object.getPrototypeOf(friend) === person);  // true\n\n// встановлюємо прототип dog\nObject.setPrototypeOf(friend, dog);\nconsole.log(friend.getGreeting());                      // &quot;Woof, hi!&quot;\nconsole.log(Object.getPrototypeOf(friend) === dog);     // true\n\nУ цьому прикладі, getGreeting() у friend викликає метод прототипа з таким самим ім’ям. Метод Object.getPrototypeOf() перевіряє чи викликається певний прототип, а тоді додатковий рядок додається до виводу. Додатковий .call(this) перевіряє чи значення this всередині прототипу встановлено коректно.\nНе забувати про використання Object.getPrototypeOf() та .call(this) для виклику методу прототипу — це дещо складно, тому ECMAScript 6 вводить super. Простота полягає у тому, що super — це вказівник на поточний прототип об’єкту, фактично значення Object.getPrototypeOf(this). Знаючи це, ви можете спростити метод getGreeting() ось так:\nlet friend = {\n    getGreeting() {\n        // у попередньому прикладі це те саме, що:\n        // Object.getPrototypeOf(this).getGreeting.call(this)\n        return super.getGreeting() + &quot;, hi!&quot;;\n    }\n};\n\nВиклик super.getGreeting() — це те саме, що Object.getPrototypeOf(this).getGreeting.call(this) у цьому контексті. Так само ви можете викликати будь–який метод прототипу об’єкта з використанням посилання super всередині лаконічного методу. Спроба використати super поза лаконічними методами призведе до синтаксичної помилки, як у цьому прикладі:\nlet friend = {\n    getGreeting: function() {\n        return super.getGreeting() + &quot;, hi!&quot;;\n    }\n};\n\nfriend.getGreeting();       // кине помилку!\n\nЦей приклад використовує іменовану властивість з функцією, тому виклик friend.getGreeting() кидає помилку, оскільки super не є валідним у цьому контексті.\nПосилання super справді є дуже потужним, коли ви маєте кілька рівнів наслідування, оскільки у цьому випадку, Object.getPrototypeOf() більше не працює для всіх випадків. Наприклад:\nlet person = {\n    getGreeting() {\n        return &quot;Hello&quot;;\n    }\n};\n\n// person — це прототип\nlet friend = {\n    getGreeting() {\n        return Object.getPrototypeOf(this).getGreeting.call(this) + &quot;, hi!&quot;;\n    }\n};\nObject.setPrototypeOf(friend, person);\n\n\n// friend — це прототип\nlet relative = Object.create(friend);\n\nconsole.log(person.getGreeting());                  // &quot;Hello&quot;\nconsole.log(friend.getGreeting());                  // &quot;Hello, hi!&quot;\nconsole.log(relative.getGreeting());                // error!\n\nЗвернення до Object.getPrototypeOf() спричинить помилку, коли relative.getGreeting() буде викликаний. Це тому, що this є relative, а прототипом relative є об’єкт friend. Коли friend.getGreeting().call() викликається з relative у якості this, процес починається знову і знову та продовжується рекурсивно доки не виникне переповнення стеку.\nЦю проблему важко вирішити у ECMAScript 5, проте з ECMAScript 6 та super це просто:\nlet person = {\n    getGreeting() {\n        return &quot;Hello&quot;;\n    }\n};\n\n// person — це прототип\nlet friend = {\n    getGreeting() {\n        return super.getGreeting() + &quot;, hi!&quot;;\n    }\n};\nObject.setPrototypeOf(friend, person);\n\n\n// friend — це прототип\nlet relative = Object.create(friend);\n\nconsole.log(person.getGreeting());                  // &quot;Hello&quot;\nconsole.log(friend.getGreeting());                  // &quot;Hello, hi!&quot;\nconsole.log(relative.getGreeting());                // &quot;Hello, hi!&quot;\n\nОскільки посилання super не є динамічним, воно завжди посилає на правильний об’єкт. У цьому випадку, super.getGreeting() завжди повертатиме person.getGreeting(), незалежно від того скільки інших об’єктів наслідують цей метод.\nФормальне визначення методів\nДо ECMAScript 6 поняття «метод» не було формально визначеним. Методами були просто властивості об’єктів, що містили функції замість даних. ECMAScript 6 формально визначає метод як функцію, що має внутрішню властивість [[HomeObject]], яка містить об’єкт, якому цей метод належить. Розгляньте наступне:\nlet person = {\n\n    // метод\n    getGreeting() {\n        return &quot;Hello&quot;;\n    }\n};\n\n// не метод\nfunction shareGreeting() {\n    return &quot;Hi!&quot;;\n}\n\nЦей приклад задає person з єдиним методом getGreeting(). [[HomeObject]] для getGreeting() буде person внаслідок присвоєння цієї функції безпосереньо до об’єкта. З іншого боку, функція shareGreeting(), не має заданого [[HomeObject]] тому, що вона не була присвоєна об’єкту під час створення. У більшості випадків, ця відмінність не є важливою, проте вона стає дуже важливою при використанні посилання super.\nБудь—яке посилання до super використовує [[HomeObject]] для визначення того, що робити. Першим кроком є виклик Object.getPrototypeOf() для [[HomeObject]], щоб отримати посилання на прототип. Потім у прототипі шукається функція з таким самим ім’ям. Нарешті встановлюється this-зв’язування і метод викликається. Якщо функція не має [[HomeObject]], або має відмнінний [[HomeObject]] від очікуваного, тоді цей процес припиниться і кинуться помилки, як у цьому шматочку коду:\nlet person = {\n    getGreeting() {\n        return &quot;Hello&quot;;\n    }\n};\n\n// person — це прототип\nlet friend = {\n    getGreeting() {\n        return super.getGreeting() + &quot;, hi!&quot;;\n    }\n};\nObject.setPrototypeOf(friend, person);\n\nfunction getGlobalGreeting() {\n    return super.getGreeting() + &quot;, yo!&quot;;\n}\n\nconsole.log(friend.getGreeting());  // &quot;Hello, hi!&quot;\n\ngetGlobalGreeting();                // кидається помилка\n\nВиклик friend.getGreeting() повертає рядок, тоді як виклик getGlobalGreeting() кидає помилку про неправильне використання ключового слова super. Оскільки функція getGlobalGreeting() не має [[HomeObject]], неможливо визначити метод у наслідуваного прототипу.\nЦікаво, що ситуація не зміниться, якщо getGlobalGreeting() присвоїти як метод об’єкту friend, ось так:\n// prototype is person\nlet friend = {\n    getGreeting() {\n        return super.getGreeting() + &quot;, hi!&quot;;\n    }\n};\nObject.setPrototypeOf(friend, person);\n\nfunction getGlobalGreeting() {\n    return super.getGreeting() + &quot;, yo!&quot;;\n}\n\nconsole.log(friend.getGreeting());  // &quot;Hello, hi!&quot;\n\n// присвоюємо getGreeting глобальну функцію\nfriend.getGreeting = getGlobalGreeting;\n\nfriend.getGreeting();               // кидає помилку\n\nТут функція getGlobalGreeting() перезаписує попередньо визначений метод getGreeting() об’єкту friend. Звернення до friend.getGreeting(), у цьому випадку, також призводить до помилки, тому що тепер getGlobalGreeting() буде методом, який не має [[HomeObject]]. Значення [[HomeObject]] встановлюється лише тоді, коли функція створюється, тож навіть присвоєння методу до об’єкту не вирішує проблеми.\nПідсумок\nОб’єкти є стовпом програмування на JavaScript, а ECMAScript 6 зробив кілька корисних змін об’єктів, що роблять їх потужнішими та простішими.\nECMAScript 6 вносить кілька змін до об’єктних літералів. Скорочене визначення  властивостей спрощує присвоєння властивостям значень змінних з поточної області видимості. Обчислювані імена властивостей дозволяють вам встановлювати нелітеральні значення у якості імен властивостей так, як це було можливо в інших частинах мови. Лаконічні методи дозволяють вам писати значно менше символів для визначення методів у об’єктних літералах, шляхом упускання двокрапки та ключового слова function. ECMAScript 6 послаблює перевірку дублювання імен властивостей у об’єктних літералах, тому ви можете мати дві властивості з однаковими іменами в одному об’єкті без виникнення помилки.\nМетод Object.assign() спрощує зміну кількох властивостей одного об’єкту одночасно. Він може виявитись дуже корисним, якщо ви користуєтесь mixin–патерном. Метод Object.is() обчислює строгу рівність будь–яких значення, будучи ефектнивною та безпечнішою версією === при роботі зі спеціальними значеннями JavaScript.\nУ ECMAScript 6 тепер чітко визначений порядок перелічення властивостей. При переліченні властивостей, нумеровані ключі йдуть попереду у порядку зростання, після йдуть рядкові ключі у порядку встановлення та символьні ключі у порядку встановлення.\nЗавдяки методу Object.setPrototypeOf() тепер можливо змінювати прототип об’єкту після того, як об’єкт було створено.\nНарешті, ви можете використовувати ключове слово super для виклику методів прототипу об’єкту. Він може використовуватись як самостійно, так і з методом, як от super(), або з посиланням до самого прототипа, як от super.getGreeting(). В обох випадках, this-зв’язування буде встановлено автоматично для роботи з поточним значенням this.\n"},"manuscript/05-Destructuring.html":{"url":"manuscript/05-Destructuring.html","title":"Деструктурування","body":"Деструктурування для легшого доступу до даних\nМасиви та об’єктні літерали - два найбільш вживані види запису, а завдяки формату даних JSON вони стали особливо важливою частиною мови. Це доволі загальний спосіб задання об’єктів та масивів, а згодом і систематичної передачі відповідної інформації до цих структур. ECMAScript 6 спрощує цей процес шляхом введення деструктурування (destructuring) — процесу розбиття структури даних на менші частини. Ця глава покаже, як приборкати деструктурування як для об’єктів, так і для масивів.\nЧому деструктурування корисне?\nУ ECMAScript 5 та раніше потреба зчитати інформацію з об’єктів чи масивів в локальні змінні могла вилитись у велику кількість однакового коду. Наприклад:\nlet options = {\n        repeat: true,\n        save: false\n    };\n\n// отримання даних з об’єкту\nlet repeat = options.repeat,\n    save = options.save;\n\nЦей код отримує значення полів repeat та save з об’єкту options та зберігає ці дані у локальні змінні з відповідними іменами. Цей код виглядає просто, але уявіть, якби ви мали велику кількість змінних та полів, вам би довелось присвоювати всіх їх одне одному. А якщо дані були б ще й вкладеними, вам би довелось “прокопати” всю цю структуру лише для того, щоб знайти одну частинку даних.\nОсь чому ECMAScript 6 додає деструктурування для об’єктів та масивів. Якщо розбивати структуру даних на дрібніші шматочки, отримання потрібної інформації буде значно легшим. Багато мов імплементують деструтурування з мінімальним синтаксисом, щоб зробити цей процес простішим для використання. Імплементація ECMAScript 6 використовує синтаксис, з яким ви насправді вже знайомі: синтаксис об’єктних та масивних літералів.\nДеструктурування об’єктів\nСинтаксис деструктурування об’єктів використовує об’єктний літерал з лівого боку операції присвоєння. Наприклад:\nlet node = {\n        type: &quot;Identifier&quot;,\n        name: &quot;foo&quot;\n    };\n\nlet { type, name } = node;\n\nconsole.log(type);      // &quot;Identifier&quot;\nconsole.log(name);      // &quot;foo&quot;\n\nУ цьому коді, значення node.type зберігається у змінну type, а значення node.name у змінну name. Цей синтаксис такий самий, як і скорочення ініціалізації властивостей в об’єктних літералах, про яке ми говорили у Главі 4. Ідентифікатори type та name є оголошеннями локальних змінних та властивостями об’єкту options з яких мають бути прочитані значення.\nA&gt; Не забудьте ініціалізатор\nА&gt; При використанні деструктурування для оголошення змінних з використанням var, let або const, ви повинні вказувати ініціалізатор (значення після знаку рівності). Всі наступні рядки коду будуть кидати помилку, спричинену пропущеним ініціалізатором:\n// syntax error!\nvar { type, name };\n\n// syntax error!\nlet { type, name };\n\n// syntax error!\nconst { type, name };\n\nA&gt; Якщо const завжди потребує ініціалізатора навіть за умови використання недеструктуровних змінних, var та let потребують ініціалізаторів лише при використанні деструктурування.\nДеструктивне присвоєння\nПриклади деструктурування вище використовували оголошення змінних. Однак, можливе використання деструктурування з присвоєнням. Для прикладу, ви можете вирішити змінити значення змінних після того, як вони були задані, ось так:\nlet node = {\n        type: &quot;Identifier&quot;,\n        name: &quot;foo&quot;\n    },\n    type = &quot;Literal&quot;,\n    name = 5;\n\n// присвоєння інших значень через деструктурування\n({ type, name } = node);\n\nconsole.log(type);      // &quot;Identifier&quot;\nconsole.log(name);      // &quot;foo&quot;\n\nУ цьому прикладі, type та name ініціалізовані зі значенням, далі дві змінні з такими ж іменами були ініціалізовані з іншими значеннями. Наступний рядок використовує деструктивне присвоєння для зміни цих значень шляхом читання з об’єкту node. Зауважте, що вам необхідно взяти вираз деструктивного присвоєння у круглі дужки. Це тому, що відкриваючі фігурні дужки сприймаються як початок блоку операторів, а блок операторів не може стояти у лівій частині присвоєння. Круглі дужки сигналізують про те, що фігурні дужки, які слідують за ними, не є блоком операторів і мають бути інтерпретовані як вираз, дозволяючи тим самим виконувати присвоєння.\nВираз деструктивного присвоєння приймає значення правої частини виразу (після =). Це означає, що ви можете використовувати деструктивне присвоєння всюди, де очікується значення. Наприклад, при передачі значення у функцію:\nlet node = {\n        type: &quot;Identifier&quot;,\n        name: &quot;foo&quot;\n    },\n    type = &quot;Literal&quot;,\n    name = 5;\n\nfunction outputInfo(value) {\n    console.log(value === node);        // true\n}\n\noutputInfo({ type, name } = node);\n\nconsole.log(type);      // &quot;Identifier&quot;\nconsole.log(name);      // &quot;foo&quot;\n\nФункція outputInfo() викликається з виразом деструктивного присвоєння. Вираз приймає значення node, оскільки воно знаходиться у лівій частині виразу. Присвоєння значень в type та name поводиться так само, як і передача nodeв якості аргументу outputInfo().\nW&gt; Якщо права частина деструктивного присвоєння (вираз після =) приймає значення null або undefined, це призведе до помилки. Це станеться тому, що будь–яка спроба зчитати властивість з null або undefined призведе до помилки виконання.\nЗначення за замовчуванням\nЗа використання деструктивного присвоєння, якщо ви вказуєте локальну змінну з ім’ям властивості, що не існує в об’єкті, тоді цій локальній змінній буде присвоєне значення undefined. Для прикладу:\nlet node = {\n        type: &quot;Identifier&quot;,\n        name: &quot;foo&quot;\n    };\n\nlet { type, name, value } = node;\n\nconsole.log(type);      // &quot;Identifier&quot;\nconsole.log(name);      // &quot;foo&quot;\nconsole.log(value);     // undefined\n\nЦей код задає додаткову локальну змінну value та намагається присвоїти їй значення. Однак, в об’єкті node немає відповідної властивості value, тому очікувано, що цій змінній буде присвоєне значення undefined.\nЗа бажанням ви можете вказати значення за замовчуванням, що використовуватиметься, якщо певної властивості не існує. Щоб зробити це, скористайтесь знаком рівності (=) після ім’я властивості та вкажіть значення за замовчуванням, ось так:\nlet node = {\n        type: &quot;Identifier&quot;,\n        name: &quot;foo&quot;\n    };\n\nlet { type, name, value = true } = node;\n\nconsole.log(type);      // &quot;Identifier&quot;\nconsole.log(name);      // &quot;foo&quot;\nconsole.log(value);     // true\n\nУ цьому прикладі змінній value присвоюється true в якості значення за замовчуванням. Це значення використовується лише тоді, коли властивості немає в node, або вона має значення undefined. Оскільки властивості node.value немає, змінна value використовує значення за замовчуванням. Це працює так само, як і значення за замовчуванням для функцій, які ми розглянули у Главі 3.\nПрисвоєння локальним змінним з іншими іменами\nДо цього моменту кожен приклад деструктуруючого присвоєння використовував властивості об’єктів в якості назв локальних змінних: для прикладу, значення node.type зберігалось у змінній type. Це чудово, якщо ви хочете використовувати таке ж саме ім’я, але що якщо для вас це небажано? ECMAScript 6 має розширений синтаксис, що дозволяє присвоювати значення локальним змінним з іншими іменами, і він виглядає так, як звичайний об’єктний літерал без використання скороченого запису для властивостей. Ось приклад:\nlet node = {\n        type: &quot;Identifier&quot;,\n        name: &quot;foo&quot;\n    };\n\nlet { type: localType, name: localName } = node;\n\nconsole.log(localType);     // &quot;Identifier&quot;\nconsole.log(localName);     // &quot;foo&quot;\n\nЦей код використовує деструктивне присвоєння, щоб оголосити змінні localType та localName, які будуть містити значення властивостей node.type та node.name, відповідно. Запис type: localType каже, що потрібно зчитати властивість з ім’ям type та зберегти її значення у змінній localType. Такий синтаксис є ефективно протилежним до традиційного синтаксису об’єктних літералів, в яких ім’я властивості знаходиться ліворуч від двокрапки, а її значення — праворуч. У цьому випадку, ім’я змінної знаходиться праворуч від двокрапки, а поле з якого має бути зчитане значення знаходиться ліворуч.\nВи також можете додавати значення за замовчуванням у цьому випадку. Знак рівності та значення за замовчуванням, у цьому випадку, також знаходитимуться після ім’я локальної змінної. Наприклад:\nlet node = {\n        type: &quot;Identifier&quot;\n    };\n\nlet { type: localType, name: localName = &quot;bar&quot; } = node;\n\nconsole.log(localType);     // &quot;Identifier&quot;\nconsole.log(localName);     // &quot;bar&quot;\n\nТут, змінна localName має значення за замовчуванням &quot;bar&quot;. Цій змінній буде присвоєно значення за замовчуванням, оскільки властивості node.name немає.\nВи вже ознайомились з тим, як працювати з деструктуруванням об’єктів, властивості яких є примітивними значеннями. Проте деструктурування о’єктів може діставати значення і з вкладених структур об’єктів.\nДеструктурування вкладених об’єктів\nЗ використанням синтаксису, що схожий на об’єктні літерали, ви можете діставати з вкладених об’єктів ту інформацію, яка вам потрібна. Наприклад:\nlet node = {\n        type: &quot;Identifier&quot;,\n        name: &quot;foo&quot;,\n        loc: {\n            start: {\n                line: 1,\n                column: 1\n            },\n            end: {\n                line: 1,\n                column: 4\n            }\n        }\n    };\n\nlet { loc: { start }} = node;\n\nconsole.log(start.line);        // 1\nconsole.log(start.column);      // 1\n\nУ цьому прикладі шаблон деструктурування використовує фігурні дужки, які вказують, що шаблону слід спуститись у властивість loc об’єкта node та знайти там властивість start. Пам&#39;ятайте з попереднього розділу про те, що кожного разу, коли у шаблоні деструктурування використовується двокрапка, це означає, що ідентифікатор перед двокрапкою позначає місце звідки потрібно дістати інформацію, а правій стороні присвоюється значення. Якщо після двокрапки стоїть фігурна дужка, це означає, що потрібна властивість є властивістю вкладеного об’єкту.\nВи також можете поглиблюватись і використовувати інші імена для локальних змінних:\nlet node = {\n        type: &quot;Identifier&quot;,\n        name: &quot;foo&quot;,\n        loc: {\n            start: {\n                line: 1,\n                column: 1\n            },\n            end: {\n                line: 1,\n                column: 4\n            }\n        }\n    };\n\n// дістаємо node.loc.start\nlet { loc: { start: localStart }} = node;\n\nconsole.log(localStart.line);   // 1\nconsole.log(localStart.column); // 1\n\nУ цьому коді, node.loc.start зберігається у новій локальній змінній з ім’ям localStart. Шаблон деструктурування може мати довільний рівень вкладненості, з усіма можливостями, що доступні на кожному з рівнів.\nДеструктурування об’єктів є дуже потужним і має багато опцій, проте деструктурування масивів пропонує деякі унікальні властивості, що дозволяють діставати інформацію з масивів.\nA&gt; Синтаксична особливість\nA&gt; Будьте обережні з використанням вкладеного деструктурування, оскільки ви можете ненароком створити оператор, що не створює жодного ефекту. Порожні фігурні дужки дозволені при деструктуруванні об’єктів, однак вони не роблять нічого. Наприклад:\n// не оголошує жодної змінної!\nlet { loc: {} } = node;\n\nA&gt; Немає жодного зв’язування у цьому операторі. Оскільки справа знаходяться фігурні дужки, loc сприймається як вказівка де шукати значення, а не як змінна, яку потрібно створити. В цьому випадку, ймовірно була необхідність вказати значення за замовчуванням з використанням =, ніж використовувати :, яка вказує де шукати властивості. Цілком можливо, що такий синтаксис буде забороненим у майбутньому, проте, зараз — це синтаксична особливість.\nДеструктурування масивів\nСинтаксис декструктурування масивів дуже схожий на деструктурування об’єктів і відрізняється тим, що використовує синтаксис літералів масивів замість синтаксису об’єктних літералів. Деструктурування оперує позиціями в масиві замість іменованих властивостей, які доступні в об’єктах. Наприклад:\nlet colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];\n\nlet [ firstColor, secondColor ] = colors;\n\nconsole.log(firstColor);        // &quot;red&quot;\nconsole.log(secondColor);       // &quot;green&quot;\n\nТут деструктурування масиву витягує значення &quot;red&quot; та &quot;green&quot; з масиву colors і зберігає їх в змінних firstColor та secondColor. Ці значення вибрані через їхні позиції в масиві, а значення локальних змінних можуть бути будь–якими. Елементи, які не були явно вказані у шаблоні деструктурування, будуть проігноровані. Також запам&#39;ятайте, що деструктурування не змінює масив жодним чином.\nВи, також, можете упускати елементи у шаблоні деструктурування і передати ім’я змінної, яка вам потрібна. Якщо, наприклад, вам потрібний третій елемент масиву, немає потреби підставляти імена для першого та другого елементів. Ось як це працює:\nlet colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];\n\nlet [ , , thirdColor ] = colors;\n\nconsole.log(thirdColor);        // &quot;blue&quot;\n\nЦей код використовує деструктивне присвоєння, щоб дістати третій елемент з colors. Коми, що передують thirdColor у цьому шаблоні, займають місце елементів, що йдуть перед ним. Ви, коли використовуєте цей підхід, можете легко отримувати значення з будь–якої кількості комірок всередині масиву без потреби передавати імена змінних для них.\nW&gt; Як і для випадку з об’єктами, ви обов’язково повинні забезпечити ініціалізатор за використання деструктурування масиву з var, let або const.\nДеструктивне присвоєння\nВи можете використовувати деструктурування масивів і в контексті присвоєння, проте, на відміну від деструктурування об’єктів, немає потреби брати вираз у круглі дужки. Наприклад:\nlet colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ],\n    firstColor = &quot;black&quot;,\n    secondColor = &quot;purple&quot;;\n\n[ firstColor, secondColor ] = colors;\n\nconsole.log(firstColor);        // &quot;red&quot;\nconsole.log(secondColor);       // &quot;green&quot;\n\nДеструктивне присвоєння у цьому коді працює так само, як і в передостанньому прикладі деструктурування масиву. Єдина відмінність полягає у тому, що firstColor та secondColor вже були задані. У більшості випадків, це все, що вам потрібно знати про деструктивне присвоєння з масивами, проте є ще дещо, що може бути для вас корисним.\nДеструктивне присвоєння масивів можна використовувати для зміни місцями значень двох змінних. Зміна значень місцями є загальною операцією в алгоритмах сортування. В ECMAScript 5, щоб змінити місцями значення двох змінних, потрібно було вводити третю, тимчасову змінну, як у цьому прикладі:\n// Зміна місцями значень у ECMAScript 5\nlet a = 1,\n    b = 2,\n    tmp;\n\ntmp = a;\na = b;\nb = tmp;\n\nconsole.log(a);     // 2\nconsole.log(b);     // 1\n\nТимчасова змінна tmp необхідна для зміни місцями значень a та b. Однак, з використанням деструктивного присвоєння зникає потреба в додатковій змінній. Ось як ви можете переставляти місцями значення у ECMAScript 6:\n// Зміна місцями значень у ECMAScript 6\nlet a = 1,\n    b = 2;\n\n[ a, b ] = [ b, a ];\n\nconsole.log(a);     // 2\nconsole.log(b);     // 1\n\nДеструктивне присвоєння у цьому прикладі виглядає як дзеркальне відображення. Ліва частина присвоєння (до знаку рівності) є шаблоном деструктурування так само, як і у інших прикладах з деструктуруванням. Права частина є літералом масиву, що тимчасово створений для зміни значень місцями. Деструктурування виконується над тимчасовим масивом, який містить значення b та a в якості першого та другого елементу. Результатом є те, що значення цих змінних міняються місцями.\nW&gt; Як і у випадку з деструктуруванням об’єктів, якщо права частина виразу деструктивного присвоєння приймає значення null або undefined це призведе до помилки.\nЗначення за замовчуванням\nДеструктивне присвоєння дозволяє вам вказати значення за замовчуванням для будь–якого елемента масиву. Значення за замовчуванням використовується тоді, коли властивість у вказаній позиції не існує, або її значення рівне undefined. Наприклад:\nlet colors = [ &quot;red&quot; ];\n\nlet [ firstColor, secondColor = &quot;green&quot; ] = colors;\n\nconsole.log(firstColor);        // &quot;red&quot;\nconsole.log(secondColor);       // &quot;green&quot;\n\nУ цьому коді масив colors має лише один елемент, тому жоден елемент не відповідає secondColor. Оскільки є значення за замовчуванням для secondColor, йому встановлюється значення &quot;green&quot; замість undefined.\nВкладене деструктурування\nВи можете деструктурувати вкладені масиви таким же чином, як це робиться при деструктуруванні об’єктів. Деструктурування заглибиться у вкладений масив, якщо вставити шаблон масиву у загальний шаблон деструктурування, ось так:\nlet colors = [ &quot;red&quot;, [ &quot;green&quot;, &quot;lightgreen&quot; ], &quot;blue&quot; ];\n\n// потім\n\nlet [ firstColor, [ secondColor ] ] = colors;\n\nconsole.log(firstColor);        // &quot;red&quot;\nconsole.log(secondColor);       // &quot;green&quot;\n\nТут змінна secondColor посилається на значення &quot;green&quot; всередині масиву colors. Цей елемент знаходиться всередині іншого масиву, тому у деструктуруючому шаблоні обов’язкові квадратні дужки довкола secondColor. Як у випадку з об’єктами, вкладеність масивів може мати довільну глибину.\nЗалишкові (rest) елементи\nГлава 3 вводила поняття залишкових параметрів (rest–параметрів) для функцій. Деструктурування масивів має схожу концепцію — залишкові елементи або (rest–елементи). Залишкові елементи використовують синтаксис ... для присвоєння елементів, що залишились у масиві певній змінній. Ось приклад:\nlet colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];\n\nlet [ firstColor, ...restColors ] = colors;\n\nconsole.log(firstColor);        // &quot;red&quot;\nconsole.log(restColors.length); // 2\nconsole.log(restColors[0]);     // &quot;green&quot;\nconsole.log(restColors[1]);     // &quot;blue&quot;\n\nПерший елемент colors присвоюється firstColor, а решта елементів присвоюються новому масиву restColors. Відповідно масив restColors має два елементи: &quot;green&quot; та &quot;blue&quot;. Залишкові елементи корисні для того, щоб діставати з масиву певні елементи і залишати решту доступними, проте, є ще один спосіб використання.\nОчевидним недоліком масивів у JavaScript є можливість їх легкого клонування. У ECMAScript 5 розробники часто використовували метод concat() у якості легкого способу клонувати масив. До прикладу:\n// клонування масиву ECMAScript 5\nvar colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];\nvar clonedColors = colors.concat();\n\nconsole.log(clonedColors);      //&quot;[red,green,blue]&quot;\n\nОскільки метод concat() створений для конкатинації двох масивів, його виклик без аргументів поверне копію поточного масиву. У ECMAScript 6 для цього ви можете використовувати залишкові елементи. Це працює ось так:\n// клонування масиву ECMAScript 6\nlet colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];\nlet [ ...clonedColors ] = colors;\n\nconsole.log(clonedColors);      //&quot;[red,green,blue]&quot;\n\nУ цьому прикладі, залишкові елементи використовуються для копіювання значень з масиву colors у масив clonedColors. Хоча це й залежить від сприйняття, такий підхід значно краще відображає наміри розробника, ніж використання методу concat(). Це корисна можливість, про яку вам слід знати.\nW&gt; Залишкові елементи повинні йти останніми при деструктуруванні масивів — після них не можна ставити коми. Кома після залишкових елементів призведе до синтаксичної помилки.\nЗмішане деструктурування\nДеструктурування об’єктів та масивів можна використовувати разом для створення більш складних виразів. Використовуючи його ви маєте можливість діставати ту частину інформації, яка вам потрібна, з будь–якої комбінації об’єктів та масивів. До прикладу:\nlet node = {\n        type: &quot;Identifier&quot;,\n        name: &quot;foo&quot;,\n        loc: {\n            start: {\n                line: 1,\n                column: 1\n            },\n            end: {\n                line: 1,\n                column: 4\n            }\n        },\n        range: [0, 3]\n    };\n\nlet {\n    loc: { start },\n    range: [ startIndex ]\n} = node;\n\nconsole.log(start.line);        // 1\nconsole.log(start.column);      // 1\nconsole.log(startIndex);        // 0\n\nЦей код дістає node.loc.start та node.range[0] у змінні start та startIndex відповідно. Пам’ятайте, що loc: та range: у шаблоні деструктурування є лише відповідними властивостями об’єкту node. Немає такої частини node, яку не можна було би дістати з допомогою комбінування деструктурування об’єктів та масивів. Такий підхід, зокрема, зручний для отримання значень з JSON структур, без необхідності проходу по всій структурі.\nДеструктивні параметри\nДеструктурування має ще один корисний спосіб використання — передача аргументів у функцію. Коли функція у JavaScript приймає велику кількість параметрів, загальноприйнятим є створення об’єкту options, властивості якого задають додаткові параметри, ось так:\n// властивості options є додатковими параметрами\nfunction setCookie(name, value, options) {\n\n    options = options || {};\n\n    let secure = options.secure,\n        path = options.path,\n        domain = options.domain,\n        expires = options.expires;\n\n    // код, що встановлює cookie\n}\n\n// третій аргумент передає аргументи у опції\nsetCookie(&quot;type&quot;, &quot;js&quot;, {\n    secure: true,\n    expires: 60000\n});\n\nБагато JavaScript–бібліотек містять функції, що схожі на функцію setCookie(). У цій функції аргументи name та value є обов’язковими, проте secure, path, domain та expires — ні. Оскільки перелік додаткових даних не важливий, ефективно було б просто мати об’єкт options з іменованими властивостями, аніж список додаткових іменованих параметрів. Такий підхід працює, але ви не можете сказати, якого вводу очікує функція, якщо просто подивитись на її оголошення — вам необхідно читати тіло функції.\nДеструктивні параметри пропонують альтернативу, яка краще показує, які аргументи очікує функція. Деструктивні параметри використовують шаблон деструктурування масиву або об’єкту на місці іменованого параметру. Щоб побачити це у дії, подивіться на переписану версію функції setCookie() з останнього прикладу:\nfunction setCookie(name, value, { secure, path, domain, expires }) {\n\n    // код, що встановлює cookie\n}\n\nsetCookie(&quot;type&quot;, &quot;js&quot;, {\n    secure: true,\n    expires: 60000\n});\n\nТака функція поводиться точно так само, як у попередньому прикладі, проте тепер третій аргумент використовує деструктурування для отримання необхідних даних. Параметри поза деструктивним параметром є чітко зрозумілими, і, в той же час, для будь—кого, хто використовує функцію setCookie(), зрозуміло, які опції вона очікує. І звісно, третій аргумент є обов’язковим, а значення, які він повинен містити, є чітко зрозумілими. Деструктивні параметри також поводяться як звичайні параметри, тобто, якщо вони не будуть передані, їх значення будуть рівні undefined.\nA&gt; Деструктивні параметри мають усі можливості, про які ви дізнались з цієї глави. Ви можете використовувати значення за замовчуванням, змішувати шаблони масивів та об’єктів та використовувати імена змінних, що відмінні від властивостей, з яких ви читаєте дані.\nОбов’язковість деструктивних параметрів\nОсобливістю використання деструктивних параметрів є те, що за замовчуванням, якщо не передати їх при виклику функції, буде кинута помилка. Такий виклик функції setCookie() з попереднього прикладу кине помилку:\n// Помилка!\nsetCookie(&quot;type&quot;, &quot;js&quot;);\n\nТут третій аргумент був упущений, і тому очікувано, що він приймає значення undefined. Це спричиняє помилку, оскільки деструктивні параметри насправді є лише скороченням оголошення деструктурування. Коли викликається функція setCookie(), рушій JavaScript насправді робить таке:\nfunction setCookie(name, value, options) {\n\n    let { secure, path, domain, expires } = options;\n\n    // код, що встановлює cookie\n}\n\nДеструктурування кидає помилку, коли права частина виразу приймає значення null або undefined, а саме це і стається, коли третій аргумент не передається у функцію setCookie().\nЯкщо ви хочете, щою деструктивний параметр був обов’язковим, тоді така поведінка не буде для вас проблемною. Проте, якщо вам потрібно, щоб деструктивний параметр був опціональним, ви можете обійти таку поведінку, просто передавши значення за замовчування для деструктивного параметру, ось так:\nfunction setCookie(name, value, { secure, path, domain, expires } = {}) {\n\n    // ...\n}\n\nУ цьому прикладі в якості значення за замовчуванням для третього параметру передається новий об’єкт. Передача цього значення за замовчуванням означає, що secure, path, domain та expires завжди будуть undefined, якщо у setCookie() не було передано третього аргументу, а тому помилка кидатись не буде.\nЗначення за замовчуванням для деструктивних параметрів\nВи можете вказувати значення за замовчуванням для деструктивних параметрів точно так само, як ви би це робили з деструктивним присвоєнням. Просто додайте знак рівності після параметру і вкажіть значення за замовчуванням. Наприклад:\nfunction setCookie(name, value,\n    {\n        secure = false,\n        path = &quot;/&quot;,\n        domain = &quot;example.com&quot;,\n        expires = new Date(Date.now() + 360000000)\n    } = {}\n) {\n\n    // ...\n}\n\nТепер кожна властивість у деструктивному параметрів має власне значення за замовчуванням, тож ви можете не перевіряти, чи дана властивість має допустиме значення. Крім того, третій параметр є опціональним, оскільки самий деструктивний параметр має порожній об’єкт у якості значення за замовчуванням. Це робить оголошення функції дещо складнішим для сприйняття, проте це невелика ціна за те, щоб кожен з аргументів мав допустиме значення.\nПідсумок\nДеструктурування полегшує роботу з об’єктами та масивами у JavaScript. Ви, коли використовуєте схожий синтаксис літералів об’єктів та масивів, можете розбивати структури даних на частини, щоб отримати потрібну інформацію. Шаблони об’єктів дозволяють вам діставати дані з об’єктів, а шаблони масивів, відповідно, з масивів.\nЯк для об’єктів, так і для масивів, при деструктуруванні ви можете задавати значення за замовчуванням для будь–яких властивостей або елементів, що мають значення undefined, інакше в обох випадках, якщо права частина присвоєння приймає значення null або undefined, буде кинута помилка. Ви також можете діставати данні з вкладених структур даних.\nДеструктурування, що оголошують змінні через var, let або const, обов’язково повинні мати ініціалізатор. Деструктивні присвоєння використовуються для того, щоб записати значення властивостей об’єктів у змінні, які вже існують.\nДеструктивні параметри використовують, щоб зробити об’єкт “опцій” у параметрах функцій більш зрозумілим. Допоміжні параметри, які вам потрібні, можуть бути перераховані в одному ряду з іншими іменованими параметрами. Шаблон деструктурування може бути шаблоном масиву, об’єкту, або комбінацією масиву та об’єкту. Для кожного з випадків ви можете використовувати всі можливості  деструктурування.\n"}}}