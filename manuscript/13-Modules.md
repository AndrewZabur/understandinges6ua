# Модулі

Одним з найбільш схильних до помилок і заплутаних аспектів JavaScript вже давно є "shared everything" підхід до завантаження коду. У той час як інші мови мають такі поняття, як пакети, JavaScript відстав, і все, що визначається в кожному файлі поділяє єдину глобальну область видимості. В той час, коли веб-додатки стали більш складними, а кількість використання JavaScript виросла, "shared everything" підхід почав виявляти проблеми з конфліктами імен, проблеми безпеки та багато іншого. Однією з цілей ECMAScript 6 було вирішення цієї проблеми, і наведення порядку в додатках JavaScript. Ось тут і з’являються модулі.

## Що таке модулі?

*Модулі* — це JavaScript файли, які завантажені спеціальним чином (на відміну від *скриптів*, які завантажуються звичайним для JavaScript чином). На час мого написання, ані браузери, ані Node.js не мали засобів для завантаження модулів ECMAScript 6, але обидва вказували, що повинна бути певна можливість це робити. Причина необхідності цієї опції в тому, що файли модулів мають досить відмінну від файлів не-модулів семантику:

1. код модуля автоматично запускається в строгому режимі і не має ніякого способу, щоб відмовитися від строгого режиму;
1. змінні, створені на вищому рівні модуля, не додаються автоматично до загальної глобальної області видимості. Вони існують тільки в межах вищого рівня модуля;
1. значення `this` в віому рівні модуля — `undefined`;
1. модулі не дозволяють використання коментарів в стилі HTML у коді (можливість, що залишилась з перших днів браузерів);
1. модулі повинні експортувати будь-щоб що має бути доступне за межами модуля.

Відмінності можуть казатися маленькими на перший погляд, але вони представляють собою значну зміну того, як JavaScript завантажується й обробляється.

Файли JavaScript модулів створюються так само, як і інші JavaScript фали: в текстовому редакторі та, зазвичай, з розширенням `.js`. Відмінність під час розробки в тому, що ви використовуєте трохи інший синтаксис.

## Основи експорту та імпорту

Ключове слово `export` використовується, щоб надавати частини опублікованого коду іншим модулям. В найпростішому випадку, ви можете поставити `export` на початку оголошення будь-якої змінної, функції, або класу, щоб експортувати їх з модуля. Наприклад:

```js
// експортуємо дані
export var color = "red";
export let name = "Nicholas";
export const magicNumber = 7;

// експортуємо функцію
export function sum(num1, num2) {
    return num1 + num1;
}

// експортуємо клас
export class Rectangle {
    constructor(length, width) {
        this.length = length;
        this.width = width;
    }
}

// це привата функція модуля
function subtract(num1, num2) {
    return num1 - num2;
}

// визначаємо функцію
function multiply(num1, num2) {
    return num1 * num2;
}

// експортуємо пізніше
export multiply;
```

Є декілька речей, на які треба зважати в цьому приклді:

1. кожне оголошення значить те саме, що й повинно значити без слова `export`;
1. оголошення функції й класу потребують ім’я. Ви не можете експортувати анонімні функції або класи, використовуючи такий синтаксис (принаймні, без використання ключового слова `default`, яке буде розглянуте далі в цьому розділі);
1. ви не повинні завжди експортувати оголошення, ви також можете експортувати посилання, як у випадку з `multiply` в цьому прикладі;
1. будь-які змінні, функції, чи класи, які явно не експортовані залишаються приватними для модуля. В цьому прикладі, `subtract()` не експортовано і залишається в подальшому недосяжним за межами модуля.

Важливим обмеженням `export` є те, що воно має бути використане на вищому рівні модуля. Наприклад, це — синтаксична помилка:

```js
if (flag) {
    export flag;    // синтаксична помилка
}
```

Цей приклад є синтаксичною помилкою тому, що `export` знаходиться всередині виразу `if`. Експорти не можуть буди частинами умовних висловів або створюватися динамічно іншим чином. Чистина переваг синтаксису модуля полягає в тому, що JavaScript рушій може статично визначити, що буду експортовано. Ось чому, ви можете використовувати `export` тільки на вищому рівні модуля.

W> Якщо ви користуєтесь компілятором на кшталт Babel.js, ви можете зауважити, що `export` може бути використано будь-де. Це працює тільки, коли код конвертується в ECMAScript 5 і не буде працювати з справжньою системою модулів ECMAScript 6.

Якщо ви маєте модуль з експортами, ви здатні використовувати експортований функціонал в іншому модулі за допомогою ключового слова `import`. Оголошення `import` має дві частини: ідентифікатори того, що ви імпортуєте та модуль, звідки ті ідентифікатори мають буду імпортовані. Загальна форма має такий вигляд:

```js
import { identifier1, identifier2 } from "module";
```

Фігурні дужки після `import` позначають ідентифікатори, які треба імпортувати з вказаного модуля. Ключове слово `from` використане, щоб позначити модуль з якого будуть імпортовані вказані ідентифікатори. Модуль визначається з використанням рядка. На момент мого написання, все ще не визначено, як мають виглядати ідентифікатори модулів. Можливо це мають бути повні шляхи файлів (як "../mymodule.js"), шляхи файлів без розширення (як "../mymodule"), або щось інше. Певно, це не буде визначено доки браузери й Node.js не реалізують модулі природнім шляхом.

I> Не зважаючи на те, що він виглядає подібно, список ідентифікаторів імпорту не є неструктурованим об’єктом.

При імпорті ідентифікатора з модуля, ідентифікатор діє так, якби його було визначено за допомогою `const`. Це означає, що ви не можете визначити іншу змінну з тим же ім'ям, використовуйте ідентифікатор до оголошення `import`, або змініть його значення.

Припустимо, що перший приклад в даному розділі знаходиться в модулі з ім'ям `"example"`. Ви можете імпортувати і використовувати ідентифікатори з цього модуля кількома шляхами. Ви можете просто імпортувати один ідентифікатор:

```js
// імпортуємо тільки один ідентифікатор
import { sum } from "example";

console.log(sum(1, 2));     // 3

sum = 1;        // помилка
```

Цей приклад імпортує тільки `sum()` з модуля `"example"`. Навіть якщо припустити, що модуль експортує більше, ніж просто одну функцію, ці експорти не вказані тут. Якщо ви спробуєте надати нове значення `sum`, результатом буде помилка тому, що ви не можете перевизначити імпортовані ідентифікатори.

Якщо ви хочете імпортувати кілька ідентифікаторів з модуля `"example"`, ви можете явно перерахувати їх:

```js
// множинний імпорт
import { sum, multiply, magicNumber } from "example";
console.log(sum(1, magicNumber));   // 8
console.log(multiply(1, 2));        // 2
```

Тут з модуля `"example"` імпортуються три ідентифікатора: `sum`,` multiply` і `magicNumber`. Потім вони використовуються, якщо б вони були локально визначені.

Ось також особливий випадок, який дозволяє імпортувати весь модуль як єдиний об'єкт. Всі експорти будуть доступні в цьому об'єкті в якості властивостей. Наприклад:

```js
// імпортуємо все
import * as example from "example";
console.log(example.sum(1,
        example.magicNumber));          // 8
console.log(example.multiply(1, 2));    // 2
```

В цьому коді весь модуль `"example"` завантажено в об’єкт названий `example`. Вказані експорти `sum()`, `multiple()` та `magicNumber` є доступними, як властивості в `example`.

Майте на увазі, що код всередині модуля буде виконуватися тільки один раз, незалежно від того, скільки разів він використовується в оголошенні `import`. Зверніть увагу на таке:

```js
import { sum } from "example";
import { multiply } from "example";
import { magicNumber } from "example";
```

Незважаючи на те, що є три оголошення `import` в даному модулі, код з `"example"` буде виконуватися тільки один раз. Ініційований модуль потім зберігається в пам'яті й буде повторно використовуватися при кожному наступному оголошенні `import`. Не має значення, чи оголошення `import` всі в одному модулі, або розподілені за кількома модулями — всі вони будуть використовувати той самий екземпляр модуля.

## Перейменування імпортів і експортів

Іноді оригінальна назва змінної, функції або класу не те, що ви хочете використовувати. Можна змінити назву експорту, як під час експорту так і, коли ідентифікатор імпортується.

У першому випадку, припустимо, що у вас є функція, яку ви хотіли б експортувати з іншим ім'ям. Ви можете використовувати ключове слово `as`, щоб вказати ім'я, під яким функція повинна бути відома за межами модуля:

```js
function sum(num1, num2) {
    return num1 + num2;
}

export { sum as add };
```

Тут, функція `sum()` (`sum` — це *локальне ім’я*) експортована як `add()` (`add` — це *експортоване ім’я*). Це означає, що, коли інший модуль хоче імпортувати цю функцію, він має використовувати ім'я `add`:

```js
import { add } from "example";
```

Якщо модуль при імпорті функції хоче використовувати для неї інше ім’я, він також може використовувати `as`:

```js
import { add as sum } from "example";
console.log(typeof add);            // "undefined"
console.log(sum(1, 2));             // 3
```

Цей код імпортує функцію `add()` (*імпортоване ім’я*) та перейменовує її на `sum()` (локальне ім’я). Це означає, зо в цьому модулі біль не має ідентифікатора з ім’ям `add`.

A> ### Імпортовані зв’язування
A>
A> Тонкий, але важливий момент, стосовно оголошень `import` є те, що вони створюють зв’язування для змінних, функцій і класів, а не просто посилання на них. Це означає, що навіть якщо ви не можете змінити імпортований ідентифікатор, він все ще може змінитися сам по собі. Наприклад, припустимо, що у вас є такий модуль:
A>
A> ```js
A> export var name = "Nicholas";
A> export function setName(newName) {
A>     name = newName;
A> }
A> ```
A>
A> Коли ви імпортуєте `name` та `setName()`, ви можете бачити, що `setName()` може змінити значення `name`:
A>
A> ```js
A> import { name, setName } from "example";
A>
A> console.log(name);       // "Nicholas"
A> setName("Greg");
A> console.log(name);       // "Greg"
A>
A> name = "Nicholas";       // error
A> ```
A>
A> Виклик `setName("Greg")` повертається назад до модуля, з якого `setName()` було експортовано та виконується там, встановлюючи `name` до `"Greg"`. Зауважте, ця зміна автоматично відбивається на імпортоване `name` зв’язування. Це тому, що `name` є локальним ім’ям для експортованого ідентифікатора *name*, таким чином вони не є тотожними речами.

## Замовчування для експортів та імпортів

Синтаксис модуля також оптимізований для експорту та імпорту значеннь за замовчуванням з модулів. Значення за замовчуванням для модуля є простою змінною, функцією або класом, яку визначено за допомогою ключового слова `default`. Наприклад:

```js
export default function(num1, num2) {
    return num1 + num2;
}
```

Цей модуль за замовчуванням експортує функцію. Ключове слово `default` вказує на те, що це є експорт за замовчуванням і функція не вимагає ім'я, тому що сам модуль являє собою функцію.

Ви також можете вказати ідентифікатор, який буде експортом за замовчуванням за допомогою синтаксису перейменування, ось так:

```js
// те саме, що й в попередньому прикладі
function sum(num1, num2) {
    return num1 + num2;
}

export { sum as default };
```

Вираз `as default` визначає, що `sum` має бути експортом модуля за замовчуванням. Цей синтаксис є еквівалентом попередньому прикладу.

W> Ви можете мати тільки один експорт за замовчуванням для модуля. Використання ключового слова `default` з багатьма експортами буде синтаксичною помилкою.

Ви можете імпортувати значення за замовчуванням з модуля, використовуючи наступний синтаксис:

```js
// імпортуємо значення за замовчуванням
import sum from "example";

console.log(sum(1, 2));     // 3
```

Це оголошення імпорту імпортує замовчування з модуля `"example"`. Зверніть увагу, що в цьому випадку не використовуються фігурні дужки, які використовуються в цьому випадку, якби було б з експортами не за замовчуванням. Локальне ім’я `sum` використовується щоб представити функцію, яка експортується модулем. Цей синтаксис є найчистішим і, як очікується, буде домінантою формою імпорту в Інтернеті, що дозволяє використовувати вже існуючий об’єкт, як наприклад:

```js
import $ from "jquery";
```

Для модулів, які експортують як замовчування, так і один або більше експортів не за замовчуванням, ви можете імпортувати все за допомогою одного оператора. Наприклад, припустимо, що у вас є цей модуль:

```js
export let color = "red";

export default function(num1, num2) {
    return num1 + num2;
}
```

Потім ви можете імпортувати як `color`, так і замовчування, використовуючи наступне:

```js
import sum, { color } from "example";

console.log(sum(1, 2));     // 3
console.log(color);         // "red"
```

Кома відокремлює локальне ім’я для імпорту замочування від інших імпортів (які також оточенні фігурними дужками).

Так само, як для експортів замовчувань, імпорт замовчувань також може бути виконаний з використанням синтаксису перейменування:

```js
// те саме, що й в попередньому прикладі
import { default as sum, color } from "example";

console.log(sum(1, 2));     // 3
console.log(color);         // "red"
```

У цьому коді, експорт за замовчуванням (`default`) перейменовується в `sum`, а додатковий експорт `color` також імпортується. Цей приклад еквівалентний попередньому прикладу.

## Ре-експортування

Можливо, колись ви захотіли б реекспортувати те, що ваш модуль імпортув. Ви можете зробити це, використовуючи шаблони вже розглянуті в цьому розділі, такі як:

```js
import { sum } from "example";
export { sum }
```

Тим не менш, є також один оператор, який може зробити те ж саме:

```js
export { sum } from "example";
```

Ця форма `export` шукає в зазначеному модулі на оголошення `sum`, а потім експортує його. Звичайно, ви можете також вибрати для експорту інше ім'я:

```js
export { sum as add } from "example";
```

Тут `sum` імпортоване з `"example"`, а потім експортоване як `add`.

Якщо ви хочете експортувати все з іншого модуля, то ви можете використовувати шаблон `*`:

```js
export * from "example";
```

При експорті всього, ви разом з усіма експортами, що мають ім’я, експортуєте також і замовчування, які можуть вплинути на те, що ви можете експортувати з вашого модуля. Наприклад, якщо `"example"` має експорт за замовчуванням, ви будете не в змозі визначити новий експорту за замовчуванням при використанні цього синтаксису.

## Імпортування без зв’язування

Деякі модулі можуть нічого не експортувати, а замість цього, тільки вносити зміни в об'єкти в глобальній області видимості. Навіть якщо змінні верхнього рівня, функції і класи всередині модулів автоматично не потрапляють в глобальну область видимості, це не означає, що модулі не можуть отримати доступ до глобальної області. Загальні визначення вбудованих об'єктів, таких як `Array` і` Object` доступні всередині модуля і зміни до цих об'єктів будуть віддзеркалені в інших модулях.

Наприклад, припустимо, що ви хочете додати метод до всіх масивів з ім’ям `pushAll()`, ви можете визначити модуль наступним чином:

```js
// Код модуля без експортів чи імпортів
Array.prototype.pushAll = function(items) {

    // items має буду масивом
    if (!Array.isArray(items)) {
        throw new TypeError("Argument must be an array.");
    }

    // використовуємо вбудовані push() та spread оператори
    return this.push(...items);
};
```

Це дійсний модуль, навіть якщо немає експорту або імпорту. Цей код може бути використаний як в якості модуля, так і сценарію. Так як він не експортує нічого, ви можете використовувати спрощений імпорт для виконання коду модуля без імпорту будь-яких зв’язувань:

```js
import "example";

let colors = ["red", "green", "blue"];
let items = [];

items.pushAll(colors);
```

У цьому прикладі, модуль імпортується і виконується таким чином, що `pushAll()` додається до прототипу масиву. Це означає, що `pushAll()` тепер доступний для використання у всіх масивах всередині цього модуля.

I> Імпорти без зв’язування, швидше за все, будуть використовуватися для створення поліфілів та латок.

## Підсумки

ECMAScript 6 додає модулі до мови, як спосіб пакування і інкапсуляції функціональності. Модулі поводяться інакше, ніж скрипти, так як вони не змінюють глобальну область видимості їх змінними верхнього рівня, функціями і класами, і `this` є `undefined`. Для того, щоб працювати по-іншому, ніж скрипти, модулі повинні бути завантажені в інший спосіб.

Ви повинні експортувати будь-які функціональні можливості, які б ви хотіли зробити доступними для використання у модулях. Змінні, функції і класи можуть бути експортовані, також для кожного модуля допускається один експорт за замовчуванням. Після експорту, інший модуль може імпортувати всі або деякі з експортованих імен. Ці імена діють так, якби їх було визначено через `let`, і тому поводяться як блокові зв’язування, які не можуть бути повторно оголошені в тому ж модулі.

Модулі не повинні нічого експортувати, якщо вони маніпулюють чимось у глобальній області видимості. В цьому випадку, можна імпортувати з такого модуля без введення будь-яких зв’язувань у області видимості модуля.
