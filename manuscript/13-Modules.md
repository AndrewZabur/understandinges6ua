# Модулі

Одним з найбільш схильних до помилок і заплутаних аспектів JavaScript вже давно є shared everything-підхід до завантаження коду. В той час як інші мови мають такі поняття як пакети, JavaScript відстав і все, що визначається в кожному файлі поділяє єдину глобальну область видимості. Тоді, коли веб-додатки стали більш складними, а частота використання JavaScript зросла, shared everything-підхід почав виявляти проблеми з конфліктами імен, проблеми безпеки та багато іншого. Однією з цілей ECMAScript 6 було вирішення цієї проблеми і наведення порядку в додатках JavaScript. Ось тут і з’являються модулі.

## Що таке модулі?

*Модулі* — це JavaScript файли, завантажені спеціальним чином (на відміну від *скриптів*, які завантажуються звичайним для JavaScript чином). На час мого написання, ані браузери, ані Node.js не мали засобів для завантаження модулів ECMAScript 6, але обидва вказували, що повинна бути певна можливість це робити. Причина необхідності цієї опції в тому, що файли модулів мають дуже відмінну від немодульних файлів семантику:

1. Код модуля автоматично запускається в строгому режимі і немає ніякого способу, щоб відмовитися від строгого режиму.
1. Змінні, створені на вищому рівні модуля, не додаються автоматично до загальної глобальної області видимості. Вони існують лише в межах області видимості модуля.
1. Значення `this` в вищому рівні модуля — `undefined`.
1. Модулі не дозволяють використання коментарів в стилі HTML у коді (можливість, можливість, яка діє від початку існування браузера).
1. Модулі повинні експортувати будь-що, що має бути доступним за межами модуля.

Відмінності можуть здаватися незначними на перший погляд, але вони істотним чином змінюють спосіб завантаження та виконання JavaScript.

Файли JavaScript модулів створюються так само, як і інші JavaScript фали: в текстовому редакторі та, зазвичай, з розширенням `.js`. Єдина відмінність протягом розробки в тому, що ви використовуєте трохи інший синтаксис.

## Основи експорту та імпорту

Ключове слово `export` використовується, щоб надавати частини опублікованого коду іншим модулям. В найпростішому випадку ви можете поставити `export` на початку оголошення будь-якої змінної, функції або класу, щоб експортувати їх з модуля. Наприклад:

```js
// експортуємо дані
export var color = "red";
export let name = "Nicholas";
export const magicNumber = 7;

// експортуємо функцію
export function sum(num1, num2) {
    return num1 + num1;
}

// експортуємо клас
export class Rectangle {
    constructor(length, width) {
        this.length = length;
        this.width = width;
    }
}

// це приватна функція модуля
function subtract(num1, num2) {
    return num1 - num2;
}

// визначаємо функцію
function multiply(num1, num2) {
    return num1 * num2;
}

// експортуємо пізніше
export multiply;
```

Є декілька речей, на які треба звернути увагу в цьому прикладі:

1. Кожне оголошення з ключовим словом `export` є точно таким, яким воно було би без нього.
1. Оголошення функції й класу потребує ім’я. Ви не зможете експортувати анонімні функції або класи, використовуючи такий синтаксис (принаймні, без використання ключового слова `default`, яке буде розглянуте далі в цій главі).
1. Ви не повинні завжди експортувати оголошення — ви також можете експортувати посилання як у випадку з `multiply` в цьому прикладі.
1. Будь-які змінні, функції чи класи, які явно не експортовані, залишаються приватними для модуля. В цьому прикладі, `subtract()` не експортовано і залишено в подальшому недосяжним за межами модуля.

Важливим обмеженням `export` є те, що воно повинне використовуватись на вищому рівні модуля. Наприклад, це — синтаксична помилка:

```js
if (flag) {
    export flag;    // синтаксична помилка
}
```

Цей приклад є синтаксичною помилкою тому, що `export` знаходиться всередині виразу `if`. Експорти не можуть буди частинами умовних висловів або створюватися динамічно іншим чином. Чистина переваг синтаксису модуля полягає в тому, що JavaScript рушій може статично визначити, що буде експортовано. Ось чому, ви можете використовувати `export` тільки на вищому рівні модуля.

W> Якщо ви користуєтесь компілятором на кшталт Babel.js, ви можете зауважити, що `export` може бути використано будь-де. Це працює тільки, коли код конвертується в ECMAScript 5, і не працюватиме зі справжньою системою модулів ECMAScript 6.

Якщо ви маєте модуль з експортами, ви можете використовувати експортований функціонал в іншому модулі за допомогою ключового слова `import`. Оголошення `import` має дві частини: ідентифікатори, які імпортуються та модуль, звідки ті ідентифікатори мають буду імпортовані. Загальна форма має такий вигляд:

```js
import { identifier1, identifier2 } from "module";
```

Фігурні дужки після `import` позначають ідентифікатори, які треба імпортувати з вказаного модуля. Ключове слово `from` використане, щоб позначити модуль, з якого будуть імпортовані вказані ідентифікатори. Модуль визначається з використанням рядка. На момент мого написання, досі ще не визначено, як мають виглядати ідентифікатори модулів. Можливо це мають бути повні шляхи файлів (як "../mymodule.js"), шляхи файлів без розширення (як "../mymodule") або щось інше. Певно, це не буде визначено, доки браузери й Node.js не реалізують модулі природнім шляхом.

I> Незважаючи на те, що він виглядає подібно, список ідентифікаторів імпорту не є деструктивним об’єктом.

За імпортування ідентифікатора з модуля, він діє так, ніби його було визначено за допомогою `const`. Це означає, що ви не можете визначити іншу змінну з тим же ім'ям — використовуйте ідентифікатор до оголошення `import` або змініть його значення.

Припустимо, що перший приклад в даному розділі знаходиться в модулі з ім'ям `"example"`. Ви можете імпортувати і використовувати ідентифікатори з цього модуля кількома шляхами. Ви можете просто імпортувати один ідентифікатор:

```js
// імпортуємо тільки один ідентифікатор
import { sum } from "example";

console.log(sum(1, 2));     // 3

sum = 1;        // помилка
```

Цей приклад імпортує тільки `sum()` з модуля `"example"`. Навіть якщо припустити, що модуль експортує більше, ніж просто одну функцію, ці експорти не вказані тут. Якщо ви спробуєте надати нове значення `sum`, результатом буде помилка, тому що ви не можете перевизначити імпортовані ідентифікатори.

Якщо ви хочете імпортувати кілька ідентифікаторів з модуля `"example"`, ви можете явно перерахувати їх:

```js
// множинний імпорт
import { sum, multiply, magicNumber } from "example";
console.log(sum(1, magicNumber));   // 8
console.log(multiply(1, 2));        // 2
```

Тут, з модуля `"example"` імпортуються три ідентифікатори: `sum`,` multiply` і `magicNumber`. Потім вони використовуються так, наче вони були визначені локально.

Є також особлива конструкція, яка дозволяє імпортувати весь модуль як єдиний об'єкт. Усі експорти будуть доступні в цьому об'єкті як властивості. Наприклад:

```js
// імпортуємо все
import * as example from "example";
console.log(example.sum(1,
        example.magicNumber));          // 8
console.log(example.multiply(1, 2));    // 2
```

В цьому коді весь модуль `"example"` завантажено в об’єкт названий `example`. Вказані експорти `sum()`, `multiple()` та `magicNumber` є доступними, як властивості в `example`.

Майте на увазі, що код всередині модуля буде виконуватися тільки один раз, незалежно від того, скільки разів він використовується в оголошенні `import`. Зверніть увагу на таке:

```js
import { sum } from "example";
import { multiply } from "example";
import { magicNumber } from "example";
```

Незважаючи на те, що є три оголошення `import` в даному модулі, код з `"example"` буде виконуватися тільки один раз. Ініціалізований модуль потім зберігається в пам'яті й буде повторно використовуватися при кожному наступному оголошенні `import`. Немає значення, чи оголошення `import` всі в одному модулі, або розподілені за кількома модулями — всі вони будуть використовувати той самий екземпляр модуля.

## Перейменування імпортів і експортів

Іноді справжня назва змінної, функції або класу не те, що ви хочете використовувати. Можна змінити назву експорту як під час експорту, так і коли ідентифікатор імпортується.

У першому випадку, припустимо, що у вас є функція, яку ви хотіли б експортувати з іншим ім'ям. Ви можете використовувати ключове слово `as`, щоб вказати ім'я з яким функція повинна бути відома за межами модуля:

```js
function sum(num1, num2) {
    return num1 + num2;
}

export { sum as add };
```

Тут, функція `sum()` (`sum` — це *локальне ім’я*) експортована як `add()` (`add` — це *експортоване ім’я*). Це означає, що коли інший модуль хоче імпортувати цю функцію, він має використовувати ім'я `add`:

```js
import { add } from "example";
```

Якщо модуль під час імпортування функції хоче використовувати для неї інше ім’я, він також може використовувати `as`:

```js
import { add as sum } from "example";
console.log(typeof add);            // "undefined"
console.log(sum(1, 2));             // 3
```

Цей код імпортує функцію `add()` (*імпортоване ім’я*) та перейменовує її на `sum()` (локальне ім’я). Це означає, зо в цьому модулі біль не має ідентифікатора з ім’ям `add`.

A> ### Імпортовані зв’язування

A> Тонкий, але важливий момент, стосовно оголошень `import` — що вони створюють зв’язування для змінних, функцій і класів, а не просто посилання на них. Це означає, що навіть якщо ви не можете змінити імпортований ідентифікатор, він все ще може змінитися сам по собі. Наприклад, припустимо, що у вас є такий модуль:

```js
export var name = "Nicholas";
export function setName(newName) {
     name = newName;
}
```

A> Коли ви імпортуєте `name` та `setName()`, ви можете бачити, що `setName()` може змінити значення `name`:

```js
import { name, setName } from "example";

console.log(name);       // "Nicholas"
setName("Greg");
console.log(name);       // "Greg"

name = "Nicholas";       // error
```

A> Виклик `setName("Greg")` повертається назад до модуля, з якого було експортовано `setName()` та виконується там, встановлюючи `name` до `"Greg"`. Зауважте, ця зміна автоматично відображається на імпортоване `name` зв’язування. Це тому, що `name` є локальним ім’ям для експортованого ідентифікатора *name*, таким чином вони не є тотожними.

## Експортування та імпортування за замовчуванням

Синтаксис модулів також оптимізований для експорту та імпорту значень за замовчуванням. Значення за замовчуванням для модуля є простою змінною, функцією або класом, яку визначено за допомогою ключового слова `default`. Наприклад:

```js
export default function(num1, num2) {
    return num1 + num2;
}
```

Цей модуль за замовчуванням експортує функцію. Ключове слово `default` вказує на те, що цей експорт є експортом за замовчуванням, а функція не потребує імені, оскільки сама функція є модулем.

Ви також можете вказати ідентифікатор, який буде експортом за замовчуванням за допомогою синтаксису перейменування, ось так:

```js
// те саме, що й в попередньому прикладі
function sum(num1, num2) {
    return num1 + num2;
}

export { sum as default };
```

Вираз `as default` визначає, що `sum` має бути експортом за замовчуванням цього модуля. Цей синтаксис є еквівалентом попередньому прикладу.

W> Ви можете мати тільки один експорт за замовчуванням для модуля. Використання ключового слова `default` з багатьма експортами буде синтаксичною помилкою.

Ви можете імпортувати значення за замовчуванням з модуля, використовуючи наступний синтаксис:

```js
// імпортуємо значення за замовчуванням
import sum from "example";

console.log(sum(1, 2));     // 3
```

Цей оператор імпорту імпортує замовчування з модуля `"example"`. Зверніть увагу, що в цьому випадку не використовуються фігурні дужки, якби було б з експортами не за замовчуванням. Локальне ім’я `sum` використовується, щоб представити функцію, яка експортується модулем. Цей синтаксис є найчистішим і, як очікується, буде домінантою формою імпорту в Інтернеті, що дозволяє використовувати вже існуючий об’єкт, як наприклад:

```js
import $ from "jquery";
```

Для модулів, які експортують як замовчування, так і один або більше експортів не за замовчуванням, ви можете імпортувати все за допомогою одного оператора. Наприклад, припустимо, що у вас є цей модуль:

```js
export let color = "red";

export default function(num1, num2) {
    return num1 + num2;
}
```

Потім ви можете імпортувати як `color`, так і замовчування, використовуючи наступне:

```js
import sum, { color } from "example";

console.log(sum(1, 2));     // 3
console.log(color);         // "red"
```

Кома відокремлює локальне ім’я для імпорту замочування від інших імпортів (які також оточенні фігурними дужками).

Так само як для експортів замовчувань, імпорт замовчувань також може бути виконаний з використанням синтаксису перейменування:

```js
// те саме, що й в попередньому прикладі
import { default as sum, color } from "example";

console.log(sum(1, 2));     // 3
console.log(color);         // "red"
```

У цьому коді, експорт за замовчуванням (`default`) перейменовується в `sum`, а додатковий експорт `color` також імпортується. Цей приклад еквівалентний попередньому прикладу.

## Переекспортування

Може статись так, що вам потрібно буде переекспортувати щось, що ваш модуль імпортував. Ви можете зробити це, використовуючи шаблони вже розглянуті в цьому розділі, такі як:

```js
import { sum } from "example";
export { sum }
```

Тим не менш, є також один оператор, який може зробити те ж саме:

```js
export { sum } from "example";
```

Ця форма `export` шукає в зазначеному модулі оголошення `sum`, а потім експортує його. Звичайно, ви можете також вибрати для експорту інше ім'я:

```js
export { sum as add } from "example";
```

Тут `sum` імпортоване з `"example"`, а потім експортоване як `add`.

Якщо ви хочете експортувати все з іншого модуля, то ви можете використовувати шаблон `*`:

```js
export * from "example";
```

При експорті всього, ви разом з усіма експортами, що мають ім’я, експортуєте також і замовчування, які можуть вплинути на те, що ви можете експортувати з вашого модуля. Наприклад, якщо `"example"` має експорт за замовчуванням, ви будете не в змозі визначити новий експорту за замовчуванням при використанні цього синтаксису.

## Імпортування без зв’язування

Деякі модулі можуть нічого не експортувати, а, замість цього, тільки вносити зміни в об'єкти в глобальній області видимості. Навіть якщо змінні верхнього рівня, функції і класи всередині модулів автоматично не потрапляють в глобальну область видимості, це не означає, що модулі не можуть отримати доступ до неї. Загальні визначення вбудованих об'єктів, таких як `Array` і` Object`, доступні всередині модуля і зміни до цих об'єктів будуть віддзеркалені в інших модулях.

Наприклад, припустимо, що ви хочете додати метод до всіх масивів з ім’ям `pushAll()`, ви можете визначити модуль наступним чином:

```js
// Код модуля без експортів чи імпортів
Array.prototype.pushAll = function(items) {

    // items має бути масивом
    if (!Array.isArray(items)) {
        throw new TypeError("Argument must be an array.");
    }

    // використовуємо вбудовані push() та spread оператор
    return this.push(...items);
};
```

Це дійсний модуль, навіть якщо немає експорту або імпорту. Цей код може бути використаний як в якості модуля, так і сценарію. Оскільки він не експортує нічого, ви можете використовувати спрощений імпорт для виконання коду модуля без імпорту будь-яких зв’язувань:

```js
import "example";

let colors = ["red", "green", "blue"];
let items = [];

items.pushAll(colors);
```

У цьому прикладі модуль імпортується і виконується таким чином, що `pushAll()` додається до прототипу масиву. Це означає, що `pushAll()` тепер доступний для використання у всіх масивах всередині цього модуля.

I> Імпорти без зв’язування, швидше за все, будуть використовуватися для створення поліфілів та латок.

## Підсумок

ECMAScript 6 додає модулі до мови як спосіб пакування і інкапсуляції функціональності. Модулі поводяться інакше, ніж скрипти, оскільки вони не змінюють глобальну область видимості їхніми змінними верхнього рівня, функціями і класами, і `this` є `undefined`. Для того, щоб працювати не так, як скрипти, модулі повинні бути завантажені в інший спосіб.

Ви повинні експортувати будь-які функціональні можливості, які б ви хотіли зробити доступними для використання у модулях. Змінні, функції і класи можуть бути експортовані, також для кожного модуля допускається один експорт за замовчуванням. Після експорту, інший модуль може імпортувати всі або деякі з експортованих імен. Ці імена діють так, ніби їх було визначено через `let`, і тому поводяться як блокові зв’язування, які не можуть бути повторно оголошені в тому ж модулі.

Модулі не повинні нічого експортувати, якщо вони маніпулюють чимось у глобальній області видимості. В цьому випадку, можна імпортувати з такого модуля без введення будь-яких зв’язувань у області видимості модуля.
